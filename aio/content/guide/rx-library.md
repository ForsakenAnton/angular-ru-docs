{@a the-rxjs-library}
# Библиотека RxJS

Реактивное программирование - это парадигма асинхронного программирования, связанная с потоками данных и распространением изменений ( [Википедия](https://en.wikipedia.org/wiki/Reactive_programming)). RxJS (Reactive Extensions for JavaScript) - это библиотека для реактивного программирования с использованием наблюдаемых, которая облегчает составление асинхронного или основанного на обратном вызове кода. Смотрите ( [RxJS Docs](https://rxjs.dev/guide/overview)).

RxJS обеспечивает реализацию  `Observable`  тип, который необходим, пока тип не станет частью языка и пока его не поддержат браузеры. Библиотека также предоставляет служебные функции для создания и работы с наблюдаемыми. Эти вспомогательные функции могут быть использованы для:

* Преобразование существующего кода для асинхронных операций в наблюдаемые
* Перебирая значения в потоке
* Отображение значений для разных типов
* Фильтрация потоков
* Составление нескольких потоков

{@a observable-creation-functions}
## Наблюдаемые функции создания

RxJS предлагает ряд функций, которые можно использовать для создания новых наблюдаемых. Эти функции могут упростить процесс создания наблюдаемых из таких вещей, как события, таймеры, обещания и так далее. Например:


<code-example path="rx-library/src/simple-creation.ts" region="promise" header="Create an observable from a promise"></code-example>

<code-example path="rx-library/src/simple-creation.ts" region="interval" header="Create an observable from a counter"></code-example>

<code-example path="rx-library/src/simple-creation.ts" region="event" header="Create an observable from an event"></code-example>

<code-example path="rx-library/src/simple-creation.ts" region="ajax" header="Create an observable that creates an AJAX request"></code-example>

{@a operators}
## Операторы

Операторы - это функции, которые строятся на основе наблюдаемых, чтобы обеспечить сложные манипуляции с коллекциями. Например, RxJS определяет такие операторы, как  `map()`, `filter()`, `concat()`  и  `flatMap()`.

Операторы принимают параметры конфигурации и возвращают функцию, которая принимает наблюдаемый источник. Выполняя эту возвращаемую функцию, оператор наблюдает излучаемые значения исходной наблюдаемой, преобразует их и возвращает новую наблюдаемую из этих преобразованных значений. Вот простой пример:

<code-example path="rx-library/src/operators.ts" header="Map operator"></code-example>

Вы можете использовать _pipes_, чтобы связать операторов вместе. Трубы позволяют объединить несколько функций в одну функцию.  `pipe()` Функция принимает в качестве аргументов функции, которые вы хотите объединить, и возвращает новую функцию, которая при выполнении запускает составные функции в последовательности.

Набор операторов, применяемых к наблюдаемой, является рецептом, то есть набором инструкций для создания интересующих вас значений. Сам рецепт ничего не делает. Вам нужно позвонить  `subscribe()`  чтобы получить результат через рецепт.

Вот пример:

<code-example path="rx-library/src/operators.1.ts" header="Standalone pipe function"></code-example>

 `pipe()` Функция также является методом в RxJS  `Observable`, так что вы используете эту короткую форму, чтобы определить ту же операцию:

<code-example path="rx-library/src/operators.2.ts" header="Observable.pipe function"></code-example>

{@a common-operators}
### Общие операторы

RxJS предоставляет много операторов, но часто используется только несколько. Для получения списка операторов и примеров использования посетите [Документация RxJS API](https://rxjs.dev/api).

<div class="alert is-helpful">
  Обратите внимание, что для приложений Angular мы предпочитаем объединять операторов с конвейерами, а не объединять в цепочки. Цепочка используется во многих примерах RxJS.
</div>

| Площадь | Операторы |
| : ------------ | : ---------- |
| Создание |   `from `, ` fromEvent `, ` of` |
| Сочетание |  `combineLatest`, `concat`, `merge`, `startWith`, `withLatestFrom`, `zip`  |
| Фильтрация |  `debounceTime`, `distinctUntilChanged`, `filter`, `take`, `takeUntil`  |
| Преобразование |  `bufferTime`, `concatMap`, `map`, `mergeMap`, `scan`, `switchMap`  |
| Полезность |  `tap`  |
| Многоадресная рассылка |  `share`  |

{@a error-handling}
## Обработка ошибок

В добавок к  `error()`  Обработчик который вы предоставляете при подписке, RxJS предоставляет  `catchError`  Оператор который позволяет обрабатывать известные ошибки в наблюдаемом рецепте.

Например, предположим, что у вас есть наблюдаемая, которая делает запрос API и сопоставляется с ответом от сервера. Если сервер возвращает ошибку или значение не существует, выдается ошибка. Если вы поймаете эту ошибку и предоставите значение по умолчанию, ваш поток продолжит обрабатывать значения, а не выдавать ошибку.

Вот пример использования  `catchError`  оператор, чтобы сделать это:

<code-example path="rx-library/src/error-handling.ts" header="catchError operator"></code-example>

{@a retry-failed-observable}
### Повторить не удалось заметным

Где  `catchError`  Оператор предоставляет простой путь восстановления,  `retry`  оператор позволяет повторить неудачный запрос.

Использовать  `retry`  операцию перед  `catchError`  оператор . Он повторно подписывается на исходный наблюдаемый источник, который затем может повторно выполнить полную последовательность действий, приведших к ошибке. Если это включает в себя HTTP-запрос, он будет повторять этот HTTP-запрос.

Следующий преобразует предыдущий пример, чтобы повторить запрос, прежде чем поймать ошибку:

<code-example path="rx-library/src/retry-on-error.ts" header="retry operator"></code-example>

<div class="alert is-helpful">

   Не повторяйте **аутентификации** запросы, поскольку они должны инициироваться только действиями пользователя. Мы не хотим блокировать учетные записи пользователей повторными запросами на вход, которые пользователь не инициировал.

</div>

{@a naming-conventions-for-observables}
## Соглашения об именах для наблюдаемых

Поскольку приложения Angular в основном написаны на TypeScript, вы обычно будете знать, когда переменная является наблюдаемой. Хотя среда Angular не предписывает соглашение об именовании для наблюдаемых, вы часто будете видеть наблюдаемые, названные со знаком «$».

Это может быть полезно при сканировании кода и поиске наблюдаемых значений. Также, если вы хотите, чтобы свойство сохраняло самое последнее значение из наблюдаемой, может быть удобно просто использовать одно и то же имя с или без «$».

Например:

<code-example path="rx-library/src/naming-convention.ts" header="Naming observables"></code-example>
