{@a animations-transitions-and-triggers}
# Анимация переходов и триггеров

Вы узнали основы Angular анимации на [введение](guide/animations)странице.

В этом руководстве более подробно рассматриваются специальные переходные состояния, такие как  `*`  (подстановочный знак) и  `void`, и покажите, как эти специальные состояния используются для элементов, входящих и выходящих из представления.
В этой главе также рассматриваются многочисленные триггеры анимации, обратные вызовы анимации и анимация на основе последовательности с использованием ключевых кадров.

{@a predefined-states-and-wildcard-matching}
## Предопределенные состояния и сопоставление с подстановочными знаками

В Angular переходные состояния могут быть определены явно через  `state()`  функция или использование предопределенного  `*`  (подстановочный знак) и  `void`  состояния.

{@a wildcard-state}
### Wildcard состояние

Звездочка  `*`  или*подстановочный знак * соответствует любому состоянию анимации. Это полезно для определения переходов, которые применяются независимо от начального или конечного состояния HTML-элемента.

Например, переход `open => *` применяется, когда состояние элемента меняется с открытого на что-либо еще.

<div class="lightbox">
  <img src="generated/images/guide/animations/wildcard-state-500.png" alt="wildcard state expressions">
</div>

Ниже приведен другой пример кода с использованием подстановочного состояния вместе с предыдущим примером с использованием  `open`  и  `closed`  состояния.
Вместо определения каждой пары переходов между состояниями, любой переход к  `closed`  занимает 1 секунду, и любой переход к  `open`  занимает 0,5 секунды.

Это позволяет нам добавлять новые состояния без необходимости включать отдельные переходы для каждого.

<code-example header="src/app/open-close.component.ts" path="animations/src/app/open-close.component.ts" region="trigger-wildcard1" language="typescript"></code-example>

Используйте синтаксис двойной стрелки, чтобы указать переходы между состояниями в обоих направлениях.

<code-example header="src/app/open-close.component.ts" path="animations/src/app/open-close.component.ts" region="trigger-wildcard2" language="typescript"></code-example>

{@a using-wildcard-state-with-multiple-transition-states}
### Использование подстановочного состояния с несколькими состояниями перехода

В примере кнопки с двумя состояниями подстановочный знак не так полезен, потому что есть только два возможных состояния,  `open`  и  `closed`.
Состояния подстановочных знаков лучше, когда элемент в одном конкретном состоянии имеет несколько потенциальных состояний, на которые он может измениться.
Если кнопка может измениться с  `open`  для любого  `closed`  или что-то вроде  `inProgress`, использование подстановочного состояния может уменьшить объем необходимого кодирования.

<div class="lightbox">
  <img src="generated/images/guide/animations/wildcard-3-states.png" alt="wildcard state with 3 states">
</div>


<code-example path="animations/src/app/open-close.component.ts" header="src/app/open-close.component.ts" region="trigger-transition" language="typescript"></code-example>


 `* =>*` переход применяется, когда происходит любое изменение между двумя состояниями.

Переходы сопоставляются в том порядке, в котором они определены. Таким образом, вы можете применить другие переходы поверх `* =>*` (любой-любой) переход. Например, определите изменения стиля или анимации, которые будут применяться только к `open => closed` или просто `closed => open`, а затем использовать `* =>*` как запасной вариант для пар состояний, которые иначе не вызываются.

Для этого перечислите более конкретные переходы *перед*  `* =>*`.

{@a using-wildcards-with-styles}
### Использование подстановочных знаков со стилями

Используйте подстановочный знак  `*`  со стилем, который указывает анимации использовать текущее значение стиля и анимирует его. Подстановочный знак - это запасное значение, которое используется, если анимированное состояние не объявлено в триггере.

<code-example path="animations/src/app/open-close.component.ts" header="src/app/open-close.component.ts" region="transition4" language="typescript"></code-example>

{@a void-state}
### Пустое состояние

Вы можете использовать  `void`  состояние для настройки переходов для элемента, который входит или покидает страницу. Смотрите [Анимация входа и выхода из вида](#enter-leave-view).


{@a combining-wildcard-and-void-states}
### Объединение подстановочных и пустых состояний

Вы можете объединить подстановочные и недействительные состояния при переходе к триггерной анимации, которые входят и выходят страницы:

* Переход `* => void` применяется, когда элемент покидает представление, независимо от того, в каком состоянии он находился до своего ухода.

* Переход `void =>*` применяется, когда элемент входит в представление, независимо от того, какое состояние он принимает при входе.

* Подстановочный знак  `*`  соответствует*любому * состоянию, в том числе  `void`.

{@a animating-entering-and-leaving-a-view}
## Анимация входа и выхода из вида

В этом разделе показано, как анимировать элементы, входящие или выходящие из страницы.

<div class="alert is-helpful">

**Примечание.** В этом примере элемент, входящий или выходящий из представления, эквивалентен вставке или удалению из DOM.

</div>

Теперь добавьте новое поведение:

* Когда вы добавляете героя в список героев, он появляется на странице слева.
* Когда вы удаляете героя из списка, он вылетает вправо.

<code-example path="animations/src/app/hero-list-enter-leave.component.ts" header="src/app/hero-list-enter-leave.component.ts" region="animationdef" language="typescript"></code-example>

В приведенном выше коде вы применили  `void`  состояние, когда элемент HTML не присоединен к представлению.


{@a enter-leave-view}

{@a enter-and-leave-aliases}
## : введите и: оставьте псевдонимы

 `:enter ` и ` :leave` псевдонимы для `void => * ` и `* => void` переходы. Эти псевдонимы используются несколькими анимационными функциями.

<code-example hideCopy language="typescript">
transition (':enter', [ ... ]);  // alias for void =>*
transition (':leave', [ ... ]);  // alias for * => void
</code-example>

Сложнее нацелить элемент, который входит в представление, потому что его еще нет в DOM.
Итак, используйте псевдонимы  `:enter`  и  `:leave`  для целевых элементов HTML, которые вставляются или удаляются из представления.

{@a use-of-\*ngif-and-\*ngfor-with-enter-and-leave}
### Использование \ *ngIf и \*ngFor с: enter и: оставить

 `:enter` переходные прогоны, когда любой  `*ngIf`  или  `*ngFor`  просмотра размещены на странице, и  `:leave`  когда эти представления удалены со страницы.

В этом примере есть специальный триггер для анимации входа и выхода, который называется  `myInsertRemoveTrigger`  . Шаблон HTML содержит следующий код.

<code-example path="animations/src/app/insert-remove.component.html" header="src/app/insert-remove.component.html" region="insert-remove" language="typescript">
</code-example>

В файле компонента  `:enter`  transition устанавливает начальную непрозрачность 0, а затем анимирует ее, чтобы изменить эту непрозрачность до 1, когда элемент вставляется в представление.

<code-example path="animations/src/app/insert-remove.component.ts" header="src/app/insert-remove.component.ts" region="enter-leave-trigger" language="typescript">
</code-example>

Обратите внимание, что этот пример не нужно использовать  `state()`.

{@a increment-and-decrement-in-transitions}
## : приращение и: уменьшение при переходах

 `transition()` функция принимает дополнительные значения селектора,  `:increment`  и  `:decrement`  . Используйте их для запуска перехода, когда числовое значение увеличилось или уменьшилось в значении.

<div class="alert is-helpful">

**Примечание.** В следующем примере используется  `query()`  и  `stagger()`  Методы, которые обсуждаются на [сложные последовательности](guide/complex-animation-sequences#complex-sequence)странице.

</div>

<code-example path="animations/src/app/hero-list-page.component.ts" header="src/app/hero-list-page.component.ts" region="increment" language="typescript"></code-example>

{@a boolean-values-in-transitions}
## Булевы значения в переходах

Если триггер содержит логическое значение в качестве значения привязки, то это значение можно сопоставить с помощью  `transition()`  выражение, которое сравнивает  `true`  и  `false`  или  `1`  и  `0`.

<code-example path="animations/src/app/open-close.component.2.html" header="src/app/open-close.component.html" region="trigger-boolean">
</code-example>

В приведенном выше фрагменте кода HTML-шаблон связывает  `<div>`  элемент для триггера с именем  `openClose`  с выражением состояния  `isOpen`, и с возможными значениями  `true`  и  `false`  . Это альтернатива практике создания двух названных состояний  `open`  и  `close`.

В коде компонента, в  `@Component`  Метаданные под  `animations:`  свойство, когда состояние оценивается как  `true`  Значение (в данном случае означает «открытый»), высота соответствующего HTML-элемента - это стиль подстановки или значение по умолчанию. В этом случае используйте любую высоту, которая была у элемента до начала анимации. Когда элемент «закрыт», элемент анимируется на высоту 0, что делает его невидимым.

<code-example path="animations/src/app/open-close.component.2.ts" header="src/app/open-close.component.ts" region="trigger-boolean" language="typescript">
</code-example>

{@a multiple-animation-triggers}
## Несколько анимационных триггеров

Вы можете определить более одного анимационного триггера для компонента. Вы можете прикрепить триггеры анимации к различным элементам, и отношения родитель-потомок между элементами влияют на то, как и когда запускаются анимации.

{@a parent-child-animations}
### Родительско-дочерние анимации

Каждый раз, когда анимация запускается в Angular, родительская анимация всегда получает приоритет, а дочерние анимации блокируются. Чтобы запустить дочернюю анимацию, родительская анимация должна запросить каждый из элементов, содержащих дочерние анимации, а затем разрешить запуск анимации с помощью функции [ `animateChild ()` ](https://angular.io/api/animations/animateChild).

{@a disabling-an-animation-on-an-html-element}
#### Отключение анимации для элемента HTML

Специальная привязка управления анимацией называется  `@.disabled`  можно поместить в элемент HTML, чтобы отключить анимацию для этого элемента, а также для любых вложенных элементов. Когда правда, то  `@.disabled`  предотвращает рендеринг всех анимаций.

Пример кода ниже показывает, как использовать эту функцию.

<code-tabs>

<code-pane path="animations/src/app/open-close.component.4.html" header="src/app/open-close.component.html" region="toggle-animation">
</code-pane>

<code-pane path="animations/src/app/open-close.component.4.ts" header="src/app/open-close.component.ts" region="toggle-animation" language="typescript">
</code-pane>

</code-tabs>

Когда  `@.disabled`  верна,  `@childAnimation`  Триггер не срабатывает.

Когда элемент в шаблоне HTML отключил анимацию с помощью  `@.disabled`  привязка хоста, анимации отключены также на всех внутренних элементах.
Вы не можете выборочно отключить несколько анимаций на одном элементе.

Тем не менее, селективные ребенка анимации все еще может быть запущен на нетрудоспособного родителя в одном из следующих способов:

* Родительская анимация может использовать [ `query ()` ](https://angular.io/api/animations/query)функцию для сбора внутренних элементов, расположенных в недоступных областях шаблона HTML.
Эти элементы все еще могут оживлять.

* Субанимация может быть запрошена родителем, а затем анимирована  `animateChild()`.

{@a disabling-all-animations}
#### Отключение всех анимаций

Чтобы отключить все анимации для приложения Angular, поместите  `@.disabled`  привязка хоста к компоненту.

<code-example path="animations/src/app/app.component.ts" header="src/app/app.component.ts" region="toggle-app-animations" language="typescript"></code-example>

<div class="alert is-helpful">

**Примечание.** Отключение анимации для всего приложения полезно во время сквозного (E2E) тестирования.
</div>

{@a animation-callbacks}
## Анимация обратных вызовов

Анимация  `trigger()`  Функция генерирует *обратные вызовы* при запуске и завершении. В приведенном ниже примере представлен компонент, который содержит  `openClose`  триггер.

<code-example path="animations/src/app/open-close.component.ts" header="src/app/open-close.component.ts" region="events1" language="typescript"></code-example>

В шаблоне HTML событие анимации передается обратно через  `$event`, as  `@trigger.start`  и  `@trigger.done`, где  `trigger`  - это имя используемого триггера.
В этом примере триггер  `openClose`  выглядит следующим образом.

<code-example path="animations/src/app/open-close.component.3.html" header="src/app/open-close.component.html" region="callbacks">
</code-example>

Потенциальное использование для обратных вызовов анимации может заключаться в покрытии медленного вызова API, такого как поиск в базе данных.
Например, вы можете настроить **InProgress** кнопку, чтобы она имела собственную циклическую анимацию, в которой она пульсирует или выполняет какое-то другое визуальное движение, когда завершается работа системы бэкэнда.

Затем другая анимация может быть вызвана, когда текущая анимация заканчивается.
Например, кнопка идет от  `inProgress`  состояние до  `closed`  состояние, когда вызов API завершен.

Анимация может повлиять на конечного пользователя, чтобы он *воспринимал* операцию быстрее, даже если это не так.
Таким образом, простая анимация может быть экономически эффективным способом удовлетворения потребностей пользователей, вместо того, чтобы пытаться повысить скорость вызова на сервере и вынуждена компенсировать обстоятельства, не зависящие от вас, такие как ненадежное сетевое соединение.

Обратные вызовы могут служить средством отладки, например, в сочетании с  `console.warn()`  для просмотра прогресса приложения в консоли JavaScript разработчика браузера.
Следующий фрагмент кода создает вывод журнала консоли для исходного примера, кнопку с двумя состояниями:  `open`  и  `closed`.

<code-example path="animations/src/app/open-close.component.ts" header="src/app/open-close.component.ts" region="events" language="typescript"></code-example>

{@a keyframes}

{@a keyframes}
## Ключевые кадры

В предыдущем разделе представлен простой переход из двух состояний. Теперь создайте анимацию с несколькими последовательными шагами, используя *ключевые кадры*.

Angular's  `keyframe()`  Функция похожа на ключевые кадры в CSS. Ключевые кадры позволяют несколько изменений стиля в пределах одного временного сегмента.
Например, кнопка вместо затухания может менять цвет несколько раз за один 2-секундный промежуток времени.

<div class="lightbox">
  <img src="generated/images/guide/animations/keyframes-500.png" alt="keyframes">
</div>

Код для этого изменения цвета может выглядеть следующим образом.

<code-example path="animations/src/app/status-slider.component.ts" header="src/app/status-slider.component.ts" region="keyframes" language="typescript"></code-example>

{@a offset}
### Смещение

Ключевые кадры включают *смещение,* которое определяет точку в анимации, где происходит каждое изменение стиля.
Смещения - это относительные меры от нуля до единицы, обозначающие соответственно начало и конец анимации, и их следует применять к каждому шагу ключевого кадра, если он используется хотя бы один раз.

Определение смещений для ключевых кадров не является обязательным.
Если вы их опускаете, автоматически назначаются равномерно смещенные смещения.
Например, три ключевых кадра без предопределенных смещений получают смещения 0, 0,5 и 1.
Задание смещения 0,8 для среднего перехода в приведенном выше примере может выглядеть следующим образом.

<div class="lightbox">
  <img src="generated/images/guide/animations/keyframes-offset-500.png" alt="keyframes with offset">
</div>

Код с указанными смещениями будет следующим.

<code-example path="animations/src/app/status-slider.component.ts" header="src/app/status-slider.component.ts" region="keyframesWithOffsets" language="typescript">
</code-example>

Вы можете комбинировать ключевые кадры с  `duration `, ` delay ` и ` easing` пределах одной анимации.

{@a keyframes-with-a-pulsation}
### Ключевые кадры с пульсацией

Используйте ключевые кадры для создания импульсного эффекта в вашей анимации, определяя стили с определенным смещением на протяжении всей анимации.

Вот пример использования ключевых кадров для создания эффекта импульса:

* Оригинал  `open`  и  `closed`  состояния с исходными изменениями высоты, цвета и непрозрачности, возникающими в течение 1 секунды.

* Последовательность ключевых кадров, вставленная в середину, заставляет кнопку казаться нерегулярно пульсирующей в течение того же 1-секундного таймфрейма.

<div class="lightbox">
  <img src="generated/images/guide/animations/keyframes-pulsation.png" alt="keyframes with irregular pulsation">
</div>

Фрагмент кода для этой анимации может выглядеть следующим образом.

<code-example path="animations/src/app/open-close.component.1.ts" header="src/app/open-close.component.ts" region="trigger" language="typescript"></code-example>

{@a animatable-properties-and-units}
### Анимационные свойства и единицы

Поддержка анимации в Angular основана на веб-анимации, поэтому вы можете анимировать любое свойство, которое браузер считает анимируемым.
Это включает в себя позиции, размеры, преобразования, цвета, границы и многое другое. W3C поддерживает список анимируемых свойств на своей [CSS Transitions](https://www.w3.org/TR/css-transitions-1/)странице.

Для позиционных свойств с числовым значением, определяет единицу, обеспечивая значение в виде строки, в кавычках, с соответствующим суффиксом:

* 50 пикселей:  `'50px'` 
* Относительный размер шрифта:  `'3em'` 
* Процент:  `'100%'` 

Если вы не указали единицу измерения при указании размера, для параметра Angular принимается значение в пикселях по умолчанию или px.
Выражение 50 пикселей как  `50`  - это то же самое, что сказать  `'50px'`.

{@a automatic-property-calculation-with-wildcards}
### Автоматический расчет свойств с подстановочными знаками

Иногда вы не знаете значение свойства размерного стиля до времени выполнения.
Например, элементы часто имеют ширину и высоту, которые зависят от их содержимого и размера экрана.
Эти свойства часто сложно анимировать с помощью CSS.

В этих случаях вы можете использовать специальный шаблон  `*`  стоимость имущества под  `style()`, так что значение этого конкретного свойства стиля вычисляется во время выполнения, а затем подключается к анимации.

В следующем примере есть триггер с именем  `shrinkOut`, используется, когда HTML-элемент покидает страницу.
Анимация берет любую высоту, которую элемент имеет до того, как уходит, и анимирует от этой высоты до нуля.

<code-example path="animations/src/app/hero-list-auto.component.ts" header="src/app/hero-list-auto.component.ts" region="auto-calc" language="typescript"></code-example>

{@a keyframes-summary}
### Сводка ключевых кадров

 `keyframes()` Функция в Angular позволяет вам указать несколько промежуточных стилей в пределах одного перехода с необязательным смещением, чтобы определить точку в анимации, где происходит каждое изменение стиля.

{@a more-on-angular-animations}
## Подробнее об Angular анимации

Вы также можете быть заинтересованы в следующих ситуациях :

* [Введение в Angular анимацию](guide/animations)
* [Сложные анимационные последовательности](guide/complex-animation-sequences)
* [Многоразовые анимации](guide/reusable-animations)
* [Анимация перехода маршрута](guide/route-animations)
