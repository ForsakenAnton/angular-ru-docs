{@a template-type-checking}
# Проверка типа шаблона

{@a overview-of-template-type-checking}
## Обзор проверки типа шаблона

Так же, как TypeScript улавливает ошибки типа в вашем коде, Angular проверяет выражения и привязки в шаблонах вашего приложения и может сообщать о любых найденных ошибках типа.
В настоящее время в Angular есть три способа сделать это, в зависимости от значения `fullTemplateTypeCheck` и `strictTemplates` флаги в [файл конфигурации TypeScript](guide/typescript-configuration), `tsconfig.json`.

{@a basic-mode}
### Основной режим

В самом основном режиме проверки типов, с `fullTemplateTypeCheck` Флаг установлен в `false`, Angular проверяет только выражения верхнего уровня в шаблоне.

Если ты пишешь `<map [city]="user.address.city">`, в компилятор Проверяет следующее:

* `user` - это свойство класса компонента.
* `user` - это объект со свойством адреса.
* `user.address` - это объект с городской собственностью.

Компилятор не проверяет, что значение `user.address.city` городскому вводу `<map>` компонент.

Компилятор также имеет существенные ограничения в этом режиме:

* Важно отметить, что он не проверяет встроенные представления, такие как `*ngIf`, `*ngFor`, другое `<ng-template>` встроенного представления.
* Это не выясняет типы `#refs`, результаты труб, тип `$event` в привязках событий и т. д.

Во многих случаях эти вещи заканчиваются как тип `any`, что может привести к тому, что последующие части выражения останутся непроверенными.



{@a full-mode}
### Полный режим

Если `fullTemplateTypeCheck` флага установлено значение `true`, Angular более агрессивен в проверке типов в шаблонах.
В частности:

* Встроенные представления (такие как в `*ngIf` или `*ngFor`) проверены.
* Трубы имеют правильный тип возврата.
* Локальные ссылки на директивы и каналы имеют правильный тип (за исключением любых общих параметров, которые будут `any`)

Следующие все еще имеют тип `any`.

* Локальные ссылки на элементы DOM.
* `$event` объекта.
* Безопасные навигационные выражения.

{@a strict-mode}

{@a strict-mode}
### Строгий режим

Angular версия 9 поддерживает поведение `fullTemplateTypeCheck` Флаг и вводит третий «строгий режим».
Строгий режим - это расширенный набор полного режима, доступ к которому можно получить, установив `strictTemplates` на значение true. Этот флаг заменяет `fullTemplateTypeCheck` флаг.
В строгом режиме Angular версии 9 добавляет проверки, выходящие за рамки проверки типов версии 8.
Обратите внимание, что строгий режим доступен только при использовании Ivy.

В дополнение к полному поведению режима, Angular версия 9:

* Проверяет, что привязки компонентов / директив назначаются их `@Input()` s.
* Подчиняется TypeScript's `strictNullChecks` флаг проверки при подтверждении выше.
* Выводит правильный тип компонентов / директив, включая дженерики.
* Выводит типы контекста шаблона там, где они настроены (например, разрешает правильную проверку типа `NgFor`).
* Выводит правильный тип `$event` в компонентах / директивах, DOM и привязках анимационных событий.
* Выводит правильный тип локальных ссылок на элементы DOM на основе имени тега (например, типа, который `document.createElement` будет возвращаться для этого тега).


{@a checking-of-*ngfor}
## Проверка `*ngFor` 

Три режима проверки типов по-разному обрабатывают встроенные представления. Рассмотрим следующий пример.


<code-example language="ts" header="User interface">

interface User {
  name: string;
  address: {
    city: string;
    state: string;
  }
}

</code-example>


```html
  <div *ngFor="let user of users">
    <h2>{{config.title}}</h2>
    <span>City: {{user.address.city}}</span>
  </div>
```

 `<h2> ` и ` <span> ` в ` *ngFor` встроенного просмотра.
В базовом режиме Angular не проверяет ни один из них.
Однако в полном режиме Angular проверяет, что `config` и `user` существует и предполагает тип `any`.
В строгом режиме Angular знает, что `user` в `<span>` имеет тип `User`, и это `address` является объектом с `city` недвижимость типа `string`.

{@a troubleshooting-template-errors}

{@a troubleshooting-template-errors}
## Устранение ошибок шаблона

При включении нового строгого режима в версии 9 вы можете столкнуться с ошибками шаблона, которые не возникали ни в одном из предыдущих режимов.
Эти ошибки часто представляют собой подлинные несоответствия типов в шаблонах, которые не были обнаружены предыдущим инструментарием.
В этом случае в сообщении об ошибке должно быть четко указано, где в шаблоне возникает проблема.

Также могут быть ложные срабатывания, когда типизация библиотеки Angular является неполной или неправильной, или когда типизация не совсем соответствует ожиданиям, как в следующих случаях.

* Когда типография библиотеки неправильная или неполная (например, отсутствует `null | undefined` если библиотека не была написана с `strictNullChecks` в памяти).
* Когда входные типы библиотеки слишком узки, и библиотека не добавила соответствующие метаданные для Angular, чтобы понять это. Это обычно происходит с отключенными или другими общими логическими входами, используемыми в качестве атрибутов, например, `<input disabled>`.
* Когда используешь `$event.target` для событий DOM (из-за возможности всплытия событий, `$event.target` в типах DOM не имеет ожидаемого типа).

В случае ложного позитива, как это, есть несколько вариантов:

* Используйте [$ any () `функцию приведения типов](guide/template-syntax#any-type-cast-function)в определенных контекстах, чтобы отказаться от проверки типов для части выражения.
* Вы можете полностью отключить строгие проверки, установив `strictTemplates: false` в файле конфигурации TypeScript приложения, `tsconfig.json`.
* Вы можете отключить определенные операции проверки типов по отдельности, сохраняя при этом строгость в других аспектах, установив флаг _strictness_ в `false`.
* Если вы хотите использовать `strictTemplates` и `strictNullChecks` вместе, вы можете отказаться от строгой проверки нулевого типа специально для привязок ввода через `strictNullInputTypes`.

| Флаг строгости | Эффект |
| - | - |
| `strictInputTypes` | Возможность назначения выражения привязки для `@Input()` проверено. Также влияет на вывод директивных универсальных типов. |
| `strictNullInputTypes` | Будь `strictNullChecks` при проверке `@Input()` (за `strictInputTypes`). Отключение этого может быть полезно при использовании библиотеки, которая не была построена с `strictNullChecks` в виду.
| `strictAttributeTypes` | ли `@Input()` которые создаются с использованием текстовых атрибутов (например, `<mat-tab label="Step 1"> ` vs ` <mat-tab [label]="'Step 1'">`).
| `strictSafeNavigationTypes` | ли тип возвращаемых безопасных операций навигации (например, `user?.name`) будет правильно выведен в зависимости от типа `user` ). Если отключено, `user?.name` будет иметь тип `any`.
| `strictDomLocalRefTypes` | Будут ли локальные ссылки на элементы DOM иметь правильный тип. Если отключено `ref` будет типа `any` для `<input #ref>` . |
| `strictOutputEventTypes` | Будь `$event` будет иметь правильный тип для привязки событий к компоненту / директиве `@Output()` или для анимационных событий. Если отключено, это будет `any`.
| `strictDomEventTypes` | Будь `$event` будет иметь правильный тип для привязки событий к событиям DOM. Если отключено, это будет `any`.
| `strictContextGenerics` | ли будут выведены параметры типа общих компонентов (включая любые общие границы). Если отключено, любые параметры типа будут `any`.
| `strictLiteralTypes` | ли у литералов объекта и массива, объявленных в шаблоне, свой тип. Если отключено, тип таких литералов будет `any`.


Если у вас все еще есть проблемы после устранения неполадок с этими флагами, вы можете вернуться в полный режим, отключив `strictTemplates`.

Если это не сработает, последний вариант - полностью отключить полный режим с помощью `fullTemplateTypeCheck: false`, поскольку мы приложили особые усилия для обеспечения обратной совместимости Angular версии 9 в этом случае.

Ошибка проверки типа, которую нельзя устранить ни одним из рекомендуемых методов, может быть результатом ошибки в самой проверке типа шаблона.
Если вы получаете ошибки, требующие возврата к основному режиму, это, вероятно, будет такой ошибкой.
Если это произойдет, пожалуйста [подайте проблему](https://github.com/angular/angular/issues)чтобы команда смогла решить ее.

{@a inputs-and-type-checking}
## Входы и проверка типов

В Angular версии 9 средство проверки типа шаблона проверяет, совместим ли тип выражения привязки с типом соответствующего ввода директивы.
В качестве примера рассмотрим следующий компонент:

```typescript
export interface User {
  name: string;
}

@Component({
  selector: 'user-detail',
  template: '{{ user.name }}',
})
export class UserDetailComponent {
  @Input() user: User;
}
```

 `AppComponent` шаблон использует этот компонент следующим образом :

```ts
@Component({
  selector: 'my-app',
  template: '<user-detail [user]="selectedUser" />',
})
export class AppComponent {
  selectedUser: User | null = null;
}
```

Здесь, во время проверки типа шаблона для `AppComponent`, `[user]="selectedUser"` привязка соответствует `UserDetailComponent.user` вход.
Поэтому Angular присваивает `selectedUser` свойство для `UserDetailComponent.user`, который может привести к ошибке, если их типы несовместимы.
TypeScript проверяет присвоение в соответствии с его системой типов, подчиняясь таким флагам, как `strictNullChecks` как они настроены в приложении.


{@a strict-null-checks}
### Строгие нулевые проверки

Когда вы включаете `strictTemplates` и флаг TypeScript `strictNullChecks`, ошибки проверки типов могут возникать в определенных ситуациях, которых трудно избежать. Например:

  * Обнуляемое значение, которое связано с директивой из библиотеки, которая не имела `strictNullChecks` включены.

  Для библиотеки, скомпилированной без `strictNullChecks`, его файлы объявлений не будут указывать, может ли поле быть `null` или нет.
  Для ситуаций, когда библиотека обрабатывает `null` правильно, это проблематично, так как компилятор проверит обнуляемое значение по файлам объявлений, которые пропускают `null` тип
  Таким образом, компилятор выдает ошибку проверки типа, потому что он придерживается `strictNullChecks`.

  * С использованием `async` канал с наблюдаемой, который вы знаете, будет излучать синхронно.

 `async` настоящее время канал предполагает, что Observable, на который он подписывается, может быть асинхронным, что означает, что, возможно, еще нет доступных значений.
  В этом случае, он все еще должен что-то вернуть - что `null`.
  Другими словами, тип возвращаемого значения `async` труба включает `null`, что может привести к ошибкам в ситуациях, когда, как известно, Observable синхронно генерирует ненулевое значение.

Есть два возможных обходные пути к вышеперечисленным вопросам:

  1. В шаблон включите оператор ненулевого утверждения `!` в конце обнуляемого выражения, такого как `<user-detail [user]="user!" />`,

  В этом примере компилятор игнорирует несовместимости типов в обнуляемости, как и в коде TypeScript.
  В случае с `async` канал, обратите внимание, что выражение должно быть заключено в скобки, как в `<user-detail [user]="(user$ | async)!" />`,

  1. Полностью отключите строгие проверки нуля в шаблонах Angular.

  когда `strictTemplates` включены, все еще возможно отключить некоторые аспекты проверки типов.
  Настройка опции `strictNullInputTypes` to `false` отключает строгие проверки NULL в шаблонах Angular.
  Этот флаг применяется для всех компонентов, которые являются частью приложения.

{@a advice-for-library-authors}
### Советы авторам библиотеки

Как автор библиотеки, вы можете предпринять несколько мер, чтобы обеспечить оптимальную работу для ваших пользователей.
Во-первых, позволяя `strictNullChecks` и в том числе `null` в типе входных данных, в зависимости от ситуации, сообщает вашим потребителям, могут ли они предоставить значение, допускающее значение NULL, или нет.
Кроме того, можно предоставить подсказки типов, относящиеся к средству проверки типа шаблона, см. [Приведение входного установщика](guide/template-typecheck#input-setter-coercion)Раздел данного руководства.


{@a input-setter-coercion}

{@a input-setter-coercion}
## Приведение входного установщика

Иногда это желательно для `@Input()` директивы или компонента, чтобы изменить привязанное к нему значение, обычно используя входную пару getter / setter.
В качестве примера, рассмотрим этот пользовательский компонент кнопки:

Рассмотрим следующую директиву:

```typescript
@Component({
  selector: 'submit-button',
  template: `
    <div class="wrapper">
      <button [disabled]="disabled">Submit</button>'
    </div>
  `,
})
class SubmitButton {
  private _disabled: boolean;

  get disabled(): boolean {
    return this._disabled;
  }

  set disabled(value: boolean) {
    this._disabled = value;
  }
}
```

Здесь `disabled` ввод компонента передается на `<button>` в шаблоне. Все это работает как положено, пока `boolean` значение привязано к входу. Но, предположим, что потребитель использует этот вход в шаблоне в качестве атрибута:

```html
<submit-button disabled></submit-button>
```

Это имеет тот же эффект, как и переплет:

```html
<submit-button [disabled]="''"></submit-button>
```

Во время выполнения вход будет установлен в пустую строку, которая не является `boolean` значение. Angular библиотеки компонентов, которые имеют дело с этой проблемой часто «принуждать» значения в правильный тип в инкубаторе:

```typescript
set disabled(value: boolean) {
  this._disabled = (value === '') || value;
}
```

Было бы идеально изменить тип `value` здесь, от `boolean` для `boolean|''`, чтобы соответствовать набору значений, которые фактически принимаются установщиком.
TypeScript требует, чтобы и метод получения, и метод установки имели одинаковый тип, поэтому, если метод получения должен вернуть `boolean` то сеттер застрял с более узким типом.

Если у потребителя включена строжайшая проверка типов в Angular для шаблонов, это создает проблему: пустая строка `''` на самом деле не присваивается `disabled` поле, которое создаст ошибку типа при использовании формы атрибута.

В качестве обходного пути для этой проблемы Angular поддерживает проверку более широкого, более разрешающего типа для `@Input()` чем объявлено для самого поля ввода. Включите это, добавив статическое свойство с `ngAcceptInputType_` префикс класса компонента:

```typescript
class SubmitButton {
  private _disabled: boolean;

  get disabled(): boolean {
    return this._disabled;
  }

  set disabled(value: boolean) {
    this._disabled = (value === '') || value;
  }

  static ngAcceptInputType_disabled: boolean|'';
}
```

Это поле не должно иметь значение. Его существование сообщает контролеру типа Angular, что `disabled` ввод должен рассматриваться как принимающий привязки, соответствующие типу `boolean|''`, Суффикс должен быть `@Input` _field_ name.

Следует проявлять осторожность, если `ngAcceptInputType_` данного входа присутствует переопределение, тогда установщик должен иметь возможность обрабатывать любые значения переопределенного типа.

{@a disabling-type-checking-using-$any}
## Отключение проверки типа с помощью `$any()` 

Отключите проверку выражения привязки, окружив выражение в вызове [ `$ any ()` приведение псевдофункции](guide/template-syntax).
Компилятор рассматривает это как приведение к `any` тип, как в TypeScript, когда `<any>` или `as any` актерский состав используется.

В следующем примере приведение `person` к `any` тип подавляет ошибку `Property address does not exist`.

```typescript
  @Component({
    selector: 'my-component',
    template: '{{$any(person).addresss.street}}'
  })
  class MyComponent {
    person?: Person;
  }
```
