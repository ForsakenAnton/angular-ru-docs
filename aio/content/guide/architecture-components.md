{@a introduction-to-components}
# Введение в компоненты

А *компонент* управления патч экрана называется *вид*.
Например, отдельные компоненты определяют и контролируют каждый из следующих представлений из [Учебное пособие](tutorial):

* Корень приложения с навигационными ссылками.
* Список героев.
* Редактор героев.

Вы определяете логику приложения компонента - что он делает для поддержки представления - внутри класса.
Класс взаимодействует с представлением через API свойств и методов.

Например,  `HeroListComponent`  имеет  `heroes`  свойство которое содержит множество героев.
это  `selectHero()`  устанавливает  `selectedHero`  свойство когда пользователь щелкает, чтобы выбрать героя из этого списка.
Компонент получает героев из службы, которая является TypeScript [свойство параметра](http://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties)в конструкторе.
Услуга предоставляется компоненту через систему внедрения зависимостей.

<code-example path="architecture/src/app/hero-list.component.ts" header="src/app/hero-list.component.ts (class)" region="class"></code-example>

Angular создает, обновляет и уничтожает компоненты при перемещении пользователя по приложению. Ваше приложение может действовать в каждый момент этого жизненного цикла с помощью дополнительных [хуков жизненного цикла](guide/lifecycle-hooks), таких как  `ngOnInit()`.

{@a component-metadata}
## Компоненты метаданных

<img src="generated/images/guide/architecture/metadata.png" alt="Metadata" class="left">

 `@Component` Декоратор идентифицирует класс, находящийся непосредственно под ним, как класс компонента, и определяет его метаданные. В приведенном ниже примере кода вы можете видеть, что  `HeroListComponent`  - это просто класс без каких-либо специальных Angular обозначений или синтаксиса. Это не компонент, пока вы не отметите его как один с  `@Component`  декоратор.

Метаданные для компонента сообщают Angular, где взять основные строительные блоки, необходимые для создания и представления компонента и его представления. В частности, он связывает *шаблон* с компонентом, либо непосредственно со встроенным кодом, либо по ссылке. Вместе компонент и его шаблон описывают *представление*.

В дополнение к содержанию или указанию на шаблон,  `@Component`  Метаданные настраивают, например, как можно ссылаться на компонент в HTML и какие сервисы ему требуются.

Вот пример основных метаданных для  `HeroListComponent`.

<code-example path="architecture/src/app/hero-list.component.ts" header="src/app/hero-list.component.ts (metadata)" region="metadata"></code-example>

Этот пример показывает некоторые из самых полезных  `@Component`  параметры конфигурации:

*  `selector` : CSS, который указывает Angular создавать и вставлять экземпляр этого компонента, где бы он ни находил соответствующий тег в шаблоне HTML. Например, если HTML-код приложения содержит  `<app-hero-list></app-hero-list>`, тогда
Angular вставки экземпляра  `HeroListComponent`  вид между этими тегами.

*  `templateUrl` : относительный к модулю адрес HTML-шаблона этого компонента. Кроме того, вы можете предоставить встроенный шаблон HTML в качестве значения  `template`  свойство. Этот шаблон определяет представление компонента*узла *.

*  `providers` : массив [провайдеров](guide/glossary#provider)для услуг, которые требуются компоненту. В примере это говорит Angular, как обеспечить  `HeroService`  который конструктор компонента использует для отображения списка героев.


{@a templates-and-views}
## Шаблоны и просмотры

<img src="generated/images/guide/architecture/template.png" alt="Template" class="left">

Вы определяете вид компонента с его сопутствующим шаблоном. Шаблон - это форма HTML, которая сообщает Angular, как визуализировать компонент.

Представления обычно располагаются иерархически, что позволяет вам изменять или показывать и скрывать целые разделы или страницы пользовательского интерфейса как единое целое. Шаблон, непосредственно связанный с компонентом, определяет представление этого компонента *узла*. Компонент также может определять *иерархию представлений*, которая содержит *встроенные представления*, размещенные другими компонентами.

<div class="lightbox">
  <img src="generated/images/guide/architecture/component-tree.png" alt="Component tree" class="left">
</div>

Иерархия представлений может включать представления от компонентов в одном и том же модуле NgModule, но она также может (и часто включает) представления от компонентов, определенных в разных модулях NgModule.

{@a template-syntax}
## Синтаксис шаблона

Шаблон выглядит как обычный HTML, за исключением того, что он также содержит Angular [синтаксис шаблона](guide/template-syntax), который изменяет HTML на основе логики вашего приложения и состояния приложения и данных DOM. Ваш шаблон может использовать *привязку данных* для координации данных приложения и DOM, *каналы* для преобразования данных перед их отображением и *директивы* применять логику приложения к тому, что отображается.

Например, вот шаблон для учебника  `HeroListComponent`.

<code-example path="architecture/src/app/hero-list.component.html" header="src/app/hero-list.component.html"></code-example>

Этот шаблон использует типичные элементы HTML, такие как  `<h2>`  и   `<p>`, а также включает в себя Angular шаблон-синтаксические элементы,   `*ngFor `, ` {{hero.name}} `, ` (click) `, ` [hero] ` и ` <app-hero-detail>` . Элементы шаблона-синтаксиса сообщают Angular, как визуализировать HTML-код на экране, используя логику программы и данные.

*  `*ngFor` Директива указывает Angular перебирать список.
*  `{{hero.name}} `, ` (click) ` и ` [hero]` связывает данные программы с DOM и обратно, реагируя на ввод пользователя. Подробнее о [привязка данных](#data-binding)см. Ниже.
*  `<app-hero-detail>` Тег в этом примере представляет собой элемент, представляющий новый компонент,  `HeroDetailComponent`.
 `HeroDetailComponent` (код не показан) определяет детальное представление детали героя  `HeroListComponent`.
Обратите внимание, как такие компоненты легко сочетаются с собственным HTML в тех же макетах.

{@a data-binding}
### Привязка данных

Без каркаса вы были бы ответственны за вставку значений данных в элементы управления HTML и превращение пользовательских ответов в действия и обновления значений. Написание такой логики push и pull вручную утомительно, подвержено ошибкам и является кошмаром для чтения, что может подтвердить любой опытный программист JavaScript.

Angular поддерживает *двустороннюю привязку данных*, механизм для координации частей шаблона с частями компонента. Добавьте разметку привязки в шаблон HTML, чтобы сообщить Angular, как соединить обе стороны.

На следующем рисунке показаны четыре формы разметки привязки данных. У каждой формы есть направление: к DOM, от DOM или к обоим.

<div class="lightbox">
  <img src="generated/images/guide/architecture/databinding.png" alt="Data Binding" class="left">
</div>

Этот пример из  `HeroListComponent`  Шаблон использует три из этих форм.

<code-example path="architecture/src/app/hero-list.component.1.html" header="src/app/hero-list.component.html (binding)" region="binding"></code-example>

*  `{{hero.name}}`  [*интерполяция*](guide/displaying-data#interpolation)
отображает компонент `hero.name`  свойства пределах  `<li>`  элемент.

*  `[hero]`  [*привязка свойства*](guide/template-syntax#property-binding) передает значение
 `selectedHero` от родителя  `HeroListComponent` к свойству `hero`  вложенного компонента  `HeroDetailComponent`.

*  `(click)`  [*привязка события*](guide/user-input#binding-to-user-input-events) вызывает компонент  `selectHero`  Метод когда пользователь щелкает имя героя.

Двустороннее связывание данных (используется главным образом в [управляемых шаблонами формах](guide/forms))
объединяет привязку свойства и события в одной записи.
Вот пример из  `HeroDetailComponent`  Шаблон который использует двустороннее связывание данных с  `ngModel`  Директива.

<code-example path="architecture/src/app/hero-detail.component.html" header="src/app/hero-detail.component.html (ngModel)" region="ngModel"></code-example>

При двусторонней привязке значение свойства данных поступает в поле ввода из компонента, как и при привязке свойства.
Изменения пользователя также возвращаются к компоненту, возвращая свойству последнее значение
как с привязкой событий.

Angular обрабатывает *все* привязки данных один раз для каждого цикла событий JavaScript
из корня дерева компонентов приложения через все дочерние компоненты.

<div class="lightbox">
  <img src="generated/images/guide/architecture/component-databinding.png" alt="Data Binding" class="left">
</div>

Связывание данных играет важную роль в коммуникации между шаблоном и его компонентом, а также важно для связи между родительским и дочерним компонентами.

<div class="lightbox">
  <img src="generated/images/guide/architecture/parent-child-binding.png" alt="Parent/Child binding" class="left">
</div>

{@a pipes}
### Пайпы

Angular пайпы позволяют объявлять преобразования отображаемого значения в шаблоне HTML. Класс с  `@Pipe`  Декоратор определяет функцию, которая преобразует входные значения в выходные значения для отображения в виде.

Angular определяет различные трубы, такие как [дата](https://angular.io/api/common/DatePipe)труба и [валюта](https://angular.io/api/common/CurrencyPipe)труба; полный список см. в разделе [Pipes API list](https://angular.io/api?type=pipe). Вы также можете определить новые трубы.

Чтобы указать преобразование значения в шаблоне HTML, используйте [оператор канала (|)](https://angular.io/guide/template-syntax#pipe).

 `{{interpolated_value | pipe_name}}` 

Вы можете связать конвейеры, отправив выходные данные одной функции конвейера для преобразования другой функцией конвейера. Канал также может принимать аргументы, управляющие тем, как он выполняет свое преобразование. Например, вы можете передать желаемый формат  `date`  трубы.

```
  <!-- Default format: output 'Jun 15, 2015'-->
  <p>Today is {{today | date}}</p>

 <!-- fullDate format: output 'Monday, June 15, 2015'-->
 <p>The date is {{today | date:'fullDate'}}</p>

  <!-- shortTime format: output '9:43 AM'-->
  <p>The time is {{today | date:'shortTime'}}</p>
```

{@a directives}
### Директивы

<img src="generated/images/guide/architecture/directive.png" alt="Directives" class="left">

Angular шаблоны являются *динамическими*. Когда Angular отображает их, он преобразует DOM в соответствии с инструкциями, данными *директивами*. Директива - это класс с  `@Directive()`  декоратор.

Технически компонент является директивой.
Тем не менее, компоненты настолько характерны и имеют ключевое значение для приложений Angular, что Angular
определяет  `@Component()`  декоратор, который расширяет  `@Directive()`  оформитель с
шаблонно-ориентированные функции.

В дополнение к компонентам, есть два других вида директив:   *структурные* и *атрибутные*.
Angular определяет несколько директив обоих типов, и вы можете определить свои собственные, используя   `@Directive()` декоратор.

Как и для компонентов, метаданные для директивы связывают декорированный класс с  `selector`  элемент, который вы используете, чтобы вставить его в HTML. В шаблонах директивы обычно отображаются в теге элемента в виде атрибутов, либо по имени, либо в качестве цели назначения или привязки.

{@a structural-directives}
#### Структурные директивы

*Структурные директивы* изменяют макет, добавляя, удаляя и заменяя элементы в DOM.
В шаблоне примера используются две встроенные структурные директивы для добавления логики приложения в способ визуализации представления.

<code-example path="architecture/src/app/hero-list.component.1.html" header="src/app/hero-list.component.html (structural)" region="structural"></code-example>

* [ `* ngFor` ](guide/displaying-data#ngFor)является итеративным; это говорит Angular, чтобы искоренить один  `<li>`  за героя в  `heroes`  список.
* [ `* ngIf` ](guide/displaying-data#ngIf)является условным; это включает в себя  `HeroDetail`  Компонент только если выбранный герой существует.

{@a attribute-directives}
#### Атрибут директивы

*Директивы атрибутов* изменяют внешний вид или поведение существующего элемента.
В шаблонах они выглядят как обычные атрибуты HTML, отсюда и название.

 `ngModel` Директива, которая реализует двустороннее связывание данных, является примером директивы атрибута.  `ngModel`  изменяет поведение существующего элемента (обычно  `<input>`) путем установки его свойства отображаемого значения и реагирования на изменения событий.

<code-example path="architecture/src/app/hero-detail.component.html" header="src/app/hero-detail.component.html (ngModel)" region="ngModel"></code-example>

Angular имеет больше предопределенных директив, которые либо изменяют структуру макета
(например, [ngSwitch](guide/template-syntax#ngSwitch))
или изменить аспекты элементов и компонентов DOM
(например, [ngStyle](guide/template-syntax#ngStyle)и [ngClass](guide/template-syntax#ngClass)).

<div class="alert is-helpful">

Узнайте больше в руководствах [Директивы об атрибутах](guide/attribute-directives)и [Структурные директивы](guide/structural-directives).

</div>
