{@a route-transition-animations}
# Маршрут перехода анимации

{@a prerequisites}
#### Предпосылки

Базовое понимание следующих понятий:

* [Введение в Angular анимацию](guide/animations)
* [Переход и триггеры](guide/transition-and-triggers)
* [Многоразовые анимации](guide/reusable-animations)

<hr>

Маршрутизация позволяет пользователям перемещаться между различными маршрутами в приложении. Когда пользователь перемещается от одного маршрута к другому, Angular маршрутизатор сопоставляет путь URL-адреса с соответствующим компонентом и отображает его представление. Анимация этого перехода по маршруту может значительно улучшить взаимодействие с пользователем.

Маршрутизатор Angular поставляется с высокоуровневыми функциями анимации, которые позволяют анимировать переходы между представлениями при изменении маршрута. Чтобы создать последовательность анимации при переключении между маршрутами, необходимо определить вложенные последовательности анимации. Начните с компонента верхнего уровня, который содержит представление, и вложите дополнительные анимации в компоненты, которые содержат встроенные представления.

Чтобы включить анимацию перехода маршрутизации, выполните следующие действия

1. Импортируйте модуль маршрутизации в приложение и создайте конфигурацию маршрутизации, которая определяет возможные маршруты.
2. Добавьте выход маршрутизатора, чтобы сообщить Angular router, где разместить активированные компоненты в DOM.
3. Определите анимацию.


Давайте проиллюстрируем анимацию перехода маршрутизатора, перемещаясь между двумя маршрутами, *Home* и *About,* связанными с  `HomeComponent`  и  `AboutComponent`  просмотров соответственно. Оба этих представления компонентов являются дочерними для самого верхнего представления, размещенного  `AppComponent`  . Мы реализуем анимацию перехода маршрутизатора, которая перемещается в новом представлении вправо и выдвигает старое представление, когда пользователь перемещается между двумя маршрутами.



<div class="lightbox">
  <img src="generated/images/guide/animations/route-animation.gif" alt="Animations in action" width="440">
</div>

{@a route-configuration}
## Конфигурация маршрута

Для начала настройте набор маршрутов, используя методы, доступные в  `RouterModule`  Класс . Эта конфигурация маршрута говорит маршрутизатору, как осуществлять навигацию.

Использовать  `RouterModule.forRoot`  метод для определения набора маршрутов. Кроме того, импортировать это  `RouterModule`  для  `imports`  массив основного модуля,  `AppModule`.

<div class="alert is-helpful">

**Примечание:** используйте  `RouterModule.forRoot`  Метод в корневом модуле,  `AppModule`, для регистрации маршрутов приложений верхнего уровня и провайдеров. Для функциональных модулей, позвоните  `RouterModule.forChild`  метод для регистрации дополнительных маршрутов.

</div>

Следующая конфигурация определяет возможные маршруты для приложения.

<code-example path="animations/src/app/app.module.ts" header="src/app/app.module.ts" region="route-animation-data" language="typescript"></code-example>

 `home ` и ` about` путях, связанных с  `HomeComponent`  и  `AboutComponent`  просмотров. Конфигурация маршрута указывает Angular-маршрутизатору на создание  `HomeComponent`  и  `AboutComponent`  просматривает, когда навигация соответствует соответствующему пути.

В дополнение к  `path`  и  `component`, `data`  Свойство каждого маршрута определяет специфическую для анимации конфигурацию, связанную с маршрутом.  `data` Значение свойства передается в  `AppComponent`  при изменении маршрута. Вы также можете передать дополнительные данные в конфигурации маршрута, которые используются в анимации. Значение свойства данных должно соответствовать переходам, определенным в  `routeAnimation`  Триггер, который мы определим позже.

<div class="alert is-helpful">

**Примечание:**  `data` Имена свойств которые вы используете, могут быть произвольными. Например, имени,*анимация * использованная в примере выше, является произвольным выбором.

</div>

{@a router-outlet}
## Маршрутизатор на выходе

После настройки маршрутов скажите маршрутизатору Angular, где следует отображать представления при сопоставлении с маршрутом. Вы можете установить выход маршрутизатора, вставив  `<router-outlet>`  внутри контейнера  `AppComponent`  Шаблон.

 `<router-outlet>` контейнере есть директива атрибута, которая содержит данные об активных маршрутах и ​​их состояниях на основе  `data`  свойство которое мы устанавливаем в конфигурации маршрута.

<code-example path="animations/src/app/app.component.html" header="src/app/app.component.html" region="route-animations-outlet"></code-example>

 `AppComponent` определяет метод, который может определять, когда изменяется представление. Метод назначает значение состояния анимации триггеру анимации (`@routeAnimation`) на основе конфигурации маршрута  `data`  значение свойства . Вот пример  `AppComponent`  Метод который определяет, когда происходит изменение маршрута.

<code-example path="animations/src/app/app.component.ts" header="src/app/app.component.ts" region="prepare-router-outlet" language="typescript"></code-example>

Здесь  `prepareRoute()`  принимает значение директивы outlet (устанавливается через  `#outlet="outlet"`) и возвращает строковое значение, представляющее состояние анимации на основе пользовательских данных текущего активного маршрута. Вы можете использовать эти данные для управления тем, какой переход выполнить для каждого маршрута.

{@a animation-definition}
## Определение анимации

Анимации могут быть определены непосредственно внутри ваших компонентов. Для этого примера мы определяем анимации в отдельном файле, что позволяет нам повторно использовать анимации.

Следующий фрагмент кода определяет повторно используемую анимацию с именем  `slideInAnimation`.


<code-example path="animations/src/app/animations.ts" header="src/app/animations.ts" region="route-animations" language="typescript"></code-example>

Определение анимации делает несколько вещей:

* Определяет два перехода. Один триггер может определять несколько состояний и переходов.
* Настраивает стили хоста и дочерних представлений для управления их взаимным расположением во время перехода.
* Пользы  `query()`  чтобы определить, какое дочернее представление входит, а какое покидает главное представление.

Изменение маршрута активирует триггер анимации, и применяется переход, соответствующий изменению состояния.

<div class="alert is-helpful">

**Примечание:** переходные состояния должны соответствовать  `data`  Значение свойства определено в конфигурации маршрута.
</div>

Сделайте определение анимации доступным в вашем приложении, добавив повторно используемую анимацию (`slideInAnimation`) в  `animations`  метаданные  `AppComponent`.

<code-example path="animations/src/app/app.component.ts" header="src/app/app.component.ts" region="define" language="typescript"></code-example>

{@a styling-the-host-and-child-components}
### Стилизация хоста и дочерних компонентов

Во время перехода новый вид вставляется сразу после старого, и оба элемента появляются на экране одновременно. Чтобы предотвратить это, примените дополнительные стили к представлению хоста и к удаленным и вставленным дочерним представлениям. Хост-представление должно использовать относительное позиционирование, а дочерние представления должны использовать абсолютное позиционирование. Добавление стилей к представлениям оживляет контейнеры на месте, без DOM, перемещающего вещи.

<code-example path="animations/src/app/animations.ts" header="src/app/animations.ts" region="style-view" language="typescript"></code-example>

{@a querying-the-view-containers}
### Запрашивание просмотра контейнеров

Использовать  `query()`  Метод для поиска и анимации элементов в текущем компоненте хоста.  `query(":enter") ` оператор возвращает вставляемое представление и `query(":leave") ` возвращает представление, которое удаляется.

Давайте предположим, что мы маршрутизация от *дома => О*.

<code-example path="animations/src/app/animations.ts" header="src/app/animations.ts (Continuation from above)" region="query" language="typescript"></code-example>

Код анимации делает следующее после укладки взглядов:

*  `query(':enter style({ left: '-100%'})` . соответствует вид, который добавляется и кожевенное недавно добавленный, установив его в крайнее левое положение
* Calls  `animateChild()`  в уходящем представлении для запуска его дочерних анимаций.
* Пользы  `group()`  Функция для параллельного запуска внутренней анимации.
* В пределах  `group()`  функции:
    * Запрашивает удаленное представление и анимирует его для скольжения вправо.
    * Слайды в новом виде, анимируя вид с помощью функции замедления и продолжительности.
    Эта анимация приводит к  `about`  скольжении вида слева направо.
* Вызывает  `animateChild()`  в новом представлении для запуска дочерних анимаций после завершения основной анимации.

Теперь у вас есть базовая маршрутизируемая анимация, которая анимирует маршрутизацию от одного представления к другому.

{@a more-on-angular-animations}
## Подробнее об Angular анимации

Вы также можете быть заинтересованы в следующих ситуациях :

* [Введение в Angular анимацию](guide/animations)
* [Переход и триггеры](guide/transition-and-triggers)
* [Сложные анимационные последовательности](guide/complex-animation-sequences)
* [Многоразовые анимации](guide/reusable-animations)
