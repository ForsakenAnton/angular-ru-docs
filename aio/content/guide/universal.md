{@a server-side-rendering-ssr-with-angular-universal}
# Рендеринг на стороне сервера (SSR) с Angular Universal

В этом руководстве описывается **Angular Universal**, технология, которая отображает Angular-приложения на сервере.

Обычное приложение Angular выполняется в _browser_, отображая страницы в DOM в ответ на действия пользователя.
Angular Universal выполняется на сервере _server_, генерируя страницы приложения _static_, которые впоследствии загружаются
клиент. Это означает, что приложение обычно рендерится быстрее, что дает пользователям возможность просматривать приложение
макет, прежде чем он станет полностью интерактивным.

Для более подробного ознакомления с различными методами и концепциями, связанными с SSR, пожалуйста, проверьте это
[статья](https://developers.google.com/web/updates/2019/02/rendering-on-the-web).

Вы можете легко подготовить приложение для рендеринга на стороне сервера, используя [Angular CLI](guide/glossary#cli).
Схема CLI `@nguniversal/express-engine` выполняет необходимые шаги, как описано ниже.

<div class="alert is-helpful">

  **Примечание:** [Скачать готовый образец кода](generated/zips/universal/universal.zip),
  который работает на [Node.js® Express](https://expressjs.com/)сервере.

</div>

{@a the-example}
{@a universal-tutorial}
## Универсальный учебник

[Тур Герои учебника](tutorial)является основой для этого руководства.

В этом примере Angular CLI компилирует и связывает универсальную версию приложения с
[Опережающий (AOT) компилятор](guide/aot-compiler).
Веб-сервер Node Express компилирует HTML-страницы с Universal на основе клиентских запросов.

Чтобы создать модуль приложения на стороне сервера, `app.server.module.ts`, выполните следующую команду CLI.

<code-example language="bash">

ng add @nguniversal/express-engine

</code-example>

Команда создает следующую структуру папок.

<code-example language="none">
src/
  index.html <i>app web page</i>
  main.ts <i>bootstrapper for client app</i>
  main.server.ts <i>* bootstrapper for server app</i>
  style.css <i>styles for the app</i>
  app/ ... <i>application code</i>
    app.server.module.ts <i>* server-side application module</i>
server.ts <i>* express web server</i>
tsconfig.json <i>TypeScript client configuration</i>
tsconfig.app.json <i>TypeScript client configuration</i>
tsconfig.server.json <i>* TypeScript server configuration</i>
tsconfig.spec.json <i>TypeScript spec configuration</i>
package.json <i>npm configuration</i>
</code-example>

Файлы, отмеченные `*` являются новыми и не в оригинальном учебном образце.

{@a universal-in-action}
### Универсальный в действии

Чтобы начать рендеринг приложения с помощью Universal в локальной системе, используйте следующую команду.

<code-example language="bash">
npm run build:ssr && npm run serve:ssr
</code-example>

Откройте браузер и перейдите по адресу http: // localhost: 4000 /.
Вы должны увидеть знакомую страницу панели «Тур героев».

Навигация через `routerLinks` работает правильно, потому что они используют собственный якорь (`<a>`) теги.
Вы можете перейти с панели инструментов на страницу героев и обратно.
Вы можете щелкнуть героя на странице панели инструментов, чтобы отобразить его страницу сведений.

Если вы снизили скорость своей сети, чтобы клиентские сценарии загружались дольше (инструкции ниже)
Вы заметите:
* Нажатие героя на странице героев ничего не делает.
* Вы не можете добавить или удалить героя.
* Поле поиска на странице панели мониторинга игнорируется.
* На*Назад * и*Сохранить * кнопки на странице Детали не работают.

Пользовательские события, кроме `routerLink` щелчки не поддерживаются.
Вы должны подождать, пока полное клиентское приложение загрузится и запустится, или буферизировать события, используя библиотеки вроде
[предварительная загрузка](https://github.com/angular/preboot), которая позволяет вам воспроизводить эти события после загрузки клиентских сценариев.

Переход от серверного приложения к клиентскому приложению происходит быстро на компьютере разработчика, но вы должны это сделать
всегда тестируйте свои приложения в реальных сценариях.

Вы можете моделировать более медленную сеть, чтобы увидеть переход более ясно следующим образом :

1. Откройте Chrome Dev Tools и перейдите на вкладку Сеть.
1. Найти [Сетевое регулирование](https://developers.google.com/web/tools/chrome-devtools/network-performance/reference#throttling)
выпадающий в правом нижнем углу строки меню.
1. Попробуйте одну из скоростей "3G".

Серверное приложение по-прежнему запускается быстро, но загрузка полного клиентского приложения может занять несколько секунд.

{@a why-do-it}
{@a why-use-server-side-rendering}
## Зачем использовать серверный рендеринг?

Существует три основных причины для создания универсальной версии вашего приложения.

1. Содействие веб-сканерам через [поисковая оптимизация (SEO)](https://static.googleusercontent.com/media/www.google.com/en//webmasters/docs/search-engine-optimization-starter-guide.pdf)
1. Улучшите производительность на мобильных и маломощных устройствах
1. Быстро показать первую страницу с помощью с [краска первым содержанием)](https://developers.google.com/web/tools/lighthouse/audits/first-contentful-paint)

{@a seo}
{@a web-crawlers}
{@a facilitate-web-crawlers-seo}
### Облегчить веб-сканеры (SEO)

Google, Bing, Facebook, Twitter и другие сайты социальных сетей используют веб-сканеры для индексации содержимого вашего приложения и
сделать этот контент для поиска в Интернете.
Эти веб-сканеры могут быть не в состоянии перемещаться и индексировать ваше высокоинтерактивное приложение Angular, как это может сделать пользователь.

Angular Universal может сгенерировать статическую версию вашего приложения, в которой легко искать, ссылаться и перемещаться без JavaScript.
Universal также делает предварительный просмотр сайта доступным, поскольку каждый URL возвращает полностью отображаемую страницу.

{@a no-javascript}
{@a improve-performance-on-mobile-and-low-powered-devices}
### Улучшите производительность на мобильных и маломощных устройствах

Некоторые устройства не поддерживают JavaScript или выполняют его так плохо, что пользовательский интерфейс неприемлем.
В этих случаях вам может потребоваться версия приложения без поддержки JavaScript на сервере.
Эта версия, однако ограниченная, может быть единственной практической альтернативой для
люди, которые иначе не могли бы использовать приложение вообще.

{@a startup-performance}
{@a show-the-first-page-quickly}
### Показать первую страницу быстро

Быстрое отображение первой страницы может иметь решающее значение для привлечения пользователей.
Страницы, которые загружаются быстрее, работают лучше [даже с изменениями всего в 100 мс](https://web.dev/shopping-for-speed-on-ebay/),
Ваше приложение может запускаться быстрее, чтобы привлечь этих пользователей, прежде чем они решат заняться чем-то другим.

С Angular Universal вы можете создавать целевые страницы для приложения, которые выглядят как законченное приложение.
Страницы являются чистым HTML и могут отображаться, даже если JavaScript отключен.
Страницы не обрабатывают события браузера, но они _до_ поддерживают навигацию по сайту с помощью [ `routerLink` ](guide/router#router-link).

На практике вы будете использовать статическую версию целевой страницы, чтобы удерживать внимание пользователя.
В то же время вы загрузите полное приложение Angular за ним.
Пользователь воспринимает практически мгновенную производительность с целевой страницы
и получает полный интерактивный опыт после полной загрузки приложения.

{@a how-does-it-work}
{@a universal-web-servers}
## Универсальные веб-серверы

Универсальный веб-сервер отвечает на запросы страниц приложения с помощью статического HTML, представленного [универсальный механизм шаблонов](#universal-engine).
Сервер получает и отвечает на запросы HTTP от клиентов (обычно браузеров) и обслуживает статические ресурсы, такие как сценарии, CSS и изображения.
Он может отвечать на запросы данных либо напрямую, либо в качестве прокси для отдельного сервера данных.

Пример веб-сервера для этого руководства основан на популярной [Express](https://expressjs.com/)инфраструктуре.

<div class="alert is-helpful">

  **Примечание:** _Any_ технология веб-сервера может обслуживать приложение Universal, если оно может вызывать Universal `renderModule()`.
  Обсуждаемые здесь принципы и моменты принятия решения применимы к любой технологии веб-сервера.

</div>

Универсальные приложения используют Angular `platform-server` пакет (в отличие от `platform-browser`), которая обеспечивает
серверные реализации DOM, `XMLHttpRequest` и другие низкоуровневые функции, которые не зависят от браузера.

Сервер ( [Node Express](https://expressjs.com/)в примере этого руководства)
передает запросы клиентов на страницы приложения в NgUniversal `ngExpressEngine` . Под капотом это
называет универсал `renderModule()`, предоставляя кеширование и другие полезные утилиты.

 `renderModule()` принимает в качестве входных данных *шаблон* HTML-страницы (обычно `index.html`)
Angular *модуль,* содержащий компоненты
и *маршрут,* который определяет, какие компоненты отображать.
Маршрут идет от запроса клиента к серверу.

Каждый запрос приводит к соответствующему представлению для запрошенного маршрута.
 `renderModule()` визуализирует представление внутри `<app>` тег шаблона
создание готовой HTML-страницы для клиента.

Наконец, сервер возвращает визуализированную страницу клиенту.

{@a working-around-the-browser-apis}
### Работа вокруг API браузера

Поскольку универсальное приложение не выполняется в браузере, на сервере могут отсутствовать некоторые API и возможности браузера.

Например, серверные приложения не могут ссылаться на глобальные объекты только для браузера, такие как `window`, `document`, `navigator` или `location`.

Angular предоставляет некоторые инъекционные абстракции над этими объектами, такие как [ `Location` ](api/common/Location)
или [ `ДОКУМЕНТ` ](api/common/DOCUMENT); он может адекватно заменить эти API.
Если Angular этого не предоставляет, можно написать новые абстракции, которые делегируются API-интерфейсам браузера во время работы в браузере
и к альтернативной реализации, пока на сервере (он же шимминг).

Аналогично, без событий мыши или клавиатуры серверное приложение не может полагаться на пользователя, нажимающего кнопку для отображения компонента.
Приложение должно определить, что отображать, основываясь только на входящем клиентском запросе.
Это хороший аргумент для создания приложения [маршрутизируемого](guide/router).

{@a http-urls}
{@a using-absolute-urls-for-server-requests}
### Использование абсолютных URL-адресов для запросов к серверу

Учебник `HeroService` и `HeroSearchService` делегат в Angular `HttpClient` Модуль для получения данных приложения.
Эти сервисы отправляют запросы на _relative_ URL-адреса, такие как `api/heroes`.
В универсальном приложении URL-адреса HTTP должны быть _absolute_ (например, `https://my-server.com/api/heroes`).
Это означает, что вам нужно изменить свои сервисы, чтобы они выполняли запросы с абсолютными URL при работе на сервере и с относительными
URL при запуске в браузере.

Одним из решений является предоставление полного URL-адреса для вашего приложения на сервере и создание перехватчика, который может получить это
значение и добавьте его к URL запроса. Если вы используете `ngExpressEngine`, как показано в примере в этом руководстве, наполовину
работа уже сделана Предположим, что это так, но тривиально предоставить такую ​​же функциональность.

Начните с создания [HttpInterceptor](api/common/http/HttpInterceptor).

<code-example language="typescript" header="universal-interceptor.ts">

import {Injectable, Inject, Optional} from '@angular/core';
import {HttpInterceptor, HttpHandler, HttpRequest, HttpHeaders} from '@angular/common/http';
import {Request} from 'express';
import {REQUEST} from '@nguniversal/express-engine/tokens';

@Injectable()
export class UniversalInterceptor implements HttpInterceptor {

  constructor(@Optional() @Inject(REQUEST) protected request?: Request) {}

  intercept(req: HttpRequest<any>, next: HttpHandler) {
    let serverReq: HttpRequest<any> = req;
    if (this.request) {
      let newUrl = `${this.request.protocol}://${this.request.get('host')}` ;
      if (!req.url.startsWith('/')) {
        newUrl += '/';
      }
      newUrl += req.url;
      serverReq = req.clone({url: newUrl});
    }
    return next.handle(serverReq);
  }
}

</code-example>

Далее предоставляем перехватчик в провайдерах для сервера `AppModule`.

<code-example language="typescript" header="app.server.module.ts">

import {HTTP_INTERCEPTORS} from '@angular/common/http';
import {UniversalInterceptor} from './universal-interceptor';

@NgModule({
  ...
  providers: [{
    provide: HTTP_INTERCEPTORS,
    useClass: UniversalInterceptor,
    multi: true
  }],
})
export class AppServerModule {}

</code-example>

Теперь при каждом HTTP-запросе, сделанном на сервере, этот перехватчик срабатывает и заменяет URL-адрес запроса на абсолютный
URL предоставлен в Экспресс `Request` Объект.

{@a universal-engine}
{@a universal-template-engine}
### Универсальный шаблонный движок

Важный бит в `server.ts` файл является `ngExpressEngine()`.

<code-example path="universal/server.ts" header="server.ts" region="ngExpressEngine">
</code-example>

 `ngExpressEngine()` является обёрткой вокруг Universal `renderModule()` которая превращает клиента
запросы на серверные HTML-страницы.

* Первый параметр `AppServerModule`.
Это мост между универсальным рендерером на стороне сервера и приложением Angular.

* Второй параметр, `extraProviders`, не является обязательным. Это позволяет вам указать поставщиков зависимостей, которые применяются только тогда, когда
работает на этом сервере.
Вы можете сделать это, когда вашему приложению нужна информация, которая может быть определена только текущим экземпляром сервера.
Одним из примеров могут быть запущенным сервер *происхождения*, которые могут быть использованы для [вычислить абсолютный URL протокол HTTP](#http-urls)если
не используя `Request` токен, как показано выше.

 `ngExpressEngine() ` возвращает ` Promise` обратного вызова, которое разрешается к отображаемой странице.
Двигатель сам решает, что делать с этой страницей.
Этот двигатель `Promise` Обратный вызов возвращает отображаемую страницу на веб-сервер
который затем передает его клиенту в ответе HTTP.

<div class="alert is-helpful">

  **Примечание:** эти обертки помогают скрыть сложность `renderModule()` . Есть еще обертки
  для различных бэкэнд-технологий в [Универсальный репозиторий](https://github.com/angular/universal).

</div>

{@a filtering-request-urls}
### Фильтрация запросов URL

ПРИМЕЧАНИЕ. Базовое поведение, описанное ниже, обрабатывается автоматически при использовании схемы NgUniversal Express
полезно при попытке понять базовое поведение или воспроизвести его без использования схемы.

Веб-сервер должен отличать _app страницы запросов_ от других видов запросов.

Это не так просто, как перехватить запрос на корневой адрес `/`,
Браузер может запросить один из маршрутов приложения, например: `/dashboard`, `/heroes` или `/detail:12`.
На самом деле, если приложение было обработано только сервером, по ссылке _every_ приложение попадет на сервер
в качестве навигационного URL, предназначенного для маршрутизатора.

К счастью, у маршрутов приложений есть что-то общее: в их URL отсутствуют расширения файлов.
(Запросы данных также не имеют расширений, но их легко распознать, потому что они всегда начинаются с `/api` .)
Все запросы статических активов имеют расширение файла (например, `main.js` или `/node_modules/zone.js/dist/zone.js`).

Поскольку мы используем маршрутизацию, мы можем легко распознать три типа запросов и обработать их по-разному.

1. **Запрос данных**: запросить URL, который начинается `/api`.
1. **Навигация в приложении**: запросить URL без расширения файла.
1. **Статический актив**: все остальные запросы.

Сервер Node Express - это конвейер промежуточного программного обеспечения, которое фильтрует и обрабатывает запросы один за другим.
Вы настраиваете конвейер сервера Node Express с вызовами `app.get()` как этот для запросов данных.

<code-example path="universal/server.ts" header="server.ts (data URL)" region="data-request"></code-example>

<div class="alert is-helpful">

  **Примечание.** Этот пример сервера не обрабатывает запросы данных.

  Модуль учебного веб-API in-memory, инструмент для демонстрации и разработки, перехватывает все HTTP-вызовы и
  имитирует поведение удаленного сервера данных.
  На практике вы должны удалить этот модуль и зарегистрировать свое промежуточное ПО веб-API на сервере здесь.

</div>

Следующий код фильтрует URL-адреса запросов без расширений и обрабатывает их как запросы навигации.

<code-example path="universal/server.ts" header="server.ts (navigation)" region="navigation-request"></code-example>

{@a serving-static-files-safely}
### Безопасное обслуживание статических файлов

Один `app.use()` обрабатывает все остальные URL-адреса как запросы статических ресурсов
такие как JavaScript, изображения и файлы стилей.

Чтобы клиенты могли загружать только те файлы, которые им разрешено просматривать, поместите в них все файлы ресурсов, относящиеся к клиенту
 `/dist` папка и только запросы чести на файлы из `/dist` папка.

Следующий код Node Express направляет все оставшиеся запросы `/dist` и возвращает `404 - NOT FOUND` ошибка, если
файл не найден

<code-example path="universal/server.ts" header="server.ts (static files)" region="static"></code-example>
