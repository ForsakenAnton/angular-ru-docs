{@a template-driven-forms}
# Шаблонно-управляемые формы

Формы являются основой бизнес-приложений.
Вы можете использовать формы войти в систему, подать заявку на помощь, оформить заказ, забронировать билет,
запланировать встречу и выполнить множество других задач ввода данных.

При разработке формы важно создать опыт ввода данных, который руководит
пользователь эффективно и эффективно через рабочий процесс.

{@a introduction-to-template-driven-forms}
## Введение в формы на основе шаблонов

Разработка форм требует навыков проектирования (которые выходят за рамки данной страницы), а также поддержки фреймворка
*двухсторонняя привязка данных, отслеживание изменений, проверки и обработки ошибок*,
о котором вы узнаете на этой странице.

На этой странице показано, как создать простую форму с нуля. По пути вы узнаете, как:

* Создайте Angular форму с компонентом и шаблоном.
* использование `ngModel` для создания привязок двухсторонних данных для чтения и записи значений входного контроля.
* Отслеживание изменений состояния и достоверности элементов управления формы.
* Обеспечение визуальной обратной связи с использованием специальных классов CSS, которые отслеживают состояние элементов управления.
* Отображать ошибки проверки пользователям и включать / отключать элементы управления формы.
* Обмен информацией между элементами HTML с использованием переменных шаблона.

Вы можете запустить <live-example></live-example>в Stackblitz и скачать код оттуда.

{@a template-driven}

Вы можете создавать формы, написав шаблоны в Angular [синтаксис шаблона](guide/template-syntax)с помощью
специфичные для формы директивы и методы, описанные на этой странице.

<div class="alert is-helpful">

  Вы также можете использовать реактивный (или модельно-ориентированный) подход для создания форм.
  Однако эта страница посвящена шаблонно-управляемым формам.

</div>

Вы можете создать практически любую форму с помощью шаблона Angular - формы входа в систему, контактные формы и практически любую бизнес-форму.
Вы можете раскладывать управление творчески, связывать их с данными, указать правила проверки и проверки ошибки дисплея,
условно включить или отключить определенные элементы управления, вызвать встроенную визуальную обратную связь и многое другое.

Angular облегчает процесс, выполняя многие повторяющиеся, типовые задачи, которые вы выполняете
иначе борись с собой.

Вы научитесь строить на основе шаблонов формы, которая выглядит следующим образом :

<div class="lightbox">
  <img src="generated/images/guide/forms/hero-form-1.png" alt="Clean Form">
</div>

Агентство по *трудоустройству героев* использует эту форму для хранения личной информации о героях.
Каждому герою нужна работа. Миссия компании - найти правильного героя и правильный кризис.

Два из трех полей в этой форме являются обязательными. Обязательные поля имеют зеленую полосу слева, чтобы их было легко найти.

Если удалить имя героя, форма отображает ошибку проверки в качестве привлекающего внимания стиля:

<div class="lightbox">
  <img src="generated/images/guide/forms/hero-form-2.png" alt="Invalid, Name Required">
</div>

Обратите внимание, что *Отправить»* кнопка « отключена, а строка «Требуется» слева от элемента управления вводом меняется с зеленого на красный.

<div class="alert is-helpful">

  Вы можете настроить цвета и расположение «требуемой» панели с помощью стандартного CSS.

</div>

Вы построите эту форму маленьких шагов:

1. Создать `Hero` Модель класса.
1. Создайте компонент, который контролирует форму.
1. Создайте шаблон с исходным макетом формы.
1. Свяжите свойства данных с каждым элементом управления формы, используя `ngModel` синтаксис двусторонней привязки данных.
1. Добавить `name` атрибут для каждого элемента управления вводом формы.
1. Добавьте пользовательский CSS, чтобы обеспечить визуальную обратную связь.
1. Показать и скрыть сообщения об ошибках проверки.
1. Обработайте формы с помощью *отправку ngSubmit*.
1. Отключить в формах - х *Submit* кнопки, пока форма не является действительной.

{@a setup}
## Настройка

Создайте новый проект под названием <code>angular-forms</code>:

<code-example language="sh" class="code-shell">

  ng new angular-forms

</code-example>

{@a create-the-hero-model-class}
## Создайте класс модели Hero

Когда пользователи вводят данные формы, вы фиксируете их изменения и обновляете экземпляр модели.
Вы не можете выложить форму, пока не узнаете, как выглядит модель.

Модель может быть такой же простой, как «сумка свойств», которая содержит факты о важности приложения.
Это хорошо описывает `Hero` Класс с тремя обязательными полями (`id`, `name`, `power`)
и одно необязательное поле (`alterEgo`).

Используя команду Angular CLI [ `ng generate class` создайте](cli/generate), новый класс с именем `Hero` :

<code-example language="sh" class="code-shell">

  ng generate class Hero

</code-example>

С этим содержанием:

<code-example path="forms/src/app/hero.ts" header="src/app/hero.ts"></code-example>

Это анемичная модель с несколькими требованиями и без поведения. Идеально подходит для демо.

Компилятор TypeScript генерирует открытое поле для каждого `public` параметр конструктора и
автоматически назначает значение параметра этому полю при создании героев.

 `alterEgo` является обязательным, поэтому конструктор позволяет вам его опустить; обратите внимание на знак вопроса (?) в `alterEgo?`,

Вы можете создать новый герой, как это:

<code-example path="forms/src/app/hero-form/hero-form.component.ts" region="SkyDog"></code-example>

{@a create-a-form-component}
## Создайте компонент формы

Angular форма состоит из двух частей: _template_ на основе HTML и компонента _class_
обрабатывать данные и взаимодействие с пользователем программно.
Начните с класса, потому что вкратце говорится о том, что может сделать редактор героев.

Используя команду Angular CLI [ `ng generate component` ](cli/generate), создайте новый компонент с именем `HeroForm` :

<code-example language="sh" class="code-shell">

  ng generate component HeroForm

</code-example>

С этим содержанием:

<code-example path="forms/src/app/hero-form/hero-form.component.ts" header="src/app/hero-form/hero-form.component.ts (v1)" region="v1"></code-example>

В этом компоненте нет ничего особенного, ничего специфичного для формы
ничто не отличит его от любого компонента, который вы написали раньше.

Понимание этого компонента требует только Angular понятий, описанных на предыдущих страницах.

* Код импортирует базовую библиотеку Angular и `Hero` Модель вы только что создали.
* `@Component` селектора «app-hero-form» означает, что вы можете оставить эту форму в родительском
шаблон с `<app-hero-form>` тег.
* `templateUrl` Свойство указывает на отдельный файл для шаблона HTML.
* Вы определили фиктивные данные для `model` и `powers`, как и положено демке.

В дальнейшем вы можете внедрить службу данных для получения и сохранения реальных данных
или, возможно, выставить эти свойства как входы и выходы
(см. [Свойства ввода и вывода](guide/template-syntax#inputs-outputs)на
[Синтаксис шаблона](guide/template-syntax)странице ) для привязки к
родительский компонент. Это не проблема сейчас, и эти будущие изменения не повлияют на форму.

* Вы добавили `diagnostic` свойство для возврата JSON-представления модели.
Это поможет вам увидеть, что вы делаете во время разработки; Вы оставили себе записку, чтобы отменить ее позже.

{@a revise-*app.module.ts*}
## Пересмотреть *app.module.ts*

 `app.module.ts` определяет корневой модуль приложения. В нем вы определяете внешние модули, которые вы будете использовать в приложении
и объявить компоненты, которые принадлежат этому модулю, такие как `HeroFormComponent`.

Поскольку управляемые шаблоном формы находятся в своем собственном модуле, необходимо добавить `FormsModule` для массива
 `imports` для модуля приложения, прежде чем вы сможете использовать формы.

Обновление его со следующим:

<code-example path="forms/src/app/app.module.ts" header="src/app/app.module.ts"></code-example>

<div class="alert is-helpful">

  Есть два изменения:

  1. Вы импортируете `FormsModule`.

  1. Вы добавляете `FormsModule` к списку `imports` определенный в `@NgModule` decorator. Это дает заявку
  доступ ко всем функциям форм на основе шаблонов, включая `ngModel`.

</div>

<div class="alert is-important">

  Если компонент, директива или труба принадлежат модулю в `imports` массив, _не_ повторно объявить его в `declarations` массив.
  Если вы написали его и он должен принадлежать этому модулю, _do_ объявите его в `declarations` массив.

</div>

{@a revise-*app.component.html*}
## Пересмотреть *app.component.html*

 `AppComponent` является корневым компонентом приложения. Здесь пройдет новый `HeroFormComponent`.

Заменить содержимое его шаблона со следующим:

<code-example path="forms/src/app/app.component.html" header="src/app/app.component.html"></code-example>

<div class="alert is-helpful">

  Есть только два изменения.
 `template` - это просто новый тег элемента, идентифицируемый компонентом `selector` свойство.
  Это отображает форму героя, когда загружен компонент приложения.
  Не забудьте удалить `name` поле из тела класса.

</div>

{@a create-an-initial-html-form-template}
## Создайте исходный шаблон формы HTML

Обновление файла шаблона со следующим содержимым:

<code-example path="forms/src/app/hero-form/hero-form.component.html" region="start" header="src/app/hero-form/hero-form.component.html"></code-example>

Язык просто HTML5. Вы представляете два из `Hero` Поля, `name` и `alterEgo`, и
открывая их для ввода пользователем в поля ввода.

*Имя* `<input>` контроль имеет HTML5 `required` атрибут;
*Alter Ego* `<input>` контроль не потому что `alterEgo` является обязательным.

Вы добавили *Submit* кнопку внизу с несколькими классами для стилизации.

*Вы еще не используете Angular*. Там нет привязок или дополнительных директив, просто макет.

<div class="alert is-helpful">

  В шаблонно-управляемых формах, если вы импортировали `FormsModule`, вам не нужно ничего делать
  к `<form>` тег, чтобы использовать `FormsModule` . Продолжайте, чтобы увидеть, как это работает.

</div>

 `container `, ` form-group `, ` form-control ` и ` btn` классы
исходить из [Twitter Bootstrap](http://getbootstrap.com/css/). Эти занятия чисто косметические.
Bootstrap придает форме немного стиля.

<div class="callout is-important">

  <header>
    Angular формы не требуют библиотеки стилей
  </header>

  Angular не использует `container`, `form-group`, `form-control` и `btn` классы или
  стили любой внешней библиотеки. Angular приложения могут использовать любую библиотеку CSS или вообще не использовать ее.

</div>

Чтобы добавить таблицу стилей, откройте `styles.css` и добавьте следующую строку импорта в верхней части:

<code-example path="forms/src/styles.1.css" header="src/styles.css"></code-example>

{@a add-powers-with-*ngfor}
## Добавьте силы с _*ngFor_

Герой должен выбрать одну сверхдержаву из фиксированного списка утвержденных агентством полномочий.
Вы поддерживаете этот список внутренне (в `HeroFormComponent`).

Вы добавите `select` в
сформировать и связать варианты с `powers` список с использованием `ngFor`,
техника, показанная ранее на [Отображение данных](guide/displaying-data)странице.

Добавьте следующий HTML *непосредственно ниже* в *Alter Ego* группы:

<code-example path="forms/src/app/hero-form/hero-form.component.html" header="src/app/hero-form/hero-form.component.html (powers)" region="powers"></code-example>

Этот код повторяет `<option>` тег для каждой державы в списке держав.
 `pow` переменная ввода шаблона - это разная мощность в каждой итерации;
вы отображаете его имя, используя синтаксис интерполяции.

{@a ngModel}

{@a two-way-data-binding-with-ngmodel}
## Двустороннее связывание данных с _ngModel_

Запуск приложения прямо сейчас будет разочаровывающим.

<div class="lightbox">
  <img src="generated/images/guide/forms/hero-form-3.png" alt="Early form with no binding">
</div>


Вы не видите данные о героях, потому что вы не привязаны к `Hero` еще.
Вы знаете, как это сделать из предыдущих страниц.
[Отображение данных](guide/displaying-data)учит связывать свойства.
[Ввод пользователя](guide/user-input)показывает, как прослушивать события DOM с помощью
привязка события и как обновить свойство компонента с отображаемым значением.

Теперь вам нужно отобразить, прослушать и извлечь одновременно.

Вы можете использовать методы, которые вы уже знаете, но
вместо этого вы будете использовать новый `[(ngModel)]` синтаксис, который
облегчает привязку формы к модели.

Найди `<input>` метки для *имени* и обновлять его как это:

<code-example path="forms/src/app/hero-form/hero-form.component.html" header="src/app/hero-form/hero-form.component.html (excerpt)" region="ngModelName-1"></code-example>

<div class="alert is-helpful">

  Вы добавили диагностическую интерполяцию после тега ввода
  так что вы можете видеть, что вы делаете.
  Вы оставили себе записку, чтобы выбросить ее, когда закончите.

</div>

Сосредоточиться на синтаксисе связывания: `[(ngModel)]="..."`.

Вам нужно еще одно дополнение для отображения данных. Объявите
переменная шаблона для формы. Обновите `<form>` тега с
 `#heroForm="ngForm"` следующим образом :

<code-example path="forms/src/app/hero-form/hero-form.component.html" header="src/app/hero-form/hero-form.component.html (excerpt)" region="template-variable"></code-example>

Переменная `heroForm` теперь является ссылкой на `NgForm` Директива которая управляет формой в целом.

<div class="alert is-helpful">

  {@a ngForm}

  ### Директива _NgForm_

  Какие `NgForm` Директива ?
  Вы не добавили [NgForm](api/forms/NgForm)директиву.

  Angular сделал. Angular автоматически создает и присоединяет `NgForm` директива к `<form>` тег.

 `NgForm` Директива дополняет `form` элемент с дополнительными функциями.
  Он содержит элементы управления, которые вы создали для элементов с `ngModel` Директива
  и `name` атрибута и отслеживает их свойства, в том числе их действительность.
  Он также имеет свой собственный `valid` свойство, которое истинно, только *если каждый содержится
  контроль * действителен.

</div>

Если вы запустили приложение сейчас, и начали печатать в *названии* поля ввода
добавляя и удаляя символы, вы увидите, что они появляются и исчезают
из интерполированного текста.
В какой - то момент это может выглядеть следующим образом :

<div class="lightbox">
  <img src="generated/images/guide/forms/ng-model-in-action.png" alt="ngModel in action">
</div>

Диагностика является свидетельством того, что значения действительно перетекают из поля ввода в модель и
вернуться снова.

<div class="alert is-helpful">

  Это *двусторонняя привязка данных*,
  Для получения дополнительной информации см
  [Двустороннее связывание с NgModel](guide/template-syntax#ngModel)на
[Шаблон синтаксис](guide/template-syntax)страница.

</div>

Обратите внимание, что вы также добавили `name` атрибут к `<input>` тег и установите его в «имя»
что имеет смысл для имени героя. Подойдет любое уникальное значение, но полезно использовать описательное имя.
Определение `name` Атрибут является обязательным при использовании `[(ngModel)]` в сочетании с формой.

<div class="alert is-helpful">

  Внутри Angular создает `FormControl` и
  регистрирует их с `NgForm` Директива что Angular прикреплен к `<form>` тег.
  каждый `FormControl` зарегистрирован под именем, которое вы присвоили `name` атрибут.
  Подробнее читайте в предыдущем разделе [директива NgForm](guide/forms#ngForm).

</div>

Добавить похожие `[(ngModel)]` привязки и `name` атрибуты *Альтер Эго* и *Силы Героя*.
Вы отбросите сообщение о привязке поля ввода
и добавьте новую привязку (вверху) к компонентам `diagnostic` свойство.
Затем вы можете подтвердить, что двусторонняя привязка данных работает *для всей модели героя*.

После пересмотра основной формы должна выглядеть следующим образом :

<code-example path="forms/src/app/hero-form/hero-form.component.html" header="src/app/hero-form/hero-form.component.html (excerpt)" region="ngModel-2"></code-example>

<div class="alert is-helpful">

  * Каждый элемент ввода имеет `id` свойство, которое используется `label` элемент `for` атрибута
  сопоставить метку с ее входным контролем.
  * Каждый элемент ввода имеет `name` Свойство, которое требуется Angular формам для регистрации элемента управления в форме.

</div>

Если запустить приложение сейчас и изменить каждый герой свойств модели, форма может отображаться как это:

<div class="lightbox">
  <img src="generated/images/guide/forms/ng-model-in-action-2.png" alt="ngModel in action">
</div>

Диагностика в верхней части формы
подтверждает, что все ваши изменения отражены в модели.

*Удалить* `{{diagnostic}}` привязка наверху, поскольку это служило своей цели.

{@a track-control-state-and-validity-with-ngmodel}
## Отслеживание состояния и достоверности управления с _ngModel_

С помощью `ngModel` в форме дает вам больше, чем просто двустороннее связывание данных. Это также говорит
Вы, если пользователь коснулся элемента управления, если значение изменилось, или если значение стало недействительным.

*NgModel* директива не только отслеживать состояние; он обновляет элемент управления специальными классами Angular CSS, которые отражают состояние.
Вы можете использовать эти имена классов, чтобы изменить внешний вид элемента управления.

<table>

  <tr>

    <th>
      Гос
    </th>

    <th>
      Класс если правда
    </th>

    <th>
      Класс если ложь
    </th>

  </tr>

  <tr>

    <td>
      Контроль был посещен.
    </td>

    <td>
      <code>ng-touched</code>
    </td>

    <td>
      <code>ng-untouched</code>
    </td>

  </tr>

  <tr>

    <td>
      Значение элемента управления изменилось.
    </td>

    <td>
      <code>ng-dirty</code>
    </td>

    <td>
      <code>ng-pristine</code>
    </td>

  </tr>

  <tr>

    <td>
      Значение элемента управления является действительным.
    </td>

    <td>
      <code>ng-valid</code>
    </td>

    <td>
      <code>ng-invalid</code>
    </td>

  </tr>

</table>

Временно добавьте [переменную ссылки на шаблон](guide/template-syntax#ref-vars)именем `spy` 
к _Name_ `<input>` тег и используйте его для отображения CSS-классов ввода.

<code-example path="forms/src/app/hero-form/hero-form.component.html" header="src/app/hero-form/hero-form.component.html (excerpt)" region="ngModelName-2"></code-example>

Теперь запустите приложение и посмотрите на поле ввода _Name_.
Выполните следующие действия *именно*:

1. Смотри, но не трогай.
1. Нажмите внутри поля имени, затем щелкните снаружи.
1. Добавьте косую черту в конце имени.
1. Сотри имя.

Действия и эффекты заключаются в следующем:

<div class="lightbox">
  <img src="generated/images/guide/forms/control-state-transitions-anim.gif" alt="Control State Transition">
</div>

Вы должны увидеть следующие переходы и имена классов:

<div class="lightbox">
  <img src="generated/images/guide/forms/ng-control-class-changes.png" alt="Control state transitions">
</div>

 `ng-valid ` / ` ng-invalid` пара является наиболее интересной, потому что вы хотите отправить
сильный визуальный сигнал, когда значения являются недействительными. Вы также хотите отметить обязательные поля.
Чтобы создать такую ​​визуальную обратную связь, добавьте определения для `ng-*` CSS классы.

*Удалить* `#spy` шаблон ссылочной переменной и `TODO` поскольку они служили своей цели.

{@a add-custom-css-for-visual-feedback}
## Добавить пользовательский CSS для визуальной обратной связи

Вы можете пометить обязательные поля и недействительные данные одновременно цветной полосой
слева от поля ввода:

<div class="lightbox">
  <img src="generated/images/guide/forms/validity-required-indicator.png" alt="Invalid Form">
</div>

Вы достигаете этого эффекта, добавляя эти определения классов в новый `forms.css` файл
что вы добавляете в проект как брат `index.html` :

<code-example path="forms/src/assets/forms.css" header="src/assets/forms.css"></code-example>

Обновите `<head>` из `index.html` включить эту таблицу стилей:

<code-example path="forms/src/index.html" header="src/index.html (styles)" region="styles"></code-example>

{@a show-and-hide-validation-error-messages}
## Показать и скрыть сообщения об ошибках проверки

Вы можете улучшить форму. Поле ввода _Name_ является обязательным, и очистка его делает панель красной.
Это говорит о том, что что-то не так, но пользователь не знает, *что* не так и что с этим делать.
Используйте состояние элемента управления, чтобы показать полезное сообщение.

Когда пользователь удаляет имя, форма должна выглядеть следующим образом :

<div class="lightbox">
  <img src="generated/images/guide/forms/name-required-error.png" alt="Name required">
</div>

Чтобы достичь этого эффекта, продлите `<input>` тег со следующим:

* A [переменная ссылки на шаблон](guide/template-syntax#ref-vars).
* «*Требуется *» сообщение в соседнем `<div>`, который вы увидите, только если элемент управления недействителен.

Вот пример сообщения об ошибке добавляется в поле ввода _NAME_:

<code-example path="forms/src/app/hero-form/hero-form.component.html" header="src/app/hero-form/hero-form.component.html (excerpt)" region="name-with-error-msg"></code-example>

Вам нужна переменная ссылки на шаблон для доступа к элементу управления Angular поля ввода из шаблона.
Здесь вы создали переменную с именем `name` и дал ему значение "ngModel".

<div class="alert is-helpful">

  Почему "ngModel"?
  А директивы [exportAs](api/core/Directive)недвижимость
  сообщает Angular, как связать ссылочную переменную с директивой.
  Ты устанавливаешь `name` для `ngModel` потому что `ngModel` Директива `exportAs` является "ngModel".

</div>

Вы контролируете видимость сообщения об ошибке имени, связывая свойства `name` 
контроль над сообщением `<div>` элементы `hidden` собственность.

<code-example path="forms/src/app/hero-form/hero-form.component.html" header="src/app/hero-form/hero-form.component.html (hidden-error-msg)" region="hidden-error-msg"></code-example>

В этом примере вы скрываете сообщение, когда элемент управления является действительным или нетронутым;
«нетронутый» означает, что пользователь не изменил значение с момента его отображения в этой форме.

Этот пользовательский опыт - выбор разработчика. Некоторые разработчики хотят, чтобы сообщение отображалось всегда.
Если вы игнорируете `pristine` состояние, вы могли бы скрыть сообщение только тогда, когда значение является действительным.
Если вы прибываете в этом компоненте с новым (пустым) героем или недействительным героем,
вы увидите сообщение об ошибке немедленно, прежде чем вы что-то сделали.

Некоторые разработчики хотят, чтобы сообщение отображалось только тогда, когда пользователь вносит недопустимые изменения.
Сокрытие сообщения, пока элемент управления «нетронут», достигает этой цели.
Вы увидите значение этого выбора, когда добавите нового героя в форму.

Герой *Alter Ego не* является обязательным, поэтому вы можете оставить это.

Героев *Силы* Требуется выбор.
Вы можете добавить такую ​​же обработку ошибок в `<select>` если хотите
но это не обязательно, потому что поле выбора уже ограничивает
сила к действительным значениям.

Теперь вы добавите нового героя в эту форму.
Поместите *Новый герой»* кнопку « внизу формы и привяжите ее к событию `newHero` компонента.

<code-example path="forms/src/app/hero-form/hero-form.component.html" region="new-hero-button-no-reset" header="src/app/hero-form/hero-form.component.html (New Hero button)"></code-example>

<code-example path="forms/src/app/hero-form/hero-form.component.ts" region="new-hero" header="src/app/hero-form/hero-form.component.ts (New Hero method)"></code-example>

Запустите приложение еще раз, нажмите кнопку « *Новый герой»*, и форма очистится.
В *необходимых* полосы слева от поля ввода красный, что указывает недействительным `name` и `power` свойства.
Это понятно, так как это обязательные поля.
Сообщения об ошибках скрыты, потому что форма является нетронутой; Вы еще ничего не изменили.

Введите имя и нажмите « *Новый герой»* снова.
Приложение отображает _Name is required_ сообщение об ошибке.
Вам не нужны сообщения об ошибках при создании нового (пустого) героя.
Почему вы получаете один сейчас?

Изучение элемента в инструментах браузера показывает, что поле *имени* ввода _не длиннее нетронутого_.
Форма запоминает, что вы ввели имя до нажатия *New Hero*.
Замена объекта героя *не восстановила первоначальное состояние* элементов управления формы.

Вы должны обязательно очистить все флаги, что вы можете сделать
позвонив в форму `reset()` метод после вызова `newHero()`.

<code-example path="forms/src/app/hero-form/hero-form.component.html" region="new-hero-button-form-reset" header="src/app/hero-form/hero-form.component.html (Reset the form)"></code-example>

Теперь нажатие «Новый герой» сбрасывает как форму, так и ее управляющие флаги.

{@a submit-the-form-with-ngsubmit}
## Отправьте форму с помощью _ngSubmit_

Пользователь должен иметь возможность отправить эту форму после заполнения
« *Отправить»* Кнопка внизу формы
ничего не делает сам по себе, но будет
вызвать отправку формы из-за ее типа (`type="submit"`).

«Форма отправки» в данный момент бесполезна.
Чтобы сделать его полезным, свяжите форму `ngSubmit` события
к компоненту формы героя `onSubmit()` Метод:

<code-example path="forms/src/app/hero-form/hero-form.component.html" header="src/app/hero-form/hero-form.component.html (ngSubmit)" region="ngSubmit"></code-example>

Вы уже определили переменную ссылки на шаблон
 `#heroForm` и инициализировал его значением "ngForm".
Теперь используйте эту переменную для доступа к форме с помощью кнопки «Отправить».


Вы свяжете полную действительность формы через
 `heroForm` переменная для кнопки `disabled` свойство
используя привязку события. Вот код:

<code-example path="forms/src/app/hero-form/hero-form.component.html" header="src/app/hero-form/hero-form.component.html (submit-button)" region="submit-button"></code-example>

Если вы запустите приложение сейчас, вы обнаружите, что кнопка включена, хотя
пока что ничего полезного не делает.

Теперь, если вы удаляете Имя, вы нарушаете «обязательное» правило, которое
должным образом отмечено в сообщении об ошибке.
« *Отправить»* Кнопка также отключена.

Не впечатлен? Задумайтесь об этом на мгновение. Что бы тебе пришлось сделать
связать состояние включения / выключения кнопки с действительностью формы без помощи Angular?

Для вас это было так просто, как это:

1. Определите ссылочную переменную шаблона в (расширенном) элементе формы.
2. Обратитесь к этой переменной в кнопке за много строк.

{@a toggle-two-form-regions-extra-credit}
## Переключить два региона формы (дополнительный кредит)

Отправка формы на данный момент не очень драматична.

<div class="alert is-helpful">

  Неудивительное наблюдение за демо. Если честно
  это не научит вас чему-то новому о формах.
  Но это возможность использовать некоторые из ваших недавно выигранных
  обязательные навыки.
  Если вы не заинтересованы, перейдите к выводу этой страницы.

</div>

Для более поразительного визуального эффекта
скрыть область ввода данных и отобразить что-то еще.

Заверните форму в `<div>` и связывай
его `hidden` свойство `HeroFormComponent.submitted` свойство.

<code-example path="forms/src/app/hero-form/hero-form.component.html" header="src/app/hero-form/hero-form.component.html (excerpt)" region="edit-div"></code-example>

Основная форма видна с самого начала, потому что
 `submitted` свойство является ложным, пока вы не отправите форму
как этот фрагмент из `HeroFormComponent` показывает:

<code-example path="forms/src/app/hero-form/hero-form.component.ts" header="src/app/hero-form/hero-form.component.ts (submitted)" region="submitted"></code-example>

Когда вы нажимаете кнопку « *Отправить»*, `submitted` флаг становится истинным, а форма исчезает
как запланировано.

Теперь приложение должно показать что-то еще, пока форма находится в отправленном состоянии.
Добавьте следующий HTML ниже `<div>` обертка, которую вы только что написали

<code-example path="forms/src/app/hero-form/hero-form.component.html" header="src/app/hero-form/hero-form.component.html (excerpt)" region="submitted"></code-example>

Там снова герой, отображается только для чтения с интерполяционными привязками.
Эта `<div>` появляется только тогда, когда компонент находится в представленном состоянии.

HTML-код включает *Изменить»* кнопку «, событие щелчка которой связано с выражением
это очищает `submitted` флаг.

Когда вы нажимаете кнопку « *Изменить»*, этот блок исчезает, и редактируемая форма появляется снова.

{@a summary}
## Резюме

Angular форма, обсуждаемая на этой странице, использует следующие преимущества
рамки возможностей, чтобы обеспечить поддержку для модификации данных, проверки и многое другое:

* Angular шаблон HTML-формы.
* Класс компонента формы с `@Component` декоратор.
* Обработка подачи заявки путем привязки к `NgForm.ngSubmit` события.
* Переменные шаблона ссылки, такие как `#heroForm` и `#name`.
* `[(ngModel)]` синтаксис для двусторонней привязки данных.
* Использование `name` атрибуты для проверки и отслеживания изменений элемента формы.
* Ссылочная переменная `valid` свойство на элементах управления вводом, чтобы проверить, является ли элемент управления действительным, и показать / скрыть сообщения об ошибках.
* Управление*Отправить * включенным состоянием кнопки « » путем привязки к `NgForm` действия.
* Пользовательские классы CSS, которые предоставляют визуальную обратную связь пользователям о недопустимых элементах управления.

Вот код для окончательной версии приложения:

<code-tabs>

  <code-pane header="hero-form/hero-form.component.ts" path="forms/src/app/hero-form/hero-form.component.ts" region="final">

  </code-pane>

  <code-pane header="hero-form/hero-form.component.html" path="forms/src/app/hero-form/hero-form.component.html" region="final">

  </code-pane>

  <code-pane header="hero.ts" path="forms/src/app/hero.ts">

  </code-pane>

  <code-pane header="app.module.ts" path="forms/src/app/app.module.ts">

  </code-pane>

  <code-pane header="app.component.html" path="forms/src/app/app.component.html">

  </code-pane>

  <code-pane header="app.component.ts" path="forms/src/app/app.component.ts">

  </code-pane>

  <code-pane header="main.ts" path="forms/src/main.ts">

  </code-pane>

  <code-pane header="forms.css" path="forms/src/assets/forms.css">

  </code-pane>

</code-tabs>

