{@a ahead-of-time-aot-compilation}
# Опережающая (AOT) компиляция

Приложение Angular состоит в основном из компонентов и их HTML-шаблонов. Поскольку компоненты и шаблоны, предоставляемые Angular, не могут быть поняты браузером напрямую, приложения Angular требуют процесса компиляции, прежде чем они смогут работать в браузере.

Angular [опережающий по времени (AOT) компилятор](guide/glossary#aot)преобразует ваш код Angular HTML и TypeScript в эффективный код JavaScript на этапе сборки, прежде чем браузер загрузит и запустит этот код. Компиляция приложения во время процесса сборки обеспечивает более быструю визуализацию в браузере.

В этом руководстве объясняется, как указывать метаданные и применять доступные параметры компилятора для эффективной компиляции ваших приложений с использованием компилятора AOT.

<div class="alert is-helpful">

Смотрите, как автор компилятора Тобиас Бош объясняет Angular-компилятор на AngularConnect 2016

</div>

{@a why-aot}

Вот несколько причин, по которым вы можете использовать AOT.

* *Более быстрый рендеринг*
   С помощью AOT браузер загружает предварительно скомпилированную версию приложения.
   Браузер загружает исполняемый код, чтобы он мог визуализировать приложение немедленно, не дожидаясь его компиляции.

* *Меньше асинхронных запросов*
   Компилятор _inlines_ внешние шаблоны HTML и таблицы стилей CSS в приложении JavaScript
   устранение отдельных запросов AJAX для этих исходных файлов.

* *Меньший Angular размер загрузки*
   Нет необходимости загружать компилятор Angular, если приложение уже скомпилировано.
   Компилятор составляет примерно половину самого Angular, поэтому его пропуск значительно снижает полезную нагрузку приложения.

* *Обнаружение ошибок шаблона ранее*
   Компилятор AOT обнаруживает и сообщает об ошибках привязки шаблона на этапе сборки
   прежде чем пользователи смогут их увидеть.

* *Лучшая безопасность*
   AOT компилирует HTML-шаблоны и компоненты в файлы JavaScript задолго до того, как они будут переданы клиенту.
   Отсутствие шаблонов для чтения и рискованная оценка HTML или JavaScript на стороне клиента
   Есть меньше возможностей для инъекционных атак.

{@a overview}

{@a choosing-a-compiler}
## Выбор компилятора

Angular предлагает два способа компиляции приложения:

* **_Just-in-Time_ (JIT)**, который компилирует ваше приложение в браузере во время выполнения.
* **_Ahead-of-Time_ (AOT)**, которая компилирует ваше приложение во время сборки.

JIT-компиляция используется по умолчанию при запуске [ `нг build` ](cli/build)(сборка только) или [ ` нг serve` ](cli/serve) (сборка и служит локально) команды CLI:

<code-example language="sh" class="code-shell">
  ng build
  ng serve
</code-example>

{@a compile}

Для компиляции AOT, включите `--aot` вариант с `ng build ` или ` ng serve` команды:

<code-example language="sh" class="code-shell">
  ng build --aot
  ng serve --aot
</code-example>

<div class="alert is-helpful">

 `ng build` Команда с `--prod` meta-flag (`ng build --prod`) компилируется с AOT по умолчанию.

См. [Справочник по командам CLI](cli)и [Создание и обслуживание приложений Angular](guide/build)для получения дополнительной информации.

</div>

{@a how-aot-works}
## Как работает AOT

Компилятор Angular AOT извлекает **метаданные** для интерпретации частей приложения, которыми должен управлять Angular.
Вы можете указать метаданные явно в **декораторах,** таких как `@Component()` и `@Input()` или неявно в объявлениях конструктора декорированных классов.
Метаданные сообщают Angular, как создавать экземпляры классов вашего приложения и взаимодействовать с ними во время выполнения.

В следующем примере `@Component()` метаданных и конструктор класса сообщают Angular, как создавать и отображать экземпляр `TypicalComponent`.

```typescript
@Component({
  selector: 'app-typical',
  template: '<div>A typical component for {{data.name}}</div>'
)}
export class TypicalComponent {
  @Input() data: TypicalData;
  constructor(private someService: SomeService) {... }
}
```

Компилятор Angular извлекает метаданные _once_ и генерирует _factory_ для `TypicalComponent`.
Когда нужно создать `TypicalComponent`, Angular вызывает фабрику, которая создает новый визуальный элемент, связанный с новым экземпляром класса компонента с его внедренной зависимостью.

{@a compilation-phases}
### Этапы компиляции

Есть три этапа компиляции AOT.
* Этап 1 -*анализ кода *.
   На этом этапе компилятор TypeScript и *сборщик AOT* создают представление источника. Сборщик не пытается интерпретировать метаданные, которые он собирает. Он представляет метаданные как можно лучше и записывает ошибки, когда обнаруживает нарушение синтаксиса метаданных.

* Этап 2 -*генерация кода *.
    На этом этапе компилятор `StaticReflector` интерпретирует метаданные, собранные на этапе 1, выполняет дополнительную проверку метаданных и выдает ошибку, если обнаруживает нарушение ограничения метаданных.

* Этап 3 -*проверка типа шаблона *.
   На этом необязательном этапе Angular *компилятор шаблонов* использует компилятор TypeScript для проверки выражений привязки в шаблонах. Вы можете включить эту фазу явно, установив `fullTemplateTypeCheck` конфигурации ; см. [Опции Angular компилятора](guide/angular-compiler-options).


{@a metadata-restrictions}
### Метаданные ограничения

Вы пишете метаданные в _subset_ машинописного текста, который должен соответствовать следующим общим ограничениям:

* Ограничение [синтаксис выражения](#expression-syntax)поддерживаемым подмножеством JavaScript.
* Только ссылки на экспортируемые символы после [свертывание кода](#code-folding).
* Только вызов [функции поддерживаются](#supported-functions)компилятором.
* Украшенные и привязанные к данным члены класса должны быть открытыми.

Дополнительные указания и инструкции по подготовке приложения для компиляции AOT см. В разделе [Angular: Написание приложений, дружественных к AOT](https://medium.com/sparkles-blog/angular-writing-aot-friendly-applications-7b64c8afbe3f).

<div class="alert is-helpful">

Ошибки в компиляции AOT обычно возникают из-за метаданных, которые не соответствуют требованиям компилятора (как более подробно описано ниже).
Для получения справки по пониманию и решению этих проблем см. [Ошибки метаданных AOT](guide/aot-metadata-errors).

</div>

{@a configuring-aot-compilation}
### Настройка компиляции AOT

Вы можете предоставить варианты в `tsconfig.json` [файл конфигурации TypeScript](guide/typescript-configuration), управляющий процессом компиляции. Смотрите [Опции Angular компилятора](guide/angular-compiler-options)для полного списка доступных опций.

{@a phase-1-code-analysis}
## Этап 1: Анализ кода

Компилятор TypeScript выполняет некоторую аналитическую работу первого этапа. Испускает `.d.ts` _type определения files_ с информацией о типе, которая нужна компилятору AOT для генерации кода приложения.
В то же время AOT **сборщик** анализирует метаданные, записанные в Angular декораторах, и выводит информацию метаданных в** `.metadata.json`** файлы, по одному на `.d.ts` файл

Вы можете думать о `.metadata.json` как диаграмма общей структуры метаданных декоратора, представленная в виде [абстрактного синтаксического дерева (AST)](https://en.wikipedia.org/wiki/Abstract_syntax_tree).

<div class="alert is-helpful">

Angular's [schema.ts](https://github.com/angular/angular/blob/master/packages/compiler-cli/src/metadata/schema.ts)
описывает формат JSON как набор интерфейсов TypeScript.

</div>

{@a expression-syntax}
{@a expression-syntax-limitations}
### Ограничения синтаксиса выражения

Сборщик AOT понимает только часть JavaScript.
Определение метаданных объектов со следующим ограниченным синтаксисом:

<style>
  td, th {vertical-align: top}
</style>

<table>
  <tr>
    <th>Синтаксис </th>
    <th>Пример </th>
  </tr>
  <tr>
    <td>Буквальный объект </td>
    <td><code>{cherry: true, apple: true, mincemeat: false}</code></td>
  </tr>
  <tr>
    <td>Литеральный массив </td>
    <td><code>['cherries', 'flour', 'sugar']</code></td>
  </tr>
  <tr>
    <td>Распространение в буквальном массиве </td>
    <td><code>['apples', 'flour',...the_rest]</code></td>
  </tr>
   <tr>
    <td>Звонки </td>
    <td><code>bake(ingredients)</code></td>
  </tr>
   <tr>
    <td>Новый </td>
    <td><code>new Oven()</code></td>
  </tr>
   <tr>
    <td>Доступ к недвижимости </td>
    <td><code>pie.slice</code></td>
  </tr>
   <tr>
    <td>Индекс массива </td>
    <td><code>ingredients[0]</code></td>
  </tr>
   <tr>
    <td>Ссылка на личность </td>
    <td><code>Component</code></td>
  </tr>
   <tr>
    <td>Строка шаблона </td>
    <td><code> `pie is ${multiplier} times better than cake` </code></td>
   <tr>
    <td>Литеральная строка</td>
    <td><code>pi</code></td>
  </tr>
   <tr>
    <td>Буквенный номер </td>
    <td><code>3.14153265</code></td>
  </tr>
   <tr>
    <td>Буквально логическое </td>
    <td><code>true</code></td>
  </tr>
   <tr>
    <td>Буквальное нуль </td>
    <td><code>null</code></td>
  </tr>
   <tr>
    <td>Поддерживается префикс оператора </td>
    <td><code>!cake</code></td>
  </tr>
   <tr>
    <td>Поддерживается бинарный оператор </td>
    <td><code>a+b</code></td>
  </tr>
   <tr>
    <td>Условный оператор </td>
    <td><code>a ? b : c</code></td>
  </tr>
   <tr>
    <td>Скобки </td>
    <td><code>(a+b)</code></td>
  </tr>
</table>


Если выражение использует неподдерживаемый синтаксис, сборщик записывает узел ошибки в `.metadata.json` Файл.
Позднее компилятор сообщает об ошибке, если ему нужен этот фрагмент метаданных для генерации кода приложения.

<div class="alert is-helpful">

Если хочешь `ngc` сообщать о синтаксических ошибках немедленно, а не производить `.metadata.json` файл с ошибками, установите `strictMetadataEmit` опция в файле конфигурации TypeScript, `tsconfig.json`.

```
  "angularCompilerOptions": {
  ...
   "strictMetadataEmit" : true
 }
 ```

Angular библиотеки имеют эту опцию, чтобы гарантировать, что все Angular `.metadata.json` Файлы чистые, и рекомендуется делать то же самое при создании собственных библиотек.

</div>

{@a function-expression}
{@a arrow-functions}
{@a no-arrow-functions}
### Нет стрелка функции

Компилятор AOT не поддерживает [выражения функций](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function)
и [функции стрелок](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), также называемые функциями _lambda_.

Рассмотрим следующий компонент декоратора:

```typescript
@Component({
 ...
  providers: [{provide: server, useFactory: () => new Server()}]
})
```

Коллектор AOT не поддерживает функцию стрелки, `() => new Server()`, в выражении метаданных.
Он генерирует узел ошибки вместо функции.
Когда компилятор позже интерпретирует этот узел, он сообщает об ошибке, которая предлагает вам превратить функцию стрелки в _exported function_.

Вы можете исправить ошибку путем преобразования этого:

```typescript
export function serverFactory() {
  return new Server();
}

@Component({
 ...
  providers: [{provide: server, useFactory: serverFactory}]
})
```

В версии 5 и более поздних, компилятор автоматически выполняет эту перезапись, испуская `.js` файл

{@a exported-symbols}
{@a code-folding}
{@a code-folding}
### Код сворачивается

Компилятор может разрешать ссылки только на **_exported_** символы.
Коллектор, однако, может оценить выражение во время сбора и записать результат в `.metadata.json`, а не оригинальное выражение.
Это позволяет вам ограниченно использовать неэкспортированные символы в выражениях.

Например, сборщик может оценить выражение `1 + 2 + 3 + 4` и заменить его результатом, `10`.
Этот процесс называется _folding_. Выражение, которое может быть уменьшено таким образом, является _foldable_.

{@a var-declaration}
Коллекционер может оценить ссылки на локальный модуль `const` объявления и инициализированные `var` и `let` объявления, эффективно удаляя их из `.metadata.json` Файл.

Рассмотрим следующий компонент определения:

```typescript
const template = '<div>{{hero.name}}</div>';

@Component({
  selector: 'app-hero',
  template: template
})
export class HeroComponent {
  @Input() hero: Hero;
}
```

Компилятор не может ссылаться на `template` константу потому что она не экспортируется.
Коллектор, однако, может сложить `template` константу в определение метаданных путем включения его содержимого.
Эффект такой же, как если бы вы написали:

```typescript
@Component({
  selector: 'app-hero',
  template: '<div>{{hero.name}}</div>'
})
export class HeroComponent {
  @Input() hero: Hero;
}
```

Больше нет ссылки на `template` и, следовательно, ничего не беспокоит компилятор, когда он позже интерпретирует вывод _collector's_ в `.metadata.json`.

Вы можете сделать этот пример еще дальше, включив `template` постоянны в другое выражение:

```typescript
const template = '<div>{{hero.name}}</div>';

@Component({
  selector: 'app-hero',
  template: template + '<div>{{hero.title}}</div>'
})
export class HeroComponent {
  @Input() hero: Hero;
}
```

Коллектор уменьшает это выражение его эквивалентную строку _folded_:

```
'<div>{{hero.name}}</div><div>{{hero.title}}</div>'
```

{@a foldable-syntax}
#### Складной синтаксис

В следующей таблице описаны выражения коллектор может и не может сложить:

<style>
  td, th {vertical-align: top}
</style>

<table>
  <tr>
    <th>Синтаксис </th>
    <th>Складная </th>
  </tr>
  <tr>
    <td>Буквальный объект </td>
    <td>да </td>
  </tr>
  <tr>
    <td>Литеральный массив </td>
    <td>да </td>
  </tr>
  <tr>
    <td>Распространение в буквальном массиве </td>
    <td>нет </td>
  </tr>
   <tr>
    <td>Звонки </td>
    <td>нет </td>
  </tr>
   <tr>
    <td>Новый </td>
    <td>нет </td>
  </tr>
   <tr>
    <td>Доступ к недвижимости </td>
    <td>да, если цель складная </td>
  </tr>
   <tr>
    <td>Индекс массива </td>
    <td>да, если цель и индекс складываются </td>
  </tr>
   <tr>
    <td>Ссылка на личность </td>
    <td>да, если это ссылка на местный </td>
  </tr>
   <tr>
    <td>Шаблон без замен </td>
    <td>да </td>
  </tr>
   <tr>
    <td>Шаблон с подстановками </td>
    <td>да, если замены складываются </td>
  </tr>
   <tr>
    <td>Литеральная строка </td>
    <td>да </td>
  </tr>
   <tr>
    <td>Буквенный номер </td>
    <td>да </td>
  </tr>
   <tr>
    <td>Буквально логическое </td>
    <td>да </td>
  </tr>
   <tr>
    <td>Буквальное нуль </td>
    <td>да </td>
  </tr>
   <tr>
    <td>Поддерживается префикс оператора </td>
    <td>да, если операнд является складным </td>
  </tr>
   <tr>
    <td>Поддерживается бинарный оператор </td>
    <td>да, если слева и справа являются складными </td>
  </tr>
   <tr>
    <td>Условный оператор </td>
    <td>да, если условие складывается </td>
  </tr>
   <tr>
    <td>Скобки </td>
    <td>да, если выражение складывается </td>
  </tr>
</table>


Если выражение не является складным, сборщик записывает его в `.metadata.json` как [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree)для разрешения компилятором.


{@a phase-2-code-generation}
## Этап 2: генерация кода

Сборщик не пытается понять метаданные, которые он собирает и выводит на `.metadata.json`.
Он представляет метаданные как можно лучше и записывает ошибки, когда обнаруживает нарушение синтаксиса метаданных.
Работа компилятора заключается в интерпретации `.metadata.json` на этапе генерации кода.

Компилятор понимает все синтаксические формы, которые поддерживает сборщик, но он может отклонить _синтаксически_ правильные метаданные, если _semantics_ нарушает правила компилятора.

{@a public-symbols}
### Публичные символы

Компилятор может ссылаться только на _экспортированные символы_.

* Декорированные компоненты класса должны быть открытыми. Вы не можете сделать `@Input()` частное или защищенное.
* Свойства, связанные с данными, также должны быть открытыми.

```typescript
// BAD CODE - title is private
@Component({
  selector: 'app-root',
  template: '<h1>{{title}}</h1>'
})
export class AppComponent {
  private title = 'My App'; // Bad
}
```

{@a supported-functions}

{@a supported-classes-and-functions}
### Поддерживаемые классы и функции

Сборщик может представлять вызов функции или создание объекта с `new` пока синтаксис действителен.
Однако позже компилятор может отказаться генерировать вызов функции _particular_ или создание объекта _particular_.

Компилятор может создавать только экземпляры определенных классов, поддерживает только основные декораторы и поддерживает только вызовы макросов (функций или статических методов), которые возвращают выражения.
* Новые экземпляры

   Компилятор допускает только метаданные, которые создают экземпляры класса `InjectionToken` из `@angular/core`.

* Поддерживаются декораторы

   Компилятор поддерживает только метаданные для [Angular декораторы в модуле `@ angular / core` ](api/core#decorators).

* Вызовы функций

   Фабричные функции должны быть экспортированы, именованные функции.
   Компилятор AOT не поддерживает лямбда-выражения («функции стрелок») для заводских функций.

{@a function-calls}
{@a functions-and-static-method-calls}
### Функции и вызовы статических методов

Сборщик принимает любую функцию или статический метод, который содержит один `return` заявления
Однако компилятор поддерживает только макросы в форме функций или статических методов, которые возвращают *выражение*.

Например, рассмотрим следующую функцию:

```typescript
export function wrapInArray<T>(value: T): T[] {
  return [value];
}
```

Вы можете позвонить `wrapInArray` в определении метаданных, потому что он возвращает значение выражения, которое соответствует ограничительному подмножеству JavaScript компилятора.

Вы могли бы использовать `wrapInArray()` как это:

```typescript
@NgModule({
  declarations: wrapInArray(TypicalComponent)
})
export class TypicalModule {}
```

Компилятор обрабатывает это использование, как если бы вы написали:

```typescript
@NgModule({
  declarations: [TypicalComponent]
})
export class TypicalModule {}
```
Angular [ `RouterModule` макростатических](api/router/RouterModule)экспортирует два метода, `forRoot` и `forChild`, чтобы помочь объявить корневые и дочерние маршруты.
Просмотрите [исходный код](https://github.com/angular/angular/blob/master/packages/router/src/router_module.ts#L139 "RouterModule.forRoot source code")
для этих методов, чтобы увидеть, как макросы могут упростить настройку сложных [NgModules](guide/ngmodules).

{@a metadata-rewriting}

{@a metadata-rewriting}
### Переписывание метаданных

Компилятор обрабатывает литералы объекта, содержащие поля `useClass`, `useValue`, `useFactory` и `data` специально для, преобразуя выражение, инициализирующее одно из этих полей, в экспортируемую переменную, которая заменяет выражение.
Этот процесс переписывания этих выражений снимает все ограничения на то, что может быть в них, потому что
компилятору не нужно знать значение выражения - ему просто нужно иметь возможность генерировать ссылку на значение.

Вы могли бы написать что - то вроде:

```typescript
class TypicalServer {

}

@NgModule({
  providers: [{provide: SERVER, useFactory: () => TypicalServer}]
})
export class TypicalModule {}
```

Без переписывания это было бы недопустимо, потому что лямбды не поддерживаются и `TypicalServer` не экспортируется.
Чтобы разрешить это, компилятор автоматически переписывает это что - то вроде:

```typescript
class TypicalServer {

}

export const ɵ0 = () => new TypicalServer();

@NgModule({
  providers: [{provide: SERVER, useFactory: ɵ0}]
})
export class TypicalModule {}
```

Это позволяет компилятору генерировать ссылку на `ɵ0` заводе, не зная, какова стоимость `ɵ0` содержит.

Компилятор выполняет переписывание во время передачи `.js` файл
Это, однако, не переписывает `.d.ts` файл, поэтому TypeScript не распознает его как экспорт. и это не мешает экспортированному API модуля ES.


{@a binding-expression-validation}
{@a phase-3-template-type-checking}
## Этап 3: проверка типа шаблона

Одна из наиболее полезных функций компилятора Angular - это возможность проверять выражения в шаблонах и обнаруживать любые ошибки, прежде чем они вызовут сбои во время выполнения.
На этапе проверки типа шаблона компилятор шаблона Angular использует компилятор TypeScript для проверки выражений привязки в шаблонах.

Включите этот этап явно, добавив опцию компилятора `"fullTemplateTypeCheck"` в `"angularCompilerOptions"` проекта `tsconfig.json` 
(см. [Параметры Angular компилятора](guide/angular-compiler-options)).

<div class="alert is-helpful">

В [Angular Ivy](guide/ivy)средство проверки типов шаблонов было полностью переписано, чтобы сделать его более функциональным и более строгим, что означает, что он может отловить множество новых ошибок, которые предыдущая программа проверки типов не обнаружит.

В результате шаблоны, ранее скомпилированные в View Engine, могут не проходить проверку типов в Ivy. Это может произойти, потому что более строгая проверка Ivy ловит подлинные ошибки, или потому что код приложения набран неправильно, или потому что приложение использует библиотеки, в которых типизация неточна или недостаточно конкретна.

Эта более строгая проверка типов не включена по умолчанию в версии 9, но ее можно включить, установив `strictTemplates` конфигурации.
Мы ожидаем сделать строгую проверку типов по умолчанию в будущем.

<!-- For more information about type-checking options, and about improvements to template type checking in version 9 and above, see [Template type checking](guide/template-type-checking). -->

</div>

Проверка шаблона выдает сообщения об ошибках, когда в привязке шаблона обнаружена ошибка типа
выражение, аналогично тому, как ошибки типа сообщаются компилятором TypeScript против кода в `.ts` 
файл.

Например, рассмотрим следующий компонент:

```typescript
  @Component({
    selector: 'my-component',
    template: '{{person.addresss.street}}'
  })
  class MyComponent {
    person?: Person;
  }
```

Это производит следующее сообщение об ошибке:

```
  my.component.ts.MyComponent.html(1,1): : Property 'addresss' does not exist on type 'Person'. Did you mean 'address'?
 ```

Имя файла, указанное в сообщении об ошибке, `my.component.ts.MyComponent.html`, это синтетический файл
генерируется компилятором шаблона, который содержит содержимое `MyComponent` класса.
Компилятор никогда не записывает этот файл на диск.
Номера строк и столбцов относятся к строке шаблона в `@Component` аннотация класса, `MyComponent` в этом случае.
Если компонент использует `templateUrl` вместо `template`, ошибки сообщаются в файле HTML, на который ссылается `templateUrl` вместо синтетического файла.

Расположение ошибки - это начало текстового узла, который содержит выражение интерполяции с ошибкой.
Если ошибка в привязке атрибута, такой как `[value]="person.address.street"`, ошибка
location - это местоположение атрибута, содержащего ошибку.

При проверке используется средство проверки типов TypeScript и параметры, предоставляемые компилятору TypeScript, для управления подробностью проверки типа.
Например, если `strictTypeChecks` указан, ошибка
`` `my.component.ts.MyComponent.html(1,1): : Object is possibly 'undefined'` ``
сообщается, а также выше сообщение об ошибке.

{@a type-narrowing}
### Типа сужения

Выражение, используемое в `ngIf` Директива используется для сужения типов в Angular
компилятор шаблона, так же, как `if` выражение делает в TypeScript.
Например, чтобы избежать `Object is possibly 'undefined'` ошибкой в ​​приведенном выше шаблоне, измените его так, чтобы он испускал интерполяцию только в том случае, если значение `person` инициализируется, как показано ниже:

```typescript
  @Component({
    selector: 'my-component',
    template: '<span *ngIf="person"> {{person.addresss.street}} </span>'
  })
  class MyComponent {
    person?: Person;
  }
```

С помощью `*ngIf` позволяет компилятору TypeScript сделать вывод, что `person` используемый в выражении связывания никогда не будет `undefined`.

{@a custom-ngif-like-directives}
#### изготовленный на заказ `ngIf` нравятся директивы

Директивы, которые ведут себя как `*ngIf` может объявить, что они хотят одинаковую обработку, включив статический маркер-член, который является сигналом для компилятора шаблона, чтобы он воспринимал их как `*ngIf` . Этот статический член для `*ngIf` является:

```typescript
    public static ngIfUseIfTypeGuard: void;
```

Это объявляет, что свойство ввода `ngIf` из `NgIf` Директива должна рассматриваться как защита от использования ее шаблона, подразумевая, что шаблон будет создан только в том случае, если `ngIf` свойство ввода имеет значение true.


{@a non-null-type-assertion-operator}
### Оператор утверждения ненулевого типа

Используйте [оператор утверждения не нулевого типа](guide/template-syntax#non-null-assertion-operator)чтобы подавить `Object is possibly 'undefined'` ошибкой, когда его неудобно использовать `*ngIf` или когда какое-либо ограничение в компоненте гарантирует, что выражение всегда будет ненулевым, когда выражение привязки интерполируется.

В следующем примере `person` и `address` свойства всегда устанавливаются вместе, подразумевая, что `address` всегда ненулевой, если `person` ненулевой
Нет удобного способа описать это ограничение для TypeScript и компилятора шаблонов, но ошибка в этом примере подавляется с помощью `address!.street`.

```typescript
  @Component({
    selector: 'my-component',
    template: '<span *ngIf="person"> {{person.name}} lives on {{address!.street}} </span>'
  })
  class MyComponent {
    person?: Person;
    address?: Address;

    setData(person: Person, address: Address) {
      this.person = person;
      this.address = address;
    }
  }
```

Оператор ненулевого утверждения следует использовать с осторожностью, поскольку рефакторинг компонента может нарушить это ограничение.

В этом примере рекомендуется включить проверку `address` в `*ngIf` как показано ниже:

```typescript
  @Component({
    selector: 'my-component',
    template: '<span *ngIf="person && address"> {{person.name}} lives on {{address.street}} </span>'
  })
  class MyComponent {
    person?: Person;
    address?: Address;

    setData(person: Person, address: Address) {
      this.person = person;
      this.address = address;
    }
  }
```
