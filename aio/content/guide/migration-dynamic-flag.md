
{@a dynamic-queries-flag-migration}
# Динамический запрос флагов миграции

{@a what-does-this-migration-do}
## Что делает эта миграция?

В Angular версии 8 добавлена ​​схема `static` флаги всем `@ViewChild()` и `@ContentChild()`.
Это был первый шаг к изменению поведения по умолчанию.
В версии 9 значение по умолчанию изменяется на `static: false` и флаг становится необязательным.

Эта схема сканирует классы в компиляции и для каждого класса проверяет, есть ли у членов `@ViewChild()` или `@ContentChild()` с `static` флаг установлен в `false`.
Если это так, схема удаляет флаг, поскольку теперь он соответствует значению по умолчанию.

**Перед тем как :**
```ts
@ViewChild('foo', {static: false}) foo: ElementRef;

@ViewChild('bar', {static: true}) bar: ElementRef;
```


**После того, как :**
```ts
@ViewChild('foo') foo: ElementRef;

// this query doesn't change because the static value is true
@ViewChild('bar', {static: true}) bar: ElementRef;
```

Обратите внимание, что флаг не поддерживается в `@ViewChildren()` или `@ContentChildren()`, поэтому схема не будет проверять эти свойства.


{@a why-is-this-migration-necessary}
## Почему эта миграция необходима?

Эта схема выполняет очистку кода для удаления `static` флаги, которые соответствуют значениям по умолчанию, так как они больше не нужны.
С функциональной точки зрения изменение кода должно быть пустяком.

До версии 9 Angular автоматически определял статическую или динамическую природу запроса, основываясь на том, как был написан шаблон.
Однако просмотр шаблонов таким образом вызвал глючное и неожиданное поведение (подробнее об этом см. В [Руководство по миграции статических запросов](guide/static-query-migration#what-does-this-flag-mean)).
Начиная с версии 9, Angular использует динамические запросы (`static: false`) по умолчанию, что упрощает запросы.
Разработчики все еще могут явно задать запрос `static: true` если необходимо.


<div class=" alert is-helpful">

{@a what-is-the-difference-between-static-and-dynamic-queries}
### В чем разница между статическими и динамическими запросами?

 `static` опция для `@ViewChild()` и `@ContentChild()` определяют, когда станут доступны результаты запроса.

Со статическими запросами (`static: true`) запрос разрешается после создания представления, но до запуска обнаружения изменений.
Результат, однако, никогда не будет обновлен для отражения изменений в вашем представлении, таких как изменения в `ngIf` и `ngFor` блоков.

С динамическими запросами (`static: false`), запрос разрешается после `ngAfterViewInit()` или `ngAfterContentInit()` для `@ViewChild()` и `@ContentChild()` соответственно.
Результат будет обновлен для изменений в вашем представлении, таких как изменения в `ngIf` и `ngFor` блоков.

Для получения дополнительной информации см. Следующие записи в
[статических запросов Руководство по миграции](https://angular.io/guide/static-query-migration):

* [Как мне выбрать, какое значение флага `static` использовать: ` true` или `false` ?](https://angular.io/guide/static-query-migration#how-do-i-choose-which-static-flag-value-to-use-true-or-false)

* [Есть ли случай, когда я должен использовать `{static: true}` ?](https://angular.io/guide/static-query-migration#is-there-a-case-where-i-should-use-static-true)

</div>


{@a what-does-this-mean-for-libraries}
## Что это значит для библиотек?

Для поддержки приложений, которые все еще работают с версией 8, самым безопасным вариантом для библиотек является сохранение `static` флаг для поддержания согласованности времени разрешения.

- *Библиотеки на 9 -ой версии с приложениями, работающими версии 8:*

  Схема не будет работать на библиотеках.
  Пока библиотеки сохраняют свои `static` флаги с версии 8, они должны работать с приложениями на 8

- *Библиотеки на 8 -й версии с приложениями, работающими версии 9:*

  В библиотеках будут определены явные флаги.
  Поведение с явными флагами не изменилось.


{@a what-about-applications-using-non-migrated-libraries}
### А как насчет приложений, использующих немигрированные библиотеки?

Поскольку это чистая очистка кода, но не перенесенные библиотеки будут работать одинаково в любом случае.
