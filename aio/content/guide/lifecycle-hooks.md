{@a lifecycle-hooks}
# Хуки жизненного цикла

У компонента есть жизненный цикл, управляемый Angular.

Angular создает и отображает компоненты вместе со своими дочерними элементами, проверяет, когда их привязанные к данным свойства изменяются, и уничтожает их перед удалением из DOM.

Angular предлагает **хуки жизненного цикла**
которые обеспечивают видимость в эти ключевые моменты жизни и способность действовать, когда они происходят.

Директива имеет тот же набор хуков жизненного цикла.

{@a hooks-overview}

{@a component-lifecycle-hooks-overview}
## Обзор хуков жизненного цикла компонентов

Директивы и экземпляры компонентов имеют жизненный цикл
так как Angular создает, обновляет и уничтожает их.
Разработчики могут использовать ключевые моменты этого жизненного цикла, внедряя их
один или несколько *жизненного цикла* интерфейсов ловушек в Angular `core` библиотека.

Каждый интерфейс имеет единственный метод подключения, именем которого является имя интерфейса с префиксом `ng`.
Например, `OnInit` интерфейсе есть метод ловушки `ngOnInit()` 
что Angular вызовы вскоре после создания компоненты:

<code-example path="lifecycle-hooks/src/app/peek-a-boo.component.ts" region="ngOnInit" header="peek-a-boo.component.ts (excerpt)"></code-example>

Ни одна директива или компонент не будет реализовывать все хуки жизненного цикла.
Angular вызывает только метод ловушки директивы / компонента, *если он определен*.

{@a hooks-purpose-timing}

{@a lifecycle-sequence}
## Последовательность жизненного цикла

*После* создания компонента / директивы путем вызова его конструктора Angular
вызывает методы жизненного цикла хук в следующей последовательности в определенные моменты:

<table width="100%">


  <tr>
    <th>Крюк </th>
    <th>Цель и сроки </th>
  </tr>
  <tr style='vertical-align:top'>
    <td>
      <code>ngOnChanges()</code>
    </td>
    <td>

      Отвечайте, когда Angular (re) устанавливает привязанные к данным свойства ввода.
      Метод получает `SimpleChanges` объект текущих и предыдущих значений свойств.

      Вызывается раньше `ngOnInit()` и всякий раз, когда одно или несколько связанных с данными входных свойств.

    </td>
  </tr>
  <tr style='vertical-align:top'>
    <td>
      <code>ngOnInit()</code>
    </td>
    <td>

      Инициализируйте директиву / компонент после того, как Angular впервые отобразит связанные с данными свойства
      и устанавливает входные свойства директивы / компонента.

      Вызывается _once_, после _first_ `ngOnChanges()`.

    </td>
  </tr>
  <tr style='vertical-align:top'>
    <td>
      <code>ngDoCheck()</code>
    </td>
    <td>

      Обнаруживать и реагировать на изменения, которые Angular не может или не сможет обнаружить самостоятельно.

      Вызывается во время каждого запуска обнаружения изменений, сразу после `ngOnChanges()` и `ngOnInit()`.

    </td>
  </tr>
  <tr style='vertical-align:top'>
    <td>
      <code>ngAfterContentInit()</code>
    </td>
    <td>

      Ответить после того, как Angular проецирует внешнее содержимое в представление компонента / представление, в котором находится директива

      Вызывается _once_ после первого `ngDoCheck()`.

    </td>
  </tr>
  <tr style='vertical-align:top'>
    <td>
      <code>ngAfterContentChecked()</code>
    </td>
    <td>

      Отвечать после Angular проверяет содержимое, проецируемое в директиву / компонент.

      Вызывается после `ngAfterContentInit()` и каждый последующий `ngDoCheck()`.

    </td>
  </tr>
  <tr style='vertical-align:top'>
    <td>
      <code>ngAfterViewInit()</code>
    </td>
    <td>

      Ответить после того, как Angular инициализирует представления компонента и дочерние представления / представление, в котором находится директива

      Вызывается _once_ после первого `ngAfterContentChecked()`.

    </td>
  </tr>
  <tr style='vertical-align:top'>
    <td>
      <code>ngAfterViewChecked()</code>
    </td>
    <td>

      Отвечать после Angular проверяет представления компонента и дочерние представления / представление, в котором находится директива

      Вызывается после `ngAfterViewInit()` и каждый последующий `ngAfterContentChecked()`.

    </td>
  </tr>
  <tr style='vertical-align:top'>
    <td>
      <code>ngOnDestroy()</code>
    </td>
    <td>

      Очистка перед тем, как Angular уничтожит директиву / компонент.
      Отмените подписку Observables и отсоедините обработчики событий, чтобы избежать утечек памяти.

      Вызывается _just before_ Angular уничтожает директиву / компонент.

    </td>
  </tr>
</table>

{@a interface-optional}

{@a interfaces-are-optional-technically}
## Интерфейсы не являются обязательными (технически)

Интерфейсы являются необязательными для разработчиков JavaScript и Typescript с чисто технической точки зрения.
Язык JavaScript не имеет интерфейсов.
Angular не может видеть интерфейсы TypeScript во время выполнения, потому что они исчезают из переданного JavaScript.

К счастью, они не нужны.
Вам не нужно добавлять интерфейсы ловушек жизненного цикла к директивам и компонентам, чтобы извлечь выгоду из самих ловушек.

Вместо этого Angular проверяет классы директив и компонентов и вызывает методы ловушек, *если они определены*.
Angular находит и вызывает такие методы, как `ngOnInit()`, с интерфейсами или без них.

Тем не менее, рекомендуется добавлять интерфейсы в классы директив TypeScript
для того, чтобы извлечь выгоду из сильного набора текста и инструментов редактора.

{@a other-lifecycle-hooks}

{@a other-angular-lifecycle-hooks}
## Прочие Angular хуки жизненного цикла

Другие Angular подсистемы могут иметь свои собственные хуки жизненного цикла, кроме этих хуков компонентов.

Сторонние библиотеки могут также реализовать свои хуки, чтобы дать разработчикам больше
контроль над тем, как используются эти библиотеки.

{@a the-sample}

{@a lifecycle-examples}
## Примеры жизненного цикла

<live-example></live-example>
демонстрирует ловушки жизненного цикла в действии с помощью серии упражнений
представлены как компоненты под контролем корня `AppComponent`.

Они следуют общему шаблону: *родительский* компонент служит для тестирования
*ребенок* компонент, который иллюстрирует один или несколько методов жизненного цикла крючков.

Вот описание краткое каждого упражнения:

<table width="100%">


  <tr>
    <th>Компонент </th>
    <th>Описание </th>
  </tr>
  <tr style='vertical-align:top'>
    <td>
      <a href="#peek-a-boo">Пикабу </a>
    </td>
    <td>

      Демонстрирует каждый хук жизненного цикла.
      Каждый метод подключения записывает данные в экранный журнал.

    </td>
  </tr>
  <tr style='vertical-align:top'>
    <td>
      <a href="#spy">Spy </a>
    </td>
    <td>

      Директивы также имеют хуки жизненного цикла.
 `SpyDirective` может регистрировать, когда элемент, за которым он шпионит
      создан или уничтожен с использованием `ngOnInit` и `ngOnDestroy` хуки.

      В этом примере применяется `SpyDirective` для `<div>` на `ngFor` *героя* репитер
      управляется родителем `SpyComponent`.

    </td>
  </tr>
  <tr style='vertical-align:top'>
    <td>
      <a href="#onchanges">OnChanges </a>
    </td>
    <td>

      Посмотрите, как Angular называет `ngOnChanges()` перехватывает с `changes` объект
      каждый раз, когда изменяется одно из входных свойств компонента.
      Показывает, как интерпретировать `changes` объект.

    </td>
  </tr>
  <tr style='vertical-align:top'>
    <td>
      <a href="#docheck">DoCheck </a>
    </td>
    <td>

      Реализует `ngDoCheck()` с пользовательским обнаружением изменений.
      Посмотрите, как часто Angular вызывает этот хук, и смотрите, как он публикует изменения в журнале.

    </td>
  </tr>
  <tr style='vertical-align:top'>
    <td>
      <a href="#afterview">AfterView </a>
    </td>
    <td>

      Показывает, что Angular подразумевает под *видом*.
      Демонстрирует `ngAfterViewInit` и `ngAfterViewChecked` хуки.

    </td>
  </tr>
  <tr style='vertical-align:top'>
    <td>
      <a href="#aftercontent">AfterContent </a>
    </td>
    <td>

      Показывает, как проецировать внешний контент в компонент и
      как отличить спроецированный контент от дочернего представления компонента.
      Демонстрирует `ngAfterContentInit` и `ngAfterContentChecked` перехватывает.

    </td>
  </tr>
  <tr style='vertical-align:top'>
    <td>
      Счетчик
    </td>
    <td>

      Демонстрирует комбинацию компонента и директивы
      у каждого свои хуки.

      В этом примере `CounterComponent` регистрирует изменения (через `ngOnChanges`)
      каждый раз, когда родительский компонент увеличивает свое свойство счетчика ввода.
      Между тем, `SpyDirective` из предыдущего примера применяется
      к `CounterComponent` где он наблюдает за созданием и уничтожением записей журнала.

    </td>
  </tr>
</table>

В оставшейся части этой страницы обсуждаются отдельные упражнения более подробно.

{@a peek-a-boo}

{@a peek-a-boo-all-hooks}
## Пикабу: все хуки

 `PeekABooComponent` демонстрирует все хуки в одном компоненте.

Вы редко, если вообще когда-либо, реализуете все интерфейсы, подобные этому.
Подглядывание существует, чтобы показать, как Angular вызывает хуки в ожидаемом порядке.

Этот снимок отражает состояние журнала после того, как пользователь нажал « *Создать»* кнопку, а затем кнопку « *Удалить»*.

<div class="lightbox">
  <img src="generated/images/guide/lifecycle-hooks/peek-a-boo.png" alt="Peek-a-boo">
</div>

Последовательность сообщений журнала следует предписанному хук порядок вызова:
 `OnChanges `, ` OnInit `, ` DoCheck`  (3x), `AfterContentInit`, `AfterContentChecked`  (3x)
 `AfterViewInit `, ` AfterViewChecked`  (3x) и `OnDestroy`.

<div class="alert is-helpful">

  Конструктор не является Angular крючком *как таковым*.
  Журнал подтверждает, что входные свойства ( `name` свойства в данном случае) не имеет назначенных значений при построении.

</div>

Если бы пользователь нажал « *Обновить героя»* кнопку, журнал показал бы `OnChanges` и еще две тройки
 `DoCheck `, ` AfterContentChecked ` и ` AfterViewChecked`.
Очевидно, что эти три крючка стреляют *часто*. Сохраняйте логику в этих крючках настолько постной, насколько это возможно!

Следующие примеры сосредоточены на деталях крючка.


{@a spy}

{@a spying-*oninit*-and-*ondestroy*}
## Шпионаж *OnInit* и *OnDestroy*

Пройдите под прикрытием с этими двумя шпионскими крюками, чтобы узнать, когда элемент инициализирован или уничтожен.

Это идеальная инфильтрационная работа для директивы.
Герои никогда не узнают, что за ними следят.

<div class="alert is-helpful">

  Шучу в сторону, обратите внимание на два ключевых момента:

  1. Angular вызывает методы перехвата как для *директив,* так и для компонентов. <br><br>

  2. Директива шпиона может дать представление об объекте DOM, который вы не можете изменить напрямую.
  Очевидно, что вы не можете коснуться реализации нативной `<div>`.
  Вы также не можете изменить сторонний компонент.
  Но вы можете смотреть как с директивой.

</div>

Подлая шпионская директива проста, состоящая почти целиком из `ngOnInit()` и `ngOnDestroy()` перехватывает
которые регистрируют сообщения для родителя через введенные `LoggerService`.

<code-example path="lifecycle-hooks/src/app/spy.directive.ts" region="spy-directive" header="src/app/spy.directive.ts"></code-example>

Вы можете применить шпиона к любому нативному или компонентному элементу, и он будет инициализирован и уничтожен
в то же время, что и этот элемент.
Вот это прилагается к многократному герою `<div>` :

<code-example path="lifecycle-hooks/src/app/spy.component.html" region="template" header="src/app/spy.component.html"></code-example>

Рождение и смерть каждого шпиона знаменует собой рождение и смерть прикрепленного героя `<div>` 
с записью в *Hook Вход ,* как показано здесь:

<div class="lightbox">
  <img src='generated/images/guide/lifecycle-hooks/spy-directive.gif' alt="Spy Directive">
</div>

Добавление героя приводит к появлению нового героя `<div>` . Шпион `ngOnInit()` регистрирует это событие.

Кнопка *сброса* очищает `heroes` список.
Angular удаляет всех героев `<div>` элементы из DOM и уничтожает их шпионские директивы одновременно.
Шпион `ngOnDestroy()` сообщает о последних моментах.

 `ngOnInit() ` и ` ngOnDestroy()` играют более важную роль в реальных приложениях.

{@a oninit}

{@a oninit}
### _OnInit () _

использование `ngOnInit()` по двум основным причинам:

1. Выполнить сложные инициализации вскоре после строительства.
1. Чтобы настроить компонент после Angular, задайте входные свойства.

Опытные разработчики согласны с тем, что компоненты должны быть дешевыми и безопасными в изготовлении.

<div class="alert is-helpful">

  Мисько Hevery, Angular команда свинец
  [объясняет почему](http://misko.hevery.com/code-reviewers-guide/flaw-constructor-does-real-work/)
  Вы должны избегать сложной логики конструктора.

</div>

Не выбирайте данные в конструкторе компонента.
Вы не должны беспокоиться, что новый компонент будет пытаться связаться с удаленным сервером, когда
создан в тестовом режиме или до того, как вы решите показать его
Конструкторы должны делать не более, чем устанавливать начальные локальные переменные в простые значения.

 `ngOnInit()` - хорошее место для компонента, чтобы получить его начальные данные.
[Tour of Heroes Tutorial](tutorial/toh-pt4#oninit)руководство показывает, как.


Помните также, что связанные с данными входные свойства директивы не устанавливаются до _after construction_.
Это проблема, если вам нужно инициализировать директиву на основе этих свойств.
Они будут установлены, когда `ngOnInit()` запускается.

<div class="alert is-helpful">

 `ngOnChanges()` - это ваша первая возможность доступа к этим свойствам.
  Angular звонки `ngOnChanges()` перед `ngOnInit()` и много раз после этого.
  Это только звонки `ngOnInit()` один раз.

</div>

Вы можете рассчитывать на Angular, чтобы позвонить `ngOnInit()` _soon_ после создания компонента.
Вот к чему относится тяжелая логика инициализации.

{@a ondestroy}

{@a ondestroy}
### _OnDestroy () _

Поместите логику очистки в `ngOnDestroy()`, логика, которая *должна* выполняться до того, как Angular уничтожит директиву.

Это время, чтобы уведомить другую часть приложения о том, что компонент исчезает.

Это место для бесплатных ресурсов, которые не будут собираться автоматически.
Отписаться от Observables и DOM событий. Таймеры интервалов остановки.
Отмените регистрацию всех обратных вызовов, которые эта директива зарегистрировала в глобальных службах или службах приложений.
Вы рискуете утечкой памяти, если пренебрегаете этим.

{@a onchanges}

{@a onchanges}
## _OnChanges () _

Angular называет его `ngOnChanges()` всякий раз, когда он обнаруживает изменения во ***входных свойствах*** компонента (или директивы).
Этот пример отслеживает `OnChanges` хук.

<code-example path="lifecycle-hooks/src/app/on-changes.component.ts" region="ng-on-changes" header="on-changes.component.ts (excerpt)"></code-example>

 `ngOnChanges()` принимает объект, который отображает каждое измененное имя свойства в
[SimpleChange](api/core/SimpleChange)объект, содержащий текущие и предыдущие значения свойств.
Этот хук перебирает измененные свойства и регистрирует их.

Пример компонента, `OnChangesComponent`, имеет два входных свойства: `hero` и `power`.

<code-example path="lifecycle-hooks/src/app/on-changes.component.ts" region="inputs" header="src/app/on-changes.component.ts"></code-example>

Гостья `OnChangesParentComponent` связывается с ними, как это:

<code-example path="lifecycle-hooks/src/app/on-changes-parent.component.html" region="on-changes" header="src/app/on-changes-parent.component.html"></code-example>

Вот пример в действии, когда пользователь вносит изменения.

<div class="lightbox">
  <img src='generated/images/guide/lifecycle-hooks/on-changes-anim.gif' alt="OnChanges">
</div>

Записи журнала появляются при изменении строкового значения *power* свойства.
Но `ngOnChanges` не ловит изменения в `hero.name` 
Сначала это удивительно.

Angular вызывает ловушку только при изменении значения свойства input.
Значение `hero` Свойство является *ссылкой на объект героя*.
Angular не волнует, что герой собственный `name` свойства изменено.
объект героя *Ссылка на* не изменилась, поэтому, с точки зрения Angular, в отчете нет никаких изменений!

{@a docheck}

{@a docheck}
## _DoCheck () _

Использовать `DoCheck` для обнаружения и реагирования на изменения, которые Angular не улавливает самостоятельно.

<div class="alert is-helpful">

  Используйте этот метод, чтобы обнаружить изменение, которое Angular пропустил.

</div>

*DoCheck* образец расширяет *OnChanges* образец с нижеследующим `ngDoCheck()` хук:

<code-example path="lifecycle-hooks/src/app/do-check.component.ts" region="ng-do-check" header="DoCheckComponent (ngDoCheck)"></code-example>

Этот код проверяет определенные значения _inquial_, фиксируя и сравнивая их текущее состояние с предыдущими значениями.
Он записывает специальное сообщение в журнал, когда нет существенных изменений в `hero` или `power` 
так что вы можете видеть, как часто `DoCheck` называется. Результаты освещения:

<div class="lightbox">
  <img src='generated/images/guide/lifecycle-hooks/do-check-anim.gif' alt="DoCheck">
</div>

В то время как `ngDoCheck()` может определить, когда герой `name` изменилось, оно имеет ужасную стоимость.
Этот хук вызывается с огромной частотой - после _every_
изменение цикла обнаружения независимо от того, где произошло изменение.
В этом примере он вызывается более двадцати раз, прежде чем пользователь сможет что-либо сделать.

Большинство из этих первоначальных проверок вызваны первым рендерингом Angular *несвязанных данных в другом месте на странице*.
Простое прикосновение к другому `<input>` инициирует вызов.
Относительно небольшое количество вызовов показывает фактические изменения соответствующих данных.
Ясно, что наша реализация должна быть очень легкой, или пользовательский опыт страдает.

{@a afterview}

{@a afterview}
## AfterView

В *AfterView* образец исследует `AfterViewInit()` и `AfterViewChecked()` перехватывает вызовы Angular
*после как* того, он создает дочерние представления компонента.

Вот дочерний вид, который отображает имя героя в `<input>` :

<code-example path="lifecycle-hooks/src/app/after-view.component.ts" region="child-view" header="ChildComponent"></code-example>

 `AfterViewComponent` отображает этот вид ребенка в *пределах его шаблона*:

<code-example path="lifecycle-hooks/src/app/after-view.component.ts" region="template" header="AfterViewComponent (template)"></code-example>

Следующие хуки принимать меры, основываясь на изменение значений *в поле зрения ребенка*,
что может быть достигнуто только путем запроса на детское представление через собственность, украшенную
[@ViewChild](api/core/ViewChild).


<code-example path="lifecycle-hooks/src/app/after-view.component.ts" region="hooks" header="AfterViewComponent (class excerpts)"></code-example>

{@a wait-a-tick}

{@a abide-by-the-unidirectional-data-flow-rule}
### Соблюдайте правило однонаправленного потока данных
 `doSomething()` обновляет экран, когда имя героя превышает 10 символов.

<code-example path="lifecycle-hooks/src/app/after-view.component.ts" region="do-something" header="AfterViewComponent (doSomething)"></code-example>

Почему `doSomething()` ожидает обновления перед обновлением `comment` ?

Правило однонаправленного потока данных Angular запрещает обновление представления *после* его составления.
Обе эти ловушки запускают _after_ вид компонента, который был составлен.

Angular выдает ошибку, если ловушка обновляет привязку данных компонента `comment` собственности немедленно (попробуйте!).
 `LoggerService.tick_then()` откладывает обновление журнала
на один оборот цикла JavaScript браузера, и это просто достаточно долго.

Вот *AfterView* в действии:

<div class="lightbox">
  <img src='generated/images/guide/lifecycle-hooks/after-view-anim.gif' alt="AfterView">
</div>

Обратите внимание, что Angular часто звонит `AfterViewChecked()`, часто, когда нет никаких изменений интереса.
Напишите методы экономного подключения, чтобы избежать проблем с производительностью.

{@a aftercontent}

{@a aftercontent}
## AfterContent

*AfterContent* Образец исследует `AfterContentInit()` и `AfterContentChecked()` перехватывает вызовы Angular
*после* Angular проецирует внешний компонент в компонент.

{@a content-projection}

{@a content-projection}
### Содержание проекции

*Проекция контента* - это способ импортировать контент HTML извне компонента и вставлять этот контент
в шаблон компонента в назначенном месте.

<div class="alert is-helpful">

  Разработчики AngularJS знают эту технику как *включение*.

</div>

Рассмотрим этот вариант на [предыдущий _AfterView_](guide/lifecycle-hooks#afterview)примере.
На этот раз вместо включения дочернего представления в шаблон он импортирует содержимое из
 `AfterContentComponent` . Вот шаблон родителя:

<code-example path="lifecycle-hooks/src/app/after-content.component.ts" region="parent-template" header="AfterContentParentComponent (template excerpt)"></code-example>

Обратите внимание, что `<app-child>` Тег находится между `<after-content>` теги.
Никогда не помещайте контент между тегами элемента компонента, *если вы не собираетесь проецировать этот контент
в компонент *.

Теперь посмотрим на шаблон компонента:

<code-example path="lifecycle-hooks/src/app/after-content.component.ts" region="template" header="AfterContentComponent (template)"></code-example>

 `<ng-content>` Тег является *заполнителем* для внешнего контента.
Он сообщает Angular, куда вставить этот контент.
В этом случае прогнозируемый контент является `<app-child>` от родителя.

<div class="lightbox">
  <img src='generated/images/guide/lifecycle-hooks/projected-child-view.png' alt="Projected Content">
</div>

<div class="alert is-helpful">

  В явных признаках *проекции контента* являются двойными:

  * HTML между тегами компонентных элементов.
  * Наличие `<ng-content>` Теги в шаблоне компонента.

</div>

{@a aftercontent-hooks}

### AfterContent хуки

*Хуки AfterContent* аналогичны *хукам AfterView*.
Основное различие заключается в дочернем компоненте.

* В*AfterView * Хуки относятся `ViewChildren`, дочерние компоненты, чьи элементы теги
появляются *в* шаблоне компонента.

* В*AfterContent * Хуки относятся `ContentChildren`, дочерние компоненты, которые Angular
проецируется в компонент.

Следующее *AfterContent* крюков принять меры, основываясь на изменение значений в *ребенке контента*,
который может быть достигнут только путем запроса их через собственность, украшенную
[@ContentChild](api/core/ContentChild).

<code-example path="lifecycle-hooks/src/app/after-content.component.ts" region="hooks" header="AfterContentComponent (class excerpts)"></code-example>

{@a no-unidirectional-flow-worries}

{@a no-unidirectional-flow-worries-with-aftercontent}
### Никакого однонаправленного потока не беспокоит _AfterContent_

Этот компонент `doSomething()` метода привязано к данным компонента `comment` собственности немедленно.
Там нет [нужно подождать](guide/lifecycle-hooks#wait-a-tick).

Напомним, что Angular вызывает обе *ловушки AfterContent* перед вызовом любой из *ловушек AfterView*.
Angular завершает композицию проецируемого содержимого *перед* завершением композиции представления этого компонента.
Есть небольшое окно между `AfterContent...` и `AfterView...` перехватывает, чтобы изменить представление хоста.
