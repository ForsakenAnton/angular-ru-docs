{@a service-worker-in-production}
# Сервисный работник на производстве

Эта страница является справочной для развертывания и поддержки производственных приложений, в которых используется работник службы Angular. В нем объясняется, как работник службы Angular вписывается в большую производственную среду, поведение работника службы в различных условиях, доступные ресурсы и отказоустойчивость.

{@a prerequisites}
#### Предпосылки

Основное понимание следующего:
* [Сервисный работник связи](guide/service-worker-communications).

<hr />

{@a service-worker-and-caching-of-app-resources}
## Сервисный работник и кеширование ресурсов приложения

Концептуально вы можете представить работника службы Angular в качестве прямого кэша или ребра CDN, установленного в веб-браузере конечного пользователя. Работа сервисного работника состоит в том, чтобы удовлетворять запросы, сделанные приложением Angular на ресурсы или данные из локального кэша, без необходимости ожидания сети. Как и в любом кеше, в нем есть правила того, как контент истекает и обновляется.

{@a versions}

{@a app-versions}
### Версии приложения

В контексте работника службы Angular «версия» - это набор ресурсов, представляющих конкретную сборку приложения Angular. Каждый раз, когда развертывается новая сборка приложения, работник службы рассматривает эту сборку как новую версию приложения. Это верно, даже если обновляется только один файл. В любой момент времени работник сервиса может иметь несколько версий приложения в своем кэше, и он может обслуживать их одновременно. Для получения дополнительной информации см. [вкладки приложения](guide/service-worker-devops#tabs)Раздел ниже.

Чтобы сохранить целостность приложения, работник службы Angular группирует все файлы в одну версию. Файлы, сгруппированные в версию, обычно включают файлы HTML, JS и CSS. Группировка этих файлов важна для целостности, поскольку файлы HTML, JS и CSS часто ссылаются друг на друга и зависят от конкретного содержимого. Например, `index.html` Файл может иметь `<script>` тег который ссылается `bundle.js` и он может попытаться вызвать функцию `startApp()` из этого скрипта. В любое время эта версия `index.html` обслуживается, соответствующий `bundle.js` должен быть подан с этим. Например, предположим, что `startApp()` переименована в `runApp()` в обоих файлах. В этом случае недопустимо служить старым `index.html`, который вызывает `startApp()` вместе с новым пакетом, который определяет `runApp()`.

Эта целостность файла особенно важна при ленивой загрузке модулей.
Пакет JS может ссылаться на множество ленивых кусков и имен файлов
Ленивые куски уникальны для конкретной сборки приложения. Если работает
приложение в версии `X` пытается загрузить ленивый кусок, но сервер имеет
обновлено до версии `X + 1`, операция отложенной загрузки завершится неудачно.

Идентификатор версии приложения определяется содержанием всего
ресурсы, и он меняется, если любой из них меняется. На практике версия
определяется содержанием `ngsw.json` Файл, который включает в себя
хеши для всего известного контента. Если какой-либо из кэшированных файлов изменяется, файл
хэш изменится в `ngsw.json`, в результате чего Angular работник службы в
рассматривать активный набор файлов как новую версию.

С поведением версий служащего Angular, приложения
Сервер может гарантировать, что приложение Angular всегда имеет согласованный набор файлов.

{@a update-checks}
#### Обновите чеки

Каждый раз, когда пользователь открывает или обновляет приложение, работник службы Angular
проверяет наличие обновлений для приложения, просматривая обновления `ngsw.json` . Если
обновление найдено, оно загружается и кэшируется автоматически и будет обслуживаться
в следующий раз приложение загружается.

{@a resource-integrity}
### Целостность ресурса

Одним из возможных побочных эффектов длительного кэширования является непреднамеренное
кэширование неверного ресурса. В обычном HTTP-кеше жесткое обновление
или срок действия кэша ограничивает негативные последствия кэширования недействительным
файл. Работник службы игнорирует такие ограничения и эффективно долго
кэширует все приложение. Следовательно, очень важно, чтобы работник службы
получает правильное содержание.

Для обеспечения целостности ресурса работник службы Angular проверяет
хэши всех ресурсов, для которых он имеет хеш. Как правило, для
приложение, созданное с помощью [Angular CLI](cli), это все в `dist` каталог покрыт
пользователь `src/ngsw-config.json`.

Если конкретный файл не проходит проверку, работник службы Angular
пытается повторно извлечь содержимое, используя URL-адрес для очистки кэша
параметр для устранения эффектов браузера или промежуточного
кэширование. Если этот контент также не проходит проверку, работник службы
считает всю версию приложения недействительной и останавливается
обслуживая приложение. При необходимости сервисный работник переходит в безопасный режим
где запросы возвращаются в сеть, решив не использовать свой кэш
если велик риск предоставления недействительного, сломанного или устаревшего контента.

Хэш несовпадение может возникать по разным причинам:

* Кэширующие слои между исходным сервером и конечным пользователем могут обслуживать устаревший контент.
* Неатомарное развертывание может привести к тому, что работнику службы Angular будет виден частично обновленный контент.
* Ошибки в процессе сборки могут привести к обновлению ресурсов без `ngsw.json` обновляется. Может произойти и обратное, что приведет к обновлению `ngsw.json` без обновленных ресурсов.

{@a unhashed-content}
#### Неназванный контент

Единственные ресурсы, которые имеют хеши в `ngsw.json` 
проявляются ресурсы, которые присутствовали в `dist` 
каталог на момент создания манифеста. Другое
ресурсы, особенно загруженные из CDN
контент, который неизвестен во время сборки или обновляется
чаще, чем приложение развернуто.

Если у работника службы Angular нет хеша для проверки
данный ресурс, он все еще кеширует свое содержимое, но чтит
заголовки кеширования HTTP с использованием политики «устаревшего
повторного подтверждения». То есть, когда HTTP кэширует заголовки для кэшируемого
ресурс указывает, что ресурс истек, Angular
работник службы продолжает обслуживать контент и пытается
обновить ресурс в фоновом режиме. Этот путь сломан
нехэшированные ресурсы не остаются в кеше за их пределами
настроенные времена жизни.

{@a tabs}

{@a app-tabs}
### Вкладки приложений

Это может быть проблематично для приложения, если версия ресурсов
он получает изменения внезапно или без предупреждения. Смотрите
[Версии](guide/service-worker-devops#versions)раздел выше
для описания таких вопросов.

Работник службы Angular предоставляет гарантию: работающее приложение
продолжит запуск той же версии приложения. Если другое
Экземпляр приложения открывается в новой вкладке веб-браузера, затем
самая последняя версия приложения обслуживается. В результате
на этой новой вкладке может быть запущена другая версия приложения
чем оригинальная вкладка.

Важно отметить, что эта гарантия **сильнее**
чем это предусмотрено обычной моделью веб-развертывания. Без
сервисный работник, нет гарантии, что код лениво загружен
позже запущенное приложение имеет ту же версию, что и начальная версия
код для приложения.

Есть несколько ограниченных причин, почему служащий Angular
может изменить версию работающего приложения. Некоторые из них есть
ошибка условия:

* Текущая версия становится недействительной из-за сбоя хэша.
* Несвязанная ошибка приводит к тому, что работник сервиса переходит в безопасный режим; то есть временная деактивация.

Работник службы Angular знает, в каких версиях
использовать в любой момент, и это очищает версии, когда
никакая вкладка не использует их.

Другие причины, по которым работник службы Angular может изменить версию
бегущего приложения нормальные события:

* Страница перезагружается / обновляется.
* Страница запрашивает, чтобы обновление было немедленно активировано через `SwUpdate`.

{@a service-worker-updates}
### Сервисный работник обновлений

Сервисный работник Angular - это небольшой скрипт, который запускается в веб-браузерах.
Время от времени сервисный работник будет обновляться с ошибкой
исправления и улучшения функций.

Сервисный работник Angular загружается при первом запуске приложения
и когда к приложению обращаются после периода бездействия. Если
Сервисный работник изменился, сервисный работник будет обновлен в фоновом режиме.

Большинство обновлений работника службы Angular прозрачны для
приложение - старые кэши все еще действительны, а контент все еще обслуживается
обычно. Тем не менее, иногда исправление или функция в Angular
Сервисный работник требует аннулирования старых кешей. В этом случае
приложение будет обновлено прозрачно из сети.

{@a bypassing-the-service-worker}
### В обход сервисного работника

В некоторых случаях вы можете полностью обойти сервисного работника и позволить браузеру обрабатывать
запрос вместо Например, вы полагаетесь на функцию, которая в данный момент не поддерживается в сервисе
работники (например
[отчетность о проделанной работе по загруженным файлам](https://github.com/w3c/ServiceWorker/issues/1141)).

Чтобы обойти сервисного работника вы можете установить `ngsw-bypass` в качестве заголовка запроса или в качестве параметра запроса.
(Значение заголовка или параметра запроса игнорируется и может быть пустым или опущено.)

{@a debugging-the-angular-service-worker}
## Отладка сервисного работника Angular

Изредка может возникнуть необходимость изучить Angular службу
работник в рабочем состоянии, чтобы расследовать проблемы или обеспечить это
он работает как задумано. Браузеры предоставляют встроенные инструменты для
отладка сервисных работников и самого сервисного работника Angular
включает в себя полезные функции отладки.

{@a locating-and-analyzing-debugging-information}
### Нахождение и анализ отладочной информации

Работник службы Angular предоставляет информацию об отладке в разделе
 `ngsw/` виртуальный каталог . В настоящее время единственный открытый URL
является `ngsw/state` . Вот пример содержимого отладочный + страницы:

```
NGSW Debug Info:

Driver state: NORMAL ((nominal))
Latest manifest hash: eea7f5f464f90789b621170af5a569d6be077e5c
Last update check: never

=== Version eea7f5f464f90789b621170af5a569d6be077e5c ===

Clients: 7b79a015-69af-4d3d-9ae6-95ba90c79486, 5bc08295-aaf2-42f3-a4cc-9e4ef9100f65

=== Idle Task Queue ===
Last update tick: 1s496u
Last update run: never
Task queue:
 * init post-load (update, cleanup)

Debug log:
```

{@a driver-state}
#### Состояние водителя

Первая строка указывает на состояние водителя:

```
Driver state: NORMAL ((nominal))
```

 `NORMAL` указывает, что работник службы работает нормально и не находится в ухудшенном состоянии.

Есть два возможных деградированные состояния:

* `EXISTING_CLIENTS_ONLY` : работник службы не имеет
чистая копия последней известной версии приложения. Старше кешируется
версии безопасны в использовании, поэтому существующие вкладки продолжают работать с
кеш, но новые загрузки приложения будут обслуживаться из сети.
Сервисный работник попытается выйти из этого состояния при появлении нового
версия приложения обнаружена и установлена (то есть
когда новый `ngsw.json` доступен).

* `SAFE_MODE` : сервисный работник не может гарантировать безопасность
используя кэшированные данные. Либо произошла непредвиденная ошибка, либо все
кэшированные версии недействительны. Весь трафик будет обслуживаться с
сеть, выполняющая как можно меньше кода рабочего сервиса.

В обоих случаях аннотация в скобках обеспечивает
ошибка, из-за которой работник сервиса перешел в ухудшенное состояние.

Оба состояния являются временными; они сохраняются только на время существования [ServiceWorker. экземпляр](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope).
Браузер иногда завершает работу бездействующего сервисного работника, чтобы сохранить память и
процессор и создает новый экземпляр работника службы в ответ на
сетевые события. Новый экземпляр начинается в `NORMAL` режим, независимо от
состояние предыдущего экземпляра.

{@a latest-manifest-hash}
#### Последний манифест

```
Latest manifest hash: eea7f5f464f90789b621170af5a569d6be077e5c
```

Это хэш SHA1 самой последней версии приложения, о которой знает служащий.


{@a last-update-check}
#### Проверка последнего обновления

```
Last update check: never
```

Это указывает, когда в последний раз работник службы проверял наличие новой версии или обновления приложения. `never` указывает на то, что работник сервиса никогда не проверял наличие обновлений.

В этом примере файла отладки проверка обновления в настоящее время запланирована, как объяснено в следующем разделе.

{@a version}
#### Версия

```
=== Version eea7f5f464f90789b621170af5a569d6be077e5c ===

Clients: 7b79a015-69af-4d3d-9ae6-95ba90c79486, 5bc08295-aaf2-42f3-a4cc-9e4ef9100f65
```

В этом примере у сервисного работника есть одна версия приложения в кеше и
используется для обслуживания двух разных вкладок. Обратите внимание, что эта версия хэш
это "последний манифест манифеста", указанный выше. Оба клиента находятся на
Последняя версия. Каждый клиент указан по его идентификатору из `Clients` 
API в браузере.


{@a idle-task-queue}
#### Бесполезная очередь задач

```
=== Idle Task Queue ===
Last update tick: 1s496u
Last update run: never
Task queue:
 * init post-load (update, cleanup)
```

Idle Task Queue - это очередь всех ожидающих выполнения задач
на заднем плане у работника службы. Если есть какие-либо задачи
в очереди они перечислены с описанием. В этом примере
у работника сервиса запланирована одна такая задача - постинициализация
операция, включающая проверку обновлений и очистку устаревших кэшей.

Счетчики тактов / запусков последнего обновления показывают время с определенного момента
события произошли, связанные с незанятой очереди. «Последний запуск обновления»
Счетчик показывает, когда в последний раз неиспользуемые задачи действительно выполнялись.
«Последнее обновление» показывает время после последнего события после
который очередь может быть обработан.


{@a debug-log}
#### Журнал отладки

```
Debug log:
```

Ошибки, возникающие внутри сервисного работника, будут регистрироваться здесь.


{@a developer-tools}
### Инструменты разработчика

Браузеры, такие как Chrome, предоставляют разработчикам инструменты для взаимодействия
с обслуживающими работниками. Такие инструменты могут быть мощными при правильном использовании
но есть несколько вещей, которые нужно иметь в виду.

* При использовании инструментов разработчика рабочий сервис продолжает работать
в фоновом режиме и никогда не перезагружается. Это может вызвать поведение с Dev
Инструменты открыты, чтобы отличаться от поведения пользователя.

* Если вы посмотрите в средстве просмотра Cache Storage, кэш часто
устаревший. Щелкните правой кнопкой мыши заголовок Cache Storage и обновите кэши.

Остановка и запуск сервисного работника в Сервисном работнике
Панель запускает проверку обновлений.

{@a service-worker-safety}
## Служба безопасности работников

Как и в любой сложной системе, могут возникнуть ошибки или неправильные конфигурации
Angular работник службы действовать непредвиденным образом. Пока свое
дизайн пытается свести к минимуму влияние таких проблем
Сервисный работник Angular содержит несколько отказоустойчивых механизмов на всякий случай
администратору всегда нужно быстро деактивировать работника службы.

{@a fail-safe}
### Отказоустойчивый

Чтобы деактивировать работника службы, удалите или переименуйте
 `ngsw.json` файл . Когда запрос работника службы
для `ngsw.json` возвращает `404`, затем работник службы
удаляет все свои кэши и снимает с себя регистрацию
по сути самоуничтожение.

{@a safety-worker}
### Рабочий безопасности

Также включены в `@angular/service-worker` Пакет NPM небольшой
скрипт `safety-worker.js`, который при загрузке регистрацию
из браузера. Этот скрипт можно использовать как последнее средство избавления
нежелательных сервисных работников, уже установленных на клиентских страницах.

Важно отметить, что вы не можете зарегистрировать этого работника напрямую
поскольку старые клиенты с кэшированным состоянием могут не видеть нового `index.html` который
устанавливает другой рабочий скрипт. Вместо этого вы должны служить
содержание `safety-worker.js` по URL-адресу сценария Service Worker
Вы пытаетесь отменить регистрацию и должны продолжать делать это, пока не сделаете это
наверняка все пользователи успешно отменили регистрацию старого работника. Для
На большинстве сайтов это означает, что вы должны обслуживать сотрудника службы безопасности в
URL старого сервисного работника навсегда.

Этот сценарий может быть использован как для отключения `@angular/service-worker` 
а также любые другие работники службы, которые могли быть обслужены в
прошлое на вашем сайте.

{@a changing-your-apps-location}
### Изменение местоположения вашего приложения

Важно отметить, что сервис воркеры не работают за редиректом. Вы
возможно, уже столкнулся с ошибкой `The script resource is behind a redirect, which is disallowed`.

Это может быть проблемой, если вам нужно изменить местоположение вашего приложения. Если вы настроили
перенаправление со старого места (например, `example.com`) к новому
местоположение (например `www.example.com`) работник перестанет работать.
Кроме того, перенаправление даже не сработает для пользователей, которые загружают сайт
полностью от работника сервиса. Старый работник (зарегистрирован на `example.com`)
пытается обновить и отправляет запросы на старое местоположение `example.com` который
быть перенаправлены на новое место `www.example.com` и создайте ошибку
 `The script resource is behind a redirect, which is disallowed`.

Чтобы исправить это, вам может понадобиться убить старого работника, используя один из вышеперечисленных
методы ( [Отказоустойчивость](#fail-safe)или [Безопасность работника](#safety-worker)).


{@a more-on-angular-service-workers}
## Больше о Angular service workers

Вы также можете быть заинтересованы в следующих ситуациях :
* [Конфигурация сервисного работника](guide/service-worker-config).

