{@a static-query-migration-guide}
# Статический запрос Руководство по миграции

**Важное примечание для авторов библиотеки. Эта миграция особенно важна для авторов библиотеки, чтобы облегчить пользователям обновление до версии 9, когда она станет доступной.**

В версии 9 настройка по умолчанию для  `@ViewChild`  и  `@ContentChild`  Запросы изменяются, чтобы исправить ошибочное и неожиданное поведение в запросах (подробнее об этом [здесь](#what-does-this-flag-mean)).

Готовясь к этому изменению, в версии 8 мы переносим все приложения и библиотеки, чтобы явно указать стратегию разрешения для  `@ViewChild`  и  `@ContentChild`  запросы.

В частности, эта миграция добавляет явный «статический» флаг, который указывает, когда должны быть назначены результаты этого запроса.
Добавление этого флага гарантирует, что ваш код работает так же, как при обновлении до версии 9

Перед тем как :

```
// query results sometimes available in  `ngOnInit`, sometimes in  `ngAfterViewInit`  (based on template)
@ViewChild('foo') foo: ElementRef;
```

После того, как :

```
// query results available in ngOnInit
@ViewChild('foo', {static: true}) foo: ElementRef;

OR

// query results available in ngAfterViewInit
@ViewChild('foo', {static: false}) foo: ElementRef;
```

Начиная с версии 9,  `static`  флаг по умолчанию будет ложным.
В то время любой `{static: false}` Флаги можно безопасно удалить, и у нас будет схема, которая обновит ваш код для вас.

Примечание: этот флаг применяется только к  `@ViewChild`  и  `@ContentChild`  запрашивает конкретно, как  `@ViewChildren`  и  `@ContentChildren`  Запросы не имеют понятия статического и динамического (они всегда разрешаются, как если бы они были «динамическими»).

{@a faq}
## FAQ

{@a what-to-do-with-todo}
{@a what-should-i-do-if-i-see-a-/*-todo-add-static-flag-*/-comment-printed-by-the-schematic}
### Что мне делать, если я вижу `/* TODO: add static flag*/` комментарий, напечатанный на схеме?

Если вы видите этот комментарий, это означает, что схема не может статически определить правильный флаг. В этом случае вам нужно будет добавить правильный флаг в зависимости от поведения вашего приложения.
Для получения дополнительной информации о том, как выбрать, см. [Следующий вопрос](#how-do-i-choose).

{@a how-do-i-choose}
{@a how-do-i-choose-which-static-flag-value-to-use-true-or-false}
### Как выбрать какой  `static`  значение флага для использования:  `true`  или  `false`  ?

В официальных документах API мы всегда рекомендовали извлекать результаты запросов в [  `ngAfterViewInit`   для запросов на просмотр](https://angular.io/api/core/ViewChild#description)и [ ` ngAfterContentInit`  для запросов на контент](https://angular.io/api/core/ContentChild#description).
Это связано с тем, что к моменту запуска этих хуков жизненного цикла обнаружение изменений для соответствующих узлов завершено, и мы можем гарантировать, что мы собрали все возможные результаты запроса.

Большинство приложений захотят использовать `{static: false}` по той же причине. Этот параметр гарантирует соответствие запросов, которые зависят от разрешения привязки (например, результаты внутри  `*ngIf`  s или  `*ngFor`  s) будет найден по запросу.

Есть более редкие случаи, когда `{static: true}` Флаг может быть необходим (см. [ответ здесь](#should-i-use-static-true)).

{@a should-i-use-static-true}
{@a is-there-a-case-where-i-should-use-{static-true}}
### Есть ли случай, когда я должен использовать `{static: true}` ?

Эта опция была введена для поддержки создания встроенных представлений на лету.
Если вам нужен доступ к  `TemplateRef`  в запросе для динамического создания представления, вы не сможете сделать это в  `ngAfterViewInit`.
Обнаружение изменений уже запущено в этом представлении, поэтому создание нового представления с шаблоном вызовет  `ExpressionHasChangedAfterChecked`  ошибка, которая будет выдана.
В этом случае вы захотите установить  `static`  флаг для  `true`  и создать свой взгляд в  `ngOnInit`.
В большинстве других случаев наилучшей практикой является использование `{static: false}`.

Однако, чтобы облегчить переход на версию 8, вы также можете установить  `static`  флаг для  `true`  если код компонента уже зависит от результатов запроса, доступных за некоторое время **до**  `ngAfterViewInit` (для запросов на просмотр) или  `ngAfterContentInit`  (для запросов контента).
Например, если ваш компонент опирается на результаты запроса, заполняемые в  `ngOnInit`  крючок или в  `@Input`, вам нужно будет либо установить флаг  `true`  или переработайте ваш компонент, чтобы приспособиться к более позднему времени.

Примечание. Выбор статического параметра означает, что результаты запроса вложены в  `*ngIf`  или  `*ngFor`  не будет найден по запросу.
Эти результаты можно получить только после запуска обнаружения изменений.

{@a what-does-this-flag-mean}
{@a what-does-this-flag-mean-and-why-is-it-necessary}
### Что означает этот флаг и почему он необходим?

Поведение по умолчанию для запросов исторически было недокументированным и запутанным, а также обычно приводило к проблемам, которые трудно отладить.
В версии 9 мы хотели бы сделать поведение запросов более последовательным и простым для понимания.

Чтобы объяснить, почему, во-первых, важно понять, как запросы работали до сих пор.

Без  `static`  флаг, компилятор решил, когда каждый запрос будет решаться в каждом конкретном случае.
Все  `@ViewChild`  /  `@ContentChild`  запросы были разделены на две группы: «статическая» или «динамическая».
Эта классификация определяется, когда результаты запроса станут доступны пользователям.

- **Статические запросы** были запросами, в которых результат мог быть определен статически, потому что результат не зависел от значений времени выполнения, таких как привязки.
Результаты запросов, классифицированных как статические, были доступны до запуска обнаружения изменений для этого представления (доступно в  `ngOnInit`).

- **Динамические запросы** были запросами, где результат НЕ мог быть определен статически, потому что результат зависел от значений времени выполнения (или привязок).
Результаты запросов, классифицированных как динамические, были недоступны до тех пор, пока не было выполнено обнаружение изменений для этого представления (доступно в  `ngAfterContentInit`  для запросов контента или  `ngAfterViewInit`  для просмотра запросов).

Например, допустим, у нас есть компонент,  `Comp`  . Внутри него, мы имеем этот запрос:

```
@ViewChild(Foo) foo: Foo;
```

и этот шаблон:

```
<div foo></div>
```

Эта  `Foo`  Запрос будет классифицирован как статический, потому что во время компиляции известно, что  `Foo`  экземпляр на  `<div>`  - правильный результат для запроса.
Поскольку результат запроса не зависит от значений времени выполнения, нам не нужно ждать, пока обнаружение изменений запустится в шаблоне, прежде чем разрешить запрос.
Следовательно, результаты могут быть доступны в  `ngOnInit`.

Скажем, запрос одно и то же, но компонент выглядит шаблон:

```
<div foo *ngIf="showing"></div>
```

С этим шаблоном запрос будет классифицирован как динамический запрос.
Нам нужно знать значение времени выполнения  `showing`  перед определением, какие правильные результаты для запроса.
В результате обнаружение изменений должно выполняться первым, а результаты могут быть доступны только в  `ngAfterViewInit`  или установщик для свойства запроса.

Результатом этой реализации является то, что добавление  `*ngIf`  или  `*ngFor`  любого места выше совпадение запроса может измениться, когда станут доступны результаты этого запроса.

Имейте в виду, что эти категории применяются только к  `@ViewChild`  и  `@ContentChild`  запрашивает конкретно.
 `@ViewChildren ` и ` @ContentChildren` Запросы не имели понятия статического и динамического, поэтому они всегда разрешались, как если бы они были «динамическими».

Эта стратегия разрешения запросов в разное время на основе местоположения потенциальных совпадений запросов вызывает много путаницы. А именно:

* Иногда результаты запроса доступны в  `ngOnInit`, но иногда это не так, и не понятно почему (см. [21800](https://github.com/angular/angular/issues/21800)или [19872](https://github.com/angular/angular/issues/19872)).

*  `@ViewChild` Запросы разрешаются в разное время  `@ViewChildren`  Запросы и  `@ContentChild`  Запросы разрешаются в разное время  `@ContentChildren`  запросы.
Если пользователь поворачивает  `@ViewChild`  запрос в  `@ViewChildren`  запрос, их код может внезапно сломаться, потому что время изменилось.

* Код, зависящий от результата запроса, может внезапно перестать работать, как только  `*ngIf`  или  `*ngFor`  добавлен в шаблон.

*  `@ContentChild` Запрос для одного и того же компонента будет разрешаться в разное время жизненного цикла для каждого использования компонента.
Это приводит к ошибочному поведению при использовании компонента с  `*ngIf`  разбит тонкими способами, которые не очевидны для автора компонента.

В версии 9 мы планируем упростить поведение, чтобы все запросы разрешались после запуска обнаружения изменений по умолчанию.
Расположение совпадений запросов в шаблоне не может повлиять на то, когда результат запроса станет доступным и внезапно нарушит ваш код, а поведение по умолчанию всегда одинаково.
Это делает логику более последовательной и предсказуемой для пользователей.

Тем не менее, если приложению нужны результаты запроса ранее (например, результат запроса необходим для создания встроенного представления), можно добавить `{static: true}` Флаг чтобы явно запрашивать статическое разрешение.
С помощью этого флага пользователи могут указать, что они заботятся только о статически доступных результатах, и результаты запроса будут заполнены до  `ngOnInit`.

{@a view-children-and-content-children}
{@a does-this-change-affect-@viewchildren-or-@contentchildren-queries}
### Влияет ли это изменение на  `@ViewChildren`  или  `@ContentChildren`  запросы?

Нет, это изменение влияет только  `@ViewChild`  и  `@ContentChild`  запрашивает конкретно.
 `@ViewChildren ` и ` @ContentChildren` Запросы по умолчанию уже являются «динамическими» и не поддерживают статическое разрешение.

{@a why-specify-static-false}
{@a ​why-do-i-have-to-specify-{static-false}-isnt-that-the-default}
### Почему я должен указать `{static: false}` ? Разве это не по умолчанию?

Цель этой миграции - преобразовать приложения, которые еще не в версии 9, в шаблон запроса, совместимый с версией 9
Однако большинство приложений используют библиотеки, и, вероятно, некоторые из этих библиотек еще не обновлены до версии 8 (и, следовательно, могут не иметь надлежащих флагов).
Поскольку версия приложения Angular будет использоваться для компиляции, если мы изменим значение по умолчанию, поведение запросов в компонентах библиотеки изменится на версию 8 по умолчанию и, возможно, прекратится.
Таким образом, зависимости приложения будут вести себя так же, как и в предыдущей версии.

В версии Angular 9 и более поздних будет безопасно удалить любую `{static: false}` помечает, и мы сделаем эту очистку для вас в схеме.

{@a libraries}
{@a can-i-keep-on-using-angular-libraries-that-havent-yet-updated-to-version-8-yet}
###  Могу ли я продолжать использовать библиотеки Angular, которые еще не обновлены до версии 8?

Да, конечно!
Поскольку мы не изменили поведение запроса по умолчанию в версии 8 (т. Е. Компилятор по-прежнему выбирает время, если не установлен флаг), когда ваше приложение запускается с библиотекой, которая не обновлена ​​до версии 8, библиотека будет работать так же, как она сделал в версии 7
Это гарантирует, что ваше приложение будет работать в версии 8, даже если библиотекам потребуется больше времени для обновления своего кода.

{@a update-library-to-use-static-flag}
{@a can-i-update-my-library-to-version-8-by-adding-the-static-flag-to-view-queries-while-still-being-compatible-with-angular-version-7-apps}
###  Могу ли я обновить свою библиотеку до версии 8, добавив  `static`  флаг для просмотра запросов и совместимость с приложениями Angular версии 7?

Да, команда Angular рекомендует для библиотек обновить версию 8 и добавить  `static`  флаг. Приложения Angular версии 7 будут продолжать работать с библиотеками, имеющими этот флаг.

Однако, если вы обновите свою библиотеку до Angular версии 8 и захотите воспользоваться новыми API-интерфейсами версии 8 или захотите использовать более новые зависимости (такие как Typescript или RxJS), ваша библиотека станет несовместимой с приложениями Angular версии 7. Если ваша цель - сделать вашу библиотеку совместимой с Angular версий 7 и 8, вам вообще не следует обновлять вашу библиотеку - кроме  `peerDependencies`  in  `package.json`.

В целом, наиболее эффективный план состоит в том, чтобы библиотеки приняли 6-месячный график основной версии и повышали основную версию после каждого обновления Angular. Таким образом, библиотеки остаются в том же ритме выпуска, что и Angular.
