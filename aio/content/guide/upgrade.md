{@a upgrading-from-angularjs-to-angular}
# Обновление с AngularJS до Angular

_Angular_ это имя для Angular сегодня и завтра. <br />
_AngularJS_ - имя для всех 1.x версий Angular.

Приложения AngularJS великолепны.
Всегда рассматривайте экономическое обоснование перед переходом на Angular.
Важной частью этого дела является время и усилия, чтобы добраться туда.
В этом руководстве описаны встроенные инструменты для эффективной миграции проектов AngularJS в
Angular платформа, штука за раз.

Некоторые приложения будет легче обновить, чем другие, и есть
много способов сделать это проще для себя. Это возможно
подготовить и согласовать приложения AngularJS с Angular еще до начала
процесс обновления. Эти подготовительные шаги все о создании кода
более разъединенный, более ремонтопригодный и лучше согласованный с современным развитием
инструменты. Это означает, что в дополнение к упрощению обновления
Вы также улучшите существующие приложения AngularJS.

Один из ключей к успешному обновлению - делать это постепенно
запустив две платформы бок о бок в одном приложении, и
портирование компонентов AngularJS на Angular один за другим. Это делает возможным
обновить даже большие и сложные приложения, не мешая другим
бизнес, потому что работа может выполняться совместно и распространяться
Период времени.  `upgrade` Модуль в Angular был разработан для
сделать постепенное обновление без шва.

{@a preparation}
## Подготовка

Есть много способов структурировать приложения AngularJS. Когда ты начнешь
чтобы обновить эти приложения до Angular, некоторые из них окажутся
гораздо проще работать с другими. Есть несколько ключевых приемов
и шаблоны, которые вы можете применить к будущим приложениям еще до вас
начать миграцию.

{@a follow-the-angular-styleguide}

{@a follow-the-angularjs-style-guide}
### Следуйте Руководству по стилю AngularJS

[Руководство по стилю AngularJS](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md)
собирает образцы и методы, которые, как доказывали, привели к
более чистые и удобные в обслуживании приложения AngularJS. Он содержит богатство
информации о том, как писать и организовывать код AngularJS - и в равной степени
главное - как **не** писать и не организовывать код AngularJS.

Angular - это переосмысленная версия лучших частей AngularJS. В этом
В смысле, его цели такие же, как в Руководстве по стилю AngularJS: «Сохранить»
хорошие части AngularJS, и чтобы избежать плохих частей. Там очень много
больше, чем Angular, конечно, но это значит
*следование руководству по стилю помогает сделать ваше приложение AngularJS более тесным
выровнен с Angular *.

В частности, есть несколько правил, которые значительно облегчат выполнение
*постепенное обновление* с использованием Angular  `upgrade/static`  модуль:

* [Правило 1](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility)
  утверждает, что должен быть один компонент на файл. Это не только делает
  Компоненты легко перемещаться и находить, но также позволяют нам мигрировать
  их между языками и фреймворками по одному. В этом примере приложения
  каждый контроллер, компонент, служба и фильтр находятся в своем собственном исходном файле.

* [Папки-на-Feature Structure](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure)
  и [модульность](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity)
  правила определяют аналогичные принципы на более высоком уровне абстракции: различные части
  Приложение должно находиться в разных каталогах и NgModules.

Таким образом, когда приложение размещает функцию для каждой функции, это также может быть
перенес одну функцию за раз. Для приложений, которые еще не похожи
поэтому настоятельно рекомендуется применять правила из руководства по стилю AngularJS
подготовительный этап. И это не только ради обновления - это просто
солидный совет в общем!

{@a using-a-module-loader}
### Использование загрузчика модулей

Когда вы разбиваете код приложения на один компонент на файл, вы часто заканчиваете работу
со структурой проекта с большим количеством относительно небольших файлов. Это
гораздо более аккуратный способ организовать вещи, чем небольшое количество больших файлов, но это
не очень хорошо работает, если вам нужно загрузить все эти файлы на страницу HTML
теги &lt;script&gt;. Особенно, когда вы также должны поддерживать эти теги в правильном
приказ. Вот почему стоит начать использовать *загрузчик модулей*.

Использование модуля загрузчика, такие как [SystemJS](https://github.com/systemjs/systemjs),
[Webpack](http://webpack.github.io/)или[Browserify](http://browserify.org/)
позволяет использовать встроенные модульные системы TypeScript или ES2015.
Вы можете использовать  `import`  и  `export`  функции которые явно указывают, что код может
и будут разделены между различными частями приложения. Для приложений ES5
Вы можете использовать стиль CommonJS  `require`  и  `module.exports`  . В обоих случаях
загрузчик модулей позаботится о загрузке всего кода, который необходим приложению
в правильном порядке.

При перемещении приложений в производство модульные загрузчики также облегчают это
упаковать их в производственные пакеты с включенными батареями.

{@a migrating-to-typescript}
### Переход на TypeScript

Если часть плана обновления Angular также предусматривает использование TypeScript, это делает
смысл вводить компилятор TypeScript еще до того, как начнется само обновление.
Это означает, что во время фактического обновления есть одна вещь, о которой нужно учиться и думать
Это также означает, что вы можете начать использовать функции TypeScript в своем коде AngularJS.

Поскольку TypeScript является надмножеством ECMAScript 2015, который, в свою очередь, является надмножеством
в ECMAScript 5 «переключение» на TypeScript не обязательно требует ничего
больше, чем установка компилятора TypeScript и переименование файлов из
 `*.js ` к `*.ts` . Но делать это, конечно, не очень полезно и не интересно.
Дополнительные шаги, подобные следующим может дать нам гораздо больше за доллар:

* Для приложений, использующих загрузчик модулей, TypeScript импортирует и экспортирует
  (которые на самом деле ECMAScript 2015 импорта и экспорта) могут быть использованы для организации
  код в модули.

* Типовые аннотации можно постепенно добавлять к существующим функциям и переменным
  чтобы определить их типы и получить такие преимущества, как проверка ошибок во время сборки
  отличная поддержка автозаполнения и встроенная документация.

* Новые функции JavaScript в ES2015, такие как функции стрелок,  `let ` с ` const` s,
  параметры функции по умолчанию и назначения деструктуры также могут быть постепенно
  добавлено, чтобы сделать код более выразительным.

* Сервисы и контроллеры можно превратить в*классы *. Таким образом, они будут шагом
  ближе к становлению Angular класса обслуживания и компонентов, которые сделают
  жизнь проще после обновления.

{@a using-component-directives}
### Использование директив компонента

В Angular компоненты являются основным примитивом, с которого работают пользовательские интерфейсы
построены. Вы определяете различные части пользовательского интерфейса как компоненты и
составить их в полный пользовательский опыт.

Вы также можете сделать это в AngularJS, используя *директивы компонента*. Это
директивы, которые определяют свои собственные шаблоны, контроллеры и привязки ввода / вывода -
те же самые вещи, которые определяют Angular компоненты. Приложения, созданные с
директивы компонентов гораздо проще перенести в Angular, чем в приложения
построен с функциями более низкого уровня, такими как  `ng-controller`, `ng-include` и область
наследование.

Для обеспечения совместимости с Angular должна быть настроена директива компонента AngularJS
эти атрибуты:

*  `restrict: 'E'` . Компоненты обычно используются в качестве элементов.
*  `scope: {}` - область изоляции. В Angular компоненты всегда изолированы
  из их окружения, и вы должны делать это и в AngularJS.
*  `bindToController: {}` . Компонентные входы и выходы должны быть связаны
  к контроллеру вместо использования  `$scope`.
*  `controller ` и ` controllerAs` . Компоненты имеют свои собственные контроллеры.
*  `template ` или ` templateUrl` . Компоненты имеют свои собственные шаблоны.

Компонентные директивы могут также использовать следующие атрибуты:

*  `transclude: true/{}`, если компонент должен включать содержимое из другого места.
*  `require`, если компонент должен общаться с некоторыми родительскими компонентами
  контроллер.

Компонент директива **не должен** использовать следующие атрибуты:

*  `compile` . Это не будет поддерживаться в Angular.
*  `replace: true` . Angular никогда не заменяет элемент компонента на
  компонентный шаблон. Этот атрибут также не рекомендуется в AngularJS.
*  `priority ` и ` terminal` . В то время как AngularJS компоненты могут использовать их,
  они не используются в Angular, и лучше не писать код
  это зависит от них.

Директива компонента AngularJS, полностью совпадающая с Angular
архитектура может выглядеть примерно так:

<code-example path="upgrade-module/src/app/hero-detail.directive.ts" header="hero-detail.directive.ts">
</code-example>

AngularJS 1.5 представляет [компонент API](https://docs.angularjs.org/api/ng/type/angular.Module#component)
это облегчает определение директив компонентов, подобных этим. Это хорошая идея для использования
этот API для компонентов директив по нескольким причинам:

* Требуется меньше стандартного кода.
* Он обеспечивает использование лучших практик, таких как  `controllerAs`.
* Он имеет хорошие значения по умолчанию для таких атрибутов директивы, как  `scope`  и  `restrict`.

Приведенный выше пример директивы компонента выглядит следующим образом
используя компонент API:

<code-example path="upgrade-module/src/app/upgrade-io/hero-detail.component.ts" region="hero-detail-io" header="hero-detail.component.ts">
</code-example>

Методы подключения жизненного цикла контроллера  `$onInit()`, `$onDestroy()`  и  `$onChanges()` 
Еще одна удобная функция, которую представляет AngularJS 1.5. У них все почти
точный [эквиваленты в Angular](guide/lifecycle-hooks), поэтому организация жизненного цикла компонента
логика вокруг них облегчит возможный процесс обновления Angular.

{@a upgrading-with-ngupgrade}
## Обновление с помощью ngUpgrade

Библиотека ngUpgrade в Angular - очень полезный инструмент для обновления
все, кроме самых маленьких приложений. С его помощью вы можете смешивать и сочетать
AngularJS и Angular компоненты в одном приложении и позволяют им взаимодействовать
бесшовно. Это означает, что вам не нужно выполнять работу по обновлению сразу
так как во время
переходный период.

{@a how-ngupgrade-works}
### Как работает ngUpgrade

Один из основных инструментов, предоставляемых ngUpgrade, называется  `UpgradeModule`.
Это модуль, который содержит утилиты для начальной загрузки и управления гибридом
приложения, которые поддерживают как Angular, так и AngularJS код.

Когда вы используете ngUpgrade, вы действительно *запускаете AngularJS и
Angular одновременно *. Весь Angular код работает в Angular
фреймворк и код AngularJS в фреймворке AngularJS. Оба из них являются
актуальные, полнофункциональные версии фреймворков. Эмуляция не происходит
так что вы можете ожидать, что у вас будут все функции и естественное поведение обеих платформ.

Кроме того, компоненты и сервисы управляются одним сервером
Фреймворк может взаимодействовать с теми из другого фреймворка. Это происходит
в трех основных областях: внедрение зависимостей, DOM и обнаружение изменений.

{@a dependency-injection}
#### Инъекция зависимости

Инъекция зависимостей является передней и центральной в AngularJS и
Angular, но есть некоторые ключевые различия между ними
рамки в том, как это на самом деле работает.

<table>
  <tr>
    <th>
      AngularJS
    </th>
    <th>
      Angular
    </th>
  </tr>
  <tr>
    <td>
      Токены внедрения зависимостей всегда являются строками
    </td>
    <td>

      Жетоны [могут иметь разные типы](guide/dependency-injection).
      Они часто являются классами. Они также могут быть строками.

    </td>
  </tr>
  <tr>
    <td>

      Там точно один инжектор. Даже в многомодульных приложениях
      все вливается в одно большое пространство имен.

    </td>
    <td>

      Существует [дерево иерархии инжекторов](guide/hierarchical-dependency-injection),
      с корневым инжектором и дополнительным инжектором для каждого компонента.

    </td>
  </tr>
</table>

Даже с учетом этих различий у вас все еще может быть внедрение зависимости
совместимость.  `upgrade/static`  решает различия и делает
все работает без проблем

* Вы можете сделать сервисы AngularJS доступными для внедрения в код Angular
  путем *повышения* их. Один и тот же экземпляр одного сервиса является общим
  между рамками. В Angular эти сервисы всегда будут в
  *корневой инжектор* и доступен для всех компонентов.

* Вы также можете сделать сервисы Angular доступными для внедрения в код AngularJS
  путем *понижения* их. Могут только услуги от Angular корневого инжектора
  быть пониженным. Опять же, одни и те же единичные экземпляры совместно используются средами.
  Когда вы регистрируете устаревшую службу, вы должны явно указать *строковый токен,* который вы хотите
  использовать в AngularJS.

<div class="lightbox">
  <img src="generated/images/guide/upgrade/injectors.png" alt="The two injectors in a hybrid application">
</div>

{@a components-and-the-dom}
#### Компоненты и DOM

В DOM гибридного приложения ngUpgrade есть компоненты и
директивы от AngularJS и Angular. Эти компоненты
общаться друг с другом, используя привязки ввода и вывода
их соответствующих структур, которые объединяют мосты ngUpgrade. Они могут также
общаться через общие введенные зависимости, как описано выше.

Главное, что нужно понять о гибридном приложении, это то, что каждый элемент в DOM принадлежит только одной из двух платформ.
Другая структура игнорирует это. Если элемент есть
принадлежащий AngularJS, Angular рассматривает его так, как если бы он не существовал
и наоборот.

Поэтому обычно гибридное приложение начинает жизнь как приложение AngularJS
и именно AngularJS обрабатывает корневой шаблон, например, index.html.
Затем Angular входит в изображение, когда где-то используется Angular компонент
в шаблоне AngularJS. Шаблон этого компонента будет затем управляться
Angular, и он может содержать любое количество Angular компонентов и
директивы.

Помимо этого, вы можете чередовать две структуры.
Вы всегда пересекаете границу между двумя фреймворками одним из двух
пути:

1. Используя компонент из другой среды: шаблон AngularJS
   используя Angular компонент, или Angular шаблон, используя
   AngularJS компонент.

2. За счет включения или проецирования контента из другой среды. ngUpgrade
    связывает связанные понятия AngularJS transclusion и Angular контента
    проекция вместе.

<div class="lightbox">
  <img src="generated/images/guide/upgrade/dom.png" alt="DOM element ownership in a hybrid application">
</div>

Всякий раз, когда вы используете компонент, принадлежащий другой структуре, a
происходит переключение между рамочными границами. Однако этот переключатель только
происходит с элементами в шаблоне этого компонента. Рассмотрим ситуацию
где вы используете Angular компонент из AngularJS, как это:

<code-example language="html" escape="html">
  &lt;a-component&gt;&lt;/a-component&gt;
</code-example>

Элемент DOM  `<a-component>`  останется управляемым AngularJS
элемент, потому что он определен в шаблоне AngularJS. Это также
означает, что вы можете применять к нему дополнительные директивы AngularJS, но *не можете*
Angular директивы. Это только в шаблоне  `<a-component>` 
где Angular шаги. Это же правило также применяется, когда вы
используйте директивы AngularJS от Angular.

{@a change-detection}
#### Обнаружение изменений

 `scope.$apply()` - это то, как AngularJS обнаруживает изменения и обновляет привязки данных.
После каждого события, которое происходит,  `scope.$apply()`  вызывается. Это тоже сделано
автоматически рамкой или вручную вами.

В Angular вещи разные. Пока обнаружение изменений еще
происходит после каждого события, никому не нужно звонить  `scope.$apply()`  для
что произойдет. Это потому, что весь код Angular работает внутри чего-либо
называется [Angular зона](api/core/NgZone). Angular всегда
знает, когда код заканчивается, поэтому он также знает, когда он должен стартовать
обнаружение изменений. Сам код не должен вызывать  `scope.$apply()` 
или что-нибудь подобное.

В случае гибридных приложений,  `UpgradeModule`  соединяет
AngularJS и Angular подходы. Вот что происходит:

* Все, что происходит в приложении, выполняется внутри Angular зоны.
  Это верно независимо от того, произошло ли событие в коде AngularJS или Angular.
  Зона запускает обнаружение изменения угла после каждого события.

*  `UpgradeModule` вызовет AngularJS  `$rootScope.$apply()`  после
  каждый поворот Angular зоны. Это также вызывает изменение AngularJS
  обнаружение после каждого события.

<div class="lightbox">
  <img src="generated/images/guide/upgrade/change_detection.png" alt="Change detection in a hybrid application">
</div>

На практике вам не нужно звонить  `$apply()`,
независимо от того, находится ли он в AngularJS или Angular.
 `UpgradeModule` делает это для нас. Вы *все можете* еще позвонить  `$apply()`  так что есть
Нет необходимости удалять такие вызовы из существующего кода. Эти звонки просто срабатывают
дополнительные проверки обнаружения изменений AngularJS в гибридном приложении.

Когда вы понижаете Angular компонент, а затем использовать его с AngularJS,
входы компонента будут отслеживаться с помощью обнаружения изменений AngularJS.
Когда эти входные данные изменяются, соответствующие свойства в компоненте
установлены. Вы также можете подключиться к изменениям путем реализации
[OnChanges](api/core/OnChanges)интерфейс в компоненте
так же, как вы могли бы, если бы не было понижено.

Соответственно, при обновлении компонента AngularJS и использовать его с угловатыми,
все привязки, определенные для директивы компонента  `scope`  (или  `bindToController`)
будет подключен к обнаружению Angular изменений. Они будут лечиться
как обычные Angular входы. Их значения будут записаны в обновленные компоненты
сфера (или контроллер), когда они меняются.

{@a using-upgrademodule-with-angular-ngmodules}
### Использование UpgradeModule с Angularи _NgModules_

И AngularJS, и Angular имеют свою концепцию модулей
чтобы помочь организовать приложение в единые блоки функциональности.

Их детали сильно отличаются по архитектуре и реализации.
В AngularJS вы добавляете ресурсы Angular к  `angular.module`  свойство.
В Angular вы создаете один или несколько классов, украшенных  `NgModule`  декоратор
который описывает Angular активы в метаданных. Различия расцветают оттуда.

В гибридном приложении вы запускаете обе версии Angular одновременно.
Это означает, что вам нужен как минимум один модуль, как AngularJS, так и Angular.
Вы будете импортировать  `UpgradeModule`  внутри NgModule, а затем использовать его для
начальная загрузка модуля AngularJS.

<div class="alert is-helpful">

Для получения дополнительной информации см. [NgModules](guide/ngmodules).

</div>

{@a bootstrapping-hybrid-applications}
### Самозагрузка гибридных приложений

Чтобы загрузить гибридное приложение, вы должны загрузить каждый из Angular и
AngularJS части приложения. Вы должны сначала загрузить Angular биты и
затем спросите  `UpgradeModule`  для загрузки битов AngularJS дальше.

В приложении AngularJS у вас есть корневой модуль AngularJS, который также будет
использоваться для начальной загрузки приложения AngularJS.

<code-example path="upgrade-module/src/app/ajs-bootstrap/app.module.ts" region="ng1module" header="app.module.ts">
</code-example>

Приложения Pure AngularJS могут автоматически загружаться с помощью  `ng-app` 
директива где-то на странице HTML. Но для гибридных приложений вы вручную запускаете через
 `UpgradeModule` . Таким образом, это хороший предварительный шаг для переключения приложений AngularJS на использование
ручной JavaScript [  `angular.bootstrap`  ](https://docs.angularjs.org/api/ng/function/angular.bootstrap)
метод даже до переключения их в гибридный режим.

Скажи, что у тебя есть  `ng-app`  привод начальной загрузки, такие как этот:

<code-example path="upgrade-module/src/index-ng-app.html">
</code-example>

Вы можете удалить  `ng-app`  и  `ng-strict-di`  директивы из HTML
и вместо этого переключиться на вызов  `angular.bootstrap`  из JavaScript, который
приведет к тому же:

<code-example path="upgrade-module/src/app/ajs-bootstrap/app.module.ts" region="bootstrap" header="app.module.ts">
</code-example>

Чтобы начать преобразование приложения AngularJS в гибрид, вам необходимо загрузить платформу Angular.
Вы можете увидеть, как это можно сделать с помощью SystemJS, следуя инструкциям в [Настройка для обновления до AngularJS](guide/upgrade-setup)для выборочного копирования кода из [QuickStart github repository](https://github.com/angular/quickstart).

Вам также необходимо установить  `@angular/upgrade`  пакет через `npm install @angular/upgrade --save` 
и добавьте отображение для  `@angular/upgrade/static`  пакет:

<code-example path="upgrade-module/src/systemjs.config.1.js" region="upgrade-static-umd" header="systemjs.config.js (map)">
</code-example>

Затем создайте  `app.module.ts`  файл и добавьте следующее  `NgModule`  класс:

<code-example path="upgrade-module/src/app/ajs-a-hybrid-bootstrap/app.module.ts" region="ngmodule" header="app.module.ts">
</code-example>

Это минимум  `NgModule`  Импорт  `BrowserModule` - модуль, который должно быть в каждом браузерном приложении Angular.
Также импортирует  `UpgradeModule`  от  `@angular/upgrade/static`, которая экспортирует поставщиков, которые будут использоваться
для обновления и понижения сервисов и компонентов.

В конструкторе  `AppModule`, используйте внедрение зависимостей, чтобы получить  `UpgradeModule`  Экземпляр
и использовать его для загрузки приложения AngularJS в  `AppModule.ngDoBootstrap`  Метод.
 `upgrade.bootstrap` метод принимает точно такие же аргументы, что и [angular.bootstrap](https://docs.angularjs.org/api/ng/function/angular.bootstrap):

<div class="alert is-helpful">

Обратите внимание, что вы не добавляете  `bootstrap`  декларация к  `@NgModule`  декоратор, так как
AngularJS будет владельцем корневого шаблона приложения.

</div>

Теперь вы можете загрузиться  `AppModule`  с помощью  `platformBrowserDynamic.bootstrapModule`  Метод.

<code-example path="upgrade-module/src/app/ajs-a-hybrid-bootstrap/app.module.ts" region="bootstrap" header="app.module.ts'">
</code-example>

Поздравляем! Вы запускаете гибридное приложение!
существующий код AngularJS работает как прежде, и вы готовы начать добавление кода Angular.

{@a using-angular-components-from-angularjs-code}

### Использование Angular компонентов из кода AngularJS

<img src="generated/images/guide/upgrade/ajs-to-a.png" alt="Using an Angular component from AngularJS code" class="left">

Запустив гибридное приложение, вы можете начать постепенный процесс обновления
код. Одним из наиболее распространенных шаблонов для этого является использование Angular компонента
в контексте AngularJS. Это может быть совершенно новый компонент или тот, который был
ранее AngularJS, но был переписан для Angular.

Скажем, у вас есть простой Angular компонент, который содержится информацией о герое:

<code-example path="upgrade-module/src/app/downgrade-static/hero-detail.component.ts" header="hero-detail.component.ts">
</code-example>

Если вы хотите использовать этот компонент из AngularJS, вам нужно *понизить* его
с использованием  `downgradeComponent()`  метод . Результатом является AngularJS
*директива*, которую затем можно зарегистрировать в AngularJS модуль:

<code-example path="upgrade-module/src/app/downgrade-static/app.module.ts" region="downgradecomponent" header="app.module.ts">
</code-example>

Потому что  `HeroDetailComponent`  является Angular компонентом, вы также должны добавить его в
 `declarations ` в ` AppModule`.

И потому, что этот компонент используется из модуля AngularJS, и является точкой входа в
Angular приложение, вы должны добавить его в  `entryComponents`  для
NgModule.

<code-example path="upgrade-module/src/app/downgrade-static/app.module.ts" region="ngmodule" header="app.module.ts">
</code-example>

<div class="alert is-helpful">

Все Angular компоненты, директивы и трубы должны быть объявлены в NgModule.

</div>

Чистым результатом является директива AngularJS под названием  `heroDetail`, что вы можете
используйте как любую другую директиву в шаблонах AngularJS.

<code-example path="upgrade-module/src/index-downgrade-static.html" region="usecomponent">
</code-example>

<div class="alert is-helpful">

Обратите внимание, что этот AngularJS является директивой элемента (`restrict: 'E'`) называется  `heroDetail`.
Директива элемента AngularJS сопоставляется на основе ее _name_.
*  `selector`  Метаданные пониженного компонента Angular игнорируются.*

</div>

Конечно, большинство компонентов не так просты. Многие из них
есть *входы и выходы,* которые соединяют их с внешним миром. Ан
Компонент Angular детализации героя с входами и выходами может выглядеть
нравится это:

<code-example path="upgrade-module/src/app/downgrade-io/hero-detail.component.ts" header="hero-detail.component.ts">
</code-example>

Эти входы и выходы могут быть предоставлены из шаблона AngularJS и
 `downgradeComponent()` метод заботится о подключении их:

<code-example path="upgrade-module/src/index-downgrade-io.html" region="usecomponent">
</code-example>

Обратите внимание, что даже если вы находитесь в шаблоне AngularJS, **вы используете Angular
Синтаксис атрибута для привязки входов и выходов **. Это требование понижено
составные части. Сами выражения все еще являются регулярными выражениями AngularJS.

<div class="callout is-important">

<header>
  Используйте kebab-case для устаревших атрибутов компонентов
</header>

Есть одно заметное исключение из правила использования синтаксиса Angular
для пониженных компонентов. Это связано с входными или выходными именами, которые состоят из
из нескольких слов. В угловому, вы бы связать эти атрибуты с помощью верблюжьего:

<code-example format="">
  [myHero]="hero"
  (heroDeleted)="handleHeroDeleted($event)"
</code-example>

Но при их использовании из шаблонов AngularJS, вы должны использовать кебаб-случай:

<code-example format="">
  [my-hero]="hero"
  (hero-deleted)="handleHeroDeleted($event)"
</code-example>

</div>

 `$event` Переменная может использоваться в выходных данных для получения доступа к
объект, который был испущен. В этом случае это будет  `Hero`  объект, потому что
это то, что было передано  `this.deleted.emit()`.

Поскольку это шаблон AngularJS, вы все равно можете использовать другой AngularJS
директивы на элементе, даже если на нем есть атрибуты Angular привязки.
Например, вы можете легко сделать несколько копий компонента, используя  `ng-repeat`  :

<code-example path="upgrade-module/src/index-downgrade-io.html" region="userepeatedcomponent">
</code-example>

{@a using-angularjs-component-directives-from-angular-code}
### Использование AngularJS Компонент Директивы из Angular кода

<img src="generated/images/guide/upgrade/a-to-ajs.png" alt="Using an AngularJS component from Angular code" class="left">

Таким образом, вы можете написать компонент Angular, а затем использовать его из AngularJS
код. Это полезно, когда вы начинаете переходить с более низкого уровня
компоненты и проложите себе путь. Но в некоторых случаях это удобнее
делать вещи в обратном порядке: начать с компонентов более высокого уровня
и проложите себе путь вниз. Это тоже можно сделать с помощью  `upgrade/static`.
Вы можете *обновить* директивы компонента AngularJS, а затем использовать их из
Angular.

Не все виды директив AngularJS могут быть обновлены. Директива
действительно должна быть *директива компонента*, с характеристиками
[описано в руководстве по подготовке выше](guide/upgrade#using-component-directives).
Самым безопасным вариантом для обеспечения совместимости является использование
[компонент API](https://docs.angularjs.org/api/ng/type/angular.Module)
введено в AngularJS 1.5

Простой пример обновляемого компонента - это тот, который просто имеет шаблон
и контроллер:

<code-example path="upgrade-module/src/app/upgrade-static/hero-detail.component.ts" region="hero-detail" header="hero-detail.component.ts">
</code-example>

Вы можете *обновить* этот компонент до Angular, используя  `UpgradeComponent`  Класс.
Создавая новую Angular **директиву,** которая расширяет  `UpgradeComponent`  и делает  `super`  звонок
внутри его конструктора у вас есть полностью обновленный компонент AngularJS, который будет использоваться внутри Angular.
Осталось только добавить его в  `AppModule`  's  `declarations`  массив.

<code-example path="upgrade-module/src/app/upgrade-static/hero-detail.component.ts" region="hero-detail-upgrade" header="hero-detail.component.ts">
</code-example>

<code-example path="upgrade-module/src/app/upgrade-static/app.module.ts" region="hero-detail-upgrade" header="app.module.ts">
</code-example>

<div class="alert is-helpful">

Модернизированные компоненты - это Angular **директивы**, а не**компоненты**, потому что Angular
не знает, что AngularJS будет создавать элементы под ним. Насколько Angular знает, модернизированный
Компонент - это просто директива - тег - и Angular не должен беспокоиться о нем
его дети.

</div>

Модернизированный компонент также может иметь входы и выходы, как определено
привязки области / контроллера исходного компонента AngularJS
директивы. При использовании компонента из Angular шаблона,
обеспечивают входы и выходы, используя **Angular синтаксис шаблона**,
соблюдая следующие правила:

<table>
  <tr>
    <th>
    </th>
    <th>
      Обязательное определение
    </th>
    <th>
      Синтаксис шаблона
    </th>
  </tr>
  <tr>
    <th>
      Привязка атрибутов
    </th>
    <td>

       `myAttribute: '@myAttribute'` 

    </td>

    <td>

       `<my-component myAttribute="value">` 

    </td>
  </tr>
  <tr>
    <th>
      Привязка выражения
    </th>
    <td>

       `myOutput: '&myOutput'` 

    </td>
    <td>

       `<my-component (myOutput)="action()">` 

    </td>
  </tr>
  <tr>
    <th>
      Односторонняя привязка
    </th>
    <td>

       `myValue: '<myValue'` 

    </td>
    <td>

       `<my-component [myValue]="anExpression">` 

    </td>
  </tr>
  <tr>
    <th>
      Двухстороннее связывание
    </th>
    <td>

       `myValue: '=myValue'` 

    </td>
    <td>

      Как двусторонняя привязка: `<my-component [(myValue)]="anExpression">`.
      Поскольку для большинства двусторонних привязок AngularJS требуется только односторонняя привязка
      на практике, `<my-component [myValue]="anExpression">` достаточно часто.

    </td>
  </tr>
</table>

Например, представьте героическую детальную директиву компонента AngularJS
с одним входом и одним выходом:

<code-example path="upgrade-module/src/app/upgrade-io/hero-detail.component.ts" region="hero-detail-io" header="hero-detail.component.ts">
</code-example>

Вы можете обновить этот компонент к угловому, аннотированию входов и выходам в директиве обновления,
а затем обеспечивают ввод и вывод с помощью Angular синтаксис шаблона:

<code-example path="upgrade-module/src/app/upgrade-io/hero-detail.component.ts" region="hero-detail-io-upgrade" header="hero-detail.component.ts">
</code-example>

<code-example path="upgrade-module/src/app/upgrade-io/container.component.ts" header="container.component.ts">
</code-example>

{@a projecting-angularjs-content-into-angular-components}
### Проецирование содержимого AngularJS в Angular компоненты

<img src="generated/images/guide/upgrade/ajs-to-a-with-projection.png" alt="Projecting AngularJS content into Angular" class="left">

Когда вы используете пониженный компонент Angular из AngularJS
шаблон, может возникнуть необходимость *включить* какой-либо контент в него. Это
тоже возможно. Несмотря на то, что нет такого понятия, как включение в угловом,
Существует очень похожая концепция, которая называется *проекцией контента*.  `upgrade/static` 
в состоянии сделать эти две функции взаимодействовать.

Angular компоненты, поддерживающие проекцию контента, используют  `<ng-content>` 
тег в них. Вот пример такого компонента:

<code-example path="upgrade-module/src/app/ajs-to-a-projection/hero-detail.component.ts" header="hero-detail.component.ts">
</code-example>

При использовании компонента из AngularJS вы можете предоставить содержимое для него. Просто
как если бы они были включены в AngularJS, они проецируются на локацию
из  `<ng-content>`  тега в угловому:

<code-example path="upgrade-module/src/index-ajs-to-a-projection.html" region="usecomponent">
</code-example>

<div class="alert is-helpful">

Когда содержимое AngularJS проецируется внутри компонента Angular, оно все равно остается
остается в "земле AngularJS" и управляется структурой AngularJS.

</div>

{@a transcluding-angular-content-into-angularjs-component-directives}
### Преобразование Angular содержимого в директивы AngularJS Component

<img src="generated/images/guide/upgrade/a-to-ajs-with-transclusion.png" alt="Projecting Angular content into AngularJS" class="left">

Так же, как вы можете проецировать контент AngularJS в Angular компоненты
вы можете в *любое время включить* Angular-контент в компоненты AngularJS
вы используете обновленные версии из них.

Когда директива компонента AngularJS поддерживает transclusion, она может использовать
 `ng-transclude` Директива в своем шаблоне для обозначения включения
указать:

<code-example path="upgrade-module/src/app/a-to-ajs-transclusion/hero-detail.component.ts" header="hero-detail.component.ts">
</code-example>

Если вы обновите этот компонент и используете его из Angular, вы можете заполнить его
компонент тег с содержимым, которые будут затем включены через :

<code-example path="upgrade-module/src/app/a-to-ajs-transclusion/container.component.ts" header="container.component.ts">
</code-example>

{@a making-angularjs-dependencies-injectable-to-angular}
### Создание зависимостей AngularJS для инъекций в Angular

При запуске гибридного приложения вы можете столкнуться с ситуациями, когда вам нужно ввести
некоторые зависимости AngularJS в вашем коде Angular.
Может быть, у вас есть бизнес-логика в сервисах AngularJS.
Может быть, вы хотите получить доступ к встроенным сервисам AngularJS, таким как  `$location ` или ` $timeout`.

В этих ситуациях можно *обновить* поставщика AngularJS до
Angular. Это позволяет затем ввести его где-нибудь в Angular
код. Например, у вас может быть служба под названием  `HeroesService`  в AngularJS:

<code-example path="upgrade-module/src/app/ajs-to-a-providers/heroes.service.ts" header="heroes.service.ts">
</code-example>

Вы можете обновить сервис, используя Angular [заводской провайдер](guide/dependency-injection-providers#factory-providers)
который запрашивает сервис у AngularJS  `$injector`.

Многие разработчики предпочитают декларировать провайдера фабрики в отдельном  `ajs-upgraded-providers.ts`  файл
так что они все вместе, что делает их легче ссылаться на них, создавать новые и
удалите их после завершения обновления.

Также рекомендуется экспортировать  `heroesServiceFactory`  функционирует так, что время
Компиляция может забрать его.

<div class="alert is-helpful">

**Примечание:** строка 'heroes' внутри фабрики относится к AngularJS  `HeroesService`.
Обычно в AngularJS приложений, чтобы выбрать имя службы для маркеров, например «героев»,
и добавьте суффикс «Service» для создания имени класса.

</div>

<code-example path="upgrade-module/src/app/ajs-to-a-providers/ajs-upgraded-providers.ts" header="ajs-upgraded-providers.ts">
</code-example>

Затем вы можете предоставить услугу Angular, добавив ее в  `@NgModule`  :

<code-example path="upgrade-module/src/app/ajs-to-a-providers/app.module.ts" region="register" header="app.module.ts">
</code-example>

Затем используйте службу внутри компонента, вводя его в компоненте конструктора, используя свой класс в качестве аннотации типа:

<code-example path="upgrade-module/src/app/ajs-to-a-providers/hero-detail.component.ts" header="hero-detail.component.ts">
</code-example>

<div class="alert is-helpful">

В этом примере вы обновили класс обслуживания.
Вы можете использовать аннотацию типа TypeScript, когда вводите ее. Пока это не так
влияет на то, как обрабатывается зависимость, это дает преимущества статического типа
проверка. Это не требуется, хотя и любой сервис AngularJS, фабрика или
провайдер может быть обновлен.

</div>

{@a making-angular-dependencies-injectable-to-angularjs}
### Создание Angular зависимостей для инъекций в AngularJS

В дополнение к обновлению зависимостей AngularJS, вы также можете *понизить версию*
Angular зависимости, так что вы можете использовать их из AngularJS. Это может быть
полезно, когда вы начинаете миграцию сервисов на Angular или создание новых сервисов
в Angular с сохранением компонентов, написанных на AngularJS.

Например, у вас может быть служба Angular, которая называется  `Heroes`  :

<code-example path="upgrade-module/src/app/a-to-ajs-providers/heroes.ts" header="heroes.ts">
</code-example>

Опять же, как и в случае с Angularи компонентами, зарегистрируйте провайдера в  `NgModule`, добавив его в модуль  `providers`  список.

<code-example path="upgrade-module/src/app/a-to-ajs-providers/app.module.ts" region="ngmodule" header="app.module.ts">
</code-example>

Теперь заверните Angular  `Heroes`  в *заводской функции AngularJS* с использованием  `downgradeInjectable()` 
и подключите фабрику к модулю AngularJS.
Имя зависимости AngularJS до вас:

<code-example path="upgrade-module/src/app/a-to-ajs-providers/app.module.ts" region="register" header="app.module.ts">
</code-example>

После этого, услуга инъекционный где - нибудь в AngularJS коде:

<code-example path="upgrade-module/src/app/a-to-ajs-providers/hero-detail.component.ts" header="hero-detail.component.ts">
</code-example>

{@a lazy-loading-angularjs}
## Ленивая загрузка AngularJS

При создании приложений вы хотите, чтобы при необходимости загружались только необходимые ресурсы. Будь то загрузка ресурсов или кода, убедитесь, что все, что можно отложить до необходимого, обеспечивает эффективную работу приложения. Это особенно актуально при запуске разных фреймворков в одном приложении.

[Ленивая загрузка](guide/glossary#lazy-loading)- это метод, который откладывает загрузку необходимых ресурсов и ресурсов кода до их фактического использования. Это сокращает время запуска и повышает эффективность, особенно при запуске разных сред в одном приложении.

При переносе больших приложений из AngularJS в Angular с использованием гибридного подхода необходимо сначала перенести некоторые из наиболее часто используемых функций и использовать только менее часто используемые функции, если это необходимо. Это поможет вам убедиться, что приложение по-прежнему обеспечивает бесперебойную работу ваших пользователей во время миграции.

В большинстве сред, где для визуализации приложения используются Angular и AngularJS, обе платформы загружаются в исходный пакет, отправляемый клиенту. Это приводит как к увеличению размера пакета, так и к возможному снижению производительности.

На общую производительность приложения влияют случаи, когда пользователь остается на страницах рендеринга в Angular, поскольку среда и приложение AngularJS по-прежнему загружаются и работают, даже если к ним никогда не обращаются.

Вы можете предпринять шаги для уменьшения как размера пакета, так и проблем с производительностью. Выделив свое приложение AngularJS в отдельный пакет, вы можете воспользоваться [ленивая загрузка](guide/glossary#lazy-loading)загружать, загружать и отображать приложение AngularJS только при необходимости. Эта стратегия уменьшает ваш первоначальный размер пакета, предотвращает любое потенциальное влияние от загрузки обеих платформ до тех пор, пока это не станет абсолютно необходимым, и поддерживает максимально эффективную работу вашего приложения.

Шаги ниже показано, как сделать следующее:

* Настройте функцию обратного вызова для вашего пакета AngularJS.
* Создайте сервис, который загружает и загружает ваше приложение AngularJS.
* Создайте маршрутизируемый компонент для контента AngularJS
* Создать кастом  `matcher`  функция для AngularJS специфической URL - адресов и настроить Angular  `Router`  с пользовательским сопоставителем для маршрутов AngularJS.

{@a create-a-service-to-lazy-load-angularjs}
### Создать сервис для ленивой загрузки AngularJS

Начиная с Angular версии 8, ленивая загрузка кода может быть выполнена просто с использованием синтаксиса динамического импорта  `import('...')`  . В вашем приложении вы создаете новый сервис, который использует динамический импорт для отложенной загрузки AngularJS.

<code-example path="upgrade-lazy-load-ajs/src/app/lazy-loader.service.ts" header="src/app/lazy-loader.service.ts">
</code-example>

Сервис использует  `import()`  Метод для ленивой загрузки вашего приложения AngularJS. Это уменьшает первоначальный размер пакета вашего приложения, так как вы не загружаете код, который еще не нужен вашему пользователю. Вам также необходимо указать способ _bootstrap_ приложения вручную после его загрузки. AngularJS предоставляет способ ручной загрузки приложения с помощью метода [angular.bootstrap ()](https://docs.angularjs.org/api/ng/function/angular.bootstrap)с предоставленным элементом HTML. Ваше приложение AngularJS также должно отображать  `bootstrap`  метод начальной который загружает приложение AngularJS.

Чтобы убедиться, что в приложении AngularJS запущен любой необходимый разрыв, например, удаление глобальных слушателей, вы также реализуете метод для вызова  `$rootScope.destroy()`.

<code-example path="upgrade-lazy-load-ajs/src/app/angularjs-app/index.ts" header="angularjs-app">
</code-example>

В вашем приложении AngularJS настроены только маршруты, необходимые для визуализации контента. Остальные маршруты в вашем приложении обрабатываются Angular маршрутизатором. Выставленный  `bootstrap`  Метод вызывается в вашем приложении Angular для начальной загрузки приложения AngularJS после загрузки пакета.

<div class="alert is-important">

**Примечание.** После загрузки и загрузки AngularJS прослушиватели, например, подключенные в конфигурации вашего маршрута, продолжат прослушивать изменения маршрута. Чтобы гарантировать отключение слушателей, когда AngularJS не отображается, настройте  `otherwise`  опция с [$ routeProvider](https://docs.angularjs.org/api/ngRoute/provider/$routeProvider)которая отображает пустой шаблон. Это предполагает, что все другие маршруты будут обрабатываться Angular.

</div>

{@a create-a-component-to-render-angularjs-content}
### Создайте компонент для визуализации содержимого AngularJS

В вашем приложении Angular вам необходим компонент в качестве заполнителя для содержимого AngularJS. Этот компонент использует созданный вами сервис для загрузки и начальной загрузки вашего приложения AngularJS после инициализации компонента.

<code-example path="upgrade-lazy-load-ajs/src/app/angular-js/angular-js.component.ts" header="src/app/angular-js/angular-js.component.ts">
</code-example>

Когда Angular Router соответствует маршруту, который использует AngularJS,  `AngularJSComponent`, а содержимое отображается в соответствии с AngularJS [  `ng-view`  ](https://docs.angularjs.org/api/ngRoute/directive/ngView)директивой . Когда пользователь уходит от маршрута,  `$rootScope`  уничтожен в приложении AngularJS.

{@a configure-a-custom-route-matcher-for-angularjs-routes}
### Настройте пользовательское сопоставление маршрутов для маршрутов AngularJS

Чтобы настроить Angular Router, необходимо определить маршрут для URL-адресов AngularJS. Чтобы соответствовать этим URL, вы добавляете конфигурацию маршрута, которая использует  `matcher`  недвижимость.  `matcher` позволяет использовать настраиваемое сопоставление с образцом для URL-путей. Angular маршрутизатор сначала пытается найти соответствие более конкретным маршрутам, таким как статические и переменные. Когда он не находит соответствия, он просматривает пользовательские соответствия, определенные в конфигурации вашего маршрута. Если пользовательские сопоставления не совпадают с маршрутом, он переходит ко всем маршрутам, таким как страница 404.

В следующем примере определяется пользовательская функция соответствия для маршрутов AngularJS.

<code-example path="upgrade-lazy-load-ajs/src/app/app-routing.module.ts" header="src/app/app-routing.module.ts" region="matcher">
</code-example>

Следующий код добавляет объект маршрута в вашу конфигурацию маршрутизации, используя  `matcher`  свойство и пользовательское matcher, а также  `component`  свойство с  `AngularJSComponent`.

<code-example path="upgrade-lazy-load-ajs/src/app/app-routing.module.ts" header="src/app/app-routing.module.ts">
</code-example>

Когда ваше приложение соответствует маршруту, для которого требуется AngularJS, приложение AngularJS загружается и загружается, маршруты AngularJS соответствуют URL-адресу, необходимому для визуализации их содержимого, и ваше приложение продолжает работать с платформами AngularJS и Angular.

{@a using-the-unified-angular-location-service}
## Использование единой службы Angular локаций

В AngularJS [$ location service](https://docs.angularjs.org/api/ng/service/$location)обрабатывает все настройки маршрутизации и навигации, кодирование и декодирование URL-адресов, перенаправляет и взаимодействует с API-интерфейсами браузера. Angular использует свой собственный  `Location`  Служба определения для всех этих задач.

При переходе с AngularJS на Angular вы захотите перенести как можно больше ответственности на Angular, чтобы вы могли воспользоваться преимуществами новых API. Чтобы помочь с переходом, Angular предоставляет  `LocationUpgradeModule`  . Этот модуль включает _унифицированную_ службу определения местоположения, которая переносит обязанности с AngularJS  `$location`  Служба определения в Angular  `Location`  Служба определения.

Чтобы использовать  `LocationUpgradeModule`, импортировать символ из  `@angular/common/upgrade`  и добавьте его в свой  `AppModule`  импортирует используя статический  `LocationUpgradeModule.config()`  Метод.

```ts
// Other imports ...
import { LocationUpgradeModule } from '@angular/common/upgrade';

@NgModule({
  imports: [
    // Other NgModule imports...
    LocationUpgradeModule.config()
  ]
})
export class AppModule {}
```

 `LocationUpgradeModule.config()` Метод принимает объект конфигурации, который позволяет настраивать параметры, включая  `LocationStrategy`  с  `useHash`  свойство и префикс URL с  `hashPrefix`  свойство.

 `useHash` свойство умолчанию  `false`, а  `hashPrefix`  умолчанию - пустой  `string`  . Передайте объект конфигурации, чтобы переопределить значения по умолчанию.

```ts
LocationUpgradeModule.config({
  useHash: true,
  hashPrefix: '!'
})
```

<div class="alert is-important">

**Примечание:** см.  `LocationUpgradeConfig`  для дополнительных параметров конфигурации, доступных для  `LocationUpgradeModule.config()`  Метод.

</div>

Это регистрирует замену для  `$location`  провайдера в AngularJS. После регистрации все навигационные, широковещательные сообщения и любые необходимые циклы дайджеста в AngularJS, запускаемые во время навигации, обрабатываются Angular. Это дает вам единый способ последовательно перемещаться по обеим сторонам гибридного приложения.

Для использования  `$location`  Service в качестве поставщика в AngularJS, вам нужно понизить  `$locationShim`  используя фабричного провайдера.

```ts
// Other imports ...
import { $locationShim } from '@angular/common/upgrade';
import { downgradeInjectable } from '@angular/upgrade/static';

angular.module('myHybridApp', [...])
  .factory('$location', downgradeInjectable($locationShim));
```

Как только вы представите Angular Router, использование Angular Router запускает навигацию через унифицированную службу определения местоположения, по-прежнему предоставляя единый источник для навигации с AngularJS и Angular.

<!--
TODO:
Correctly document how to use AOT with SystemJS-based  `ngUpgrade`  apps (or better yet update the
 `ngUpgrade`  examples/guides to use  `@angular/cli` ).
See https://github.com/angular/angular/issues/35989.

{@a using-ahead-of-time-compilation-with-hybrid-apps}
## Using Ahead-of-time compilation with hybrid apps

You can take advantage of Ahead-of-time (AOT) compilation on hybrid apps just like on any other
Angular application.
The setup for a hybrid app is mostly the same as described in
[the Ahead-of-time Compilation chapter](guide/aot-compiler)
save for differences in  `index.html`  and  `main-aot.ts` 

The  `index.html`  will likely have script tags loading AngularJS files, so the  `index.html` 
for AOT must also load those files.
An easy way to copy them is by adding each to the  `copy-dist-files.js`  file.

You'll need to use the generated  `AppModuleFactory`, instead of the original  `AppModule`  to
bootstrap the hybrid app:

<code-example path="upgrade-phonecat-2-hybrid/app/main-aot.ts" header="app/main-aot.ts">
</code-example>

And that's all you need do to get the full benefit of AOT for Angular apps!
-->

{@a phonecat-upgrade-tutorial}
## PhoneCat Обновление Учебник

В этом разделе вы научитесь готовить и обновлять приложение с  `ngUpgrade`.
Пример приложения [Angular PhoneCat](https://github.com/angular/angular-phonecat)
из [оригинальное AngularJS учебника](https://docs.angularjs.org/tutorial),
именно здесь многие из нас начали наши Angular приключения. Теперь вы увидите, как
перенесите это приложение в дивный новый мир Angular.

В процессе вы узнаете, как применять шаги, описанные в
[руководство по подготовке](guide/upgrade#preparation). Вы выровняете приложение
с Angular, а также начать писать в TypeScript.

Чтобы следовать учебнику, клонируйте
[angular-phonecat](https://github.com/angular/angular-phonecat)хранилище
и применить шаги, как вы идете.

С точки зрения структуры проекта, это где начинается работа:

<div class='filetree'>
  <div class='file'>
    Angular-Phonecat
  </div>
  <div class='children'>
    <div class='file'>
      bower.json
    </div>
    <div class='file'>
      karma.conf.js
    </div>
    <div class='file'>
      package.json
    </div>
    <div class='file'>
      приложение
    </div>
    <div class='children'>
      <div class='file'>
        ядро
      </div>
      <div class='children'>
        <div class='file'>
          Галочка
        </div>
        <div class='children'>
          <div class='file'>
            checkmark.filter.js
          </div>
          <div class='file'>
            checkmark.filter.spec.js
          </div>
        </div>
        <div class='file'>
          телефон
        </div>
        <div class='children'>
          <div class='file'>
            phone.module.js
          </div>
          <div class='file'>
            phone.service.js
          </div>
          <div class='file'>
            phone.service.spec.js
          </div>
        </div>
        <div class='file'>
          core.module.js
        </div>
      </div>
      <div class='file'>
        телефон-деталь
      </div>
      <div class='children'>
        <div class='file'>
          phone-detail.component.js
        </div>
        <div class='file'>
          phone-detail.component.spec.js
        </div>
        <div class='file'>
          phone-detail.module.js
        </div>
        <div class='file'>
          phone-detail.template.html
        </div>
      </div>
      <div class='file'>
        список телефонов
      </div>
      <div class='children'>
        <div class='file'>
          phone-list.component.js
        </div>
        <div class='file'>
          phone-list.component.spec.js
        </div>
        <div class='file'>
          phone-list.module.js
        </div>
        <div class='file'>
          phone-list.template.html
        </div>
      </div>
      <div class='file'>
        IMG
      </div>
      <div class='children'>
        <div class='file'>
           ...
        </div>
      </div>
      <div class='file'>
        телефоны
      </div>
      <div class='children'>
        <div class='file'>
           ...
        </div>
      </div>
      <div class='file'>
        app.animations.js
      </div>
      <div class='file'>
        app.config.js
      </div>
      <div class='file'>
        app.css
      </div>
      <div class='file'>
        app.module.js
      </div>
      <div class='file'>
        index.html
      </div>
    </div>
    <div class='file'>
      e2e-тесты
    </div>
    <div class='children'>
      <div class='file'>
        транспортир-conf.js
      </div>
      <div class='file'>
        scenarios.js
      </div>
    </div>
  </div>
</div>

Это на самом деле довольно хорошая отправная точка. Код использует AngularJS 1.5
Компонент API и организация следует
[AngularJS Руководство по стилю](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md),
что является важным [подготовительный этап](guide/upgrade#follow-the-angular-styleguide)раньше
успешное обновление.

* Каждый компонент, служба и фильтр находятся в своем собственном исходном файле согласно
  [Правило 1](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility).

*  `core `, ` phone-detail`, и  `phone-list`  Модули каждый в своем
  собственный подкаталог. Эти подкаталоги содержат код JavaScript, а также
  HTML-шаблоны, которые идут с каждой конкретной функцией. Это соответствует
  [Структура папок по функциям](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure)
  и [модульность](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity)
  правила.

* Модульные тесты расположены рядом с кодом приложения, где они легко
  нашел, как описано в правилах для
  [Организация испытаний](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#organizing-tests).

{@a switching-to-typescript}
### Переключение на TypeScript

Поскольку вы собираетесь писать код Angular на языке TypeScript, это имеет смысл
принесите компилятор TypeScript еще до того, как вы начнете обновление.

Вы также начнете постепенно отказываться от менеджера пакетов Bower
NPM, установка всех новых зависимостей с использованием NPM и, в конечном итоге, удаление Bower из проекта.

Начните с установки TypeScript в проект.

<code-example format="">
  npm i typescript --save-dev
</code-example>

Установите определения типов для существующих библиотек
вы используете, но они не поставляются с предварительно упакованными типами: AngularJS, AngularJS Material и
Фреймворк для жасмина.

Для приложения PhoneCat, мы можем установить необходимые определения типов, выполнив следующую команду:

<code-example format="">
  npm install @types/jasmine @types/angular @types/angular-animate @types/angular-aria @types/angular-cookies @types/angular-mocks @types/angular-resource @types/angular-route @types/angular-sanitize --save-dev
</code-example>

Если вы используете AngularJS материал, вы можете установить определение типа с помощью:

<code-example format="">
  npm install @types/angular-material --save-dev
</code-example>

Вы также должны настроить компилятор TypeScript с  `tsconfig.json`  в каталоге проекта
как описано в руководстве [Конфигурация TypeScript](guide/typescript-configuration).
 `tsconfig.json` Файл сообщает компилятору TypeScript, как включить файлы TypeScript
в код ES5, связанный с модулями CommonJS.

Наконец, вы должны добавить несколько скриптов npm в  `package.json`  для компиляции файлов TypeScript
JavaScript (на основе  `tsconfig.json`  файл конфигурации):

<code-example format="">
  "scripts": {
    "tsc": "tsc",
    "tsc:w": "tsc -w",
    ...
</code-example>

Теперь запустите компилятор машинопись из командной строки в режиме часов:

<code-example format="">
  npm run tsc:w
</code-example>

Сохраняйте этот процесс в фоновом режиме, наблюдая и перекомпилируя при внесении изменений.

Затем конвертируйте ваши текущие файлы JavaScript в TypeScript. Так как
TypeScript - это супер-набор ECMAScript 2015, который, в свою очередь, является супер-набором
ECMAScript 5, вы можете просто переключать расширения файлов с  `.js`  к  `.ts` 
и все будет работать так же, как и раньше. Как компилятор TypeScript
работает, он испускает соответствующий  `.js`  файл для каждого  `.ts`  файл и
скомпилированный JavaScript - это то, что фактически выполняется. Если вы начнете
HTTP-сервер проекта с `npm start`, вы должны увидеть полностью работоспособный
приложение в вашем браузере.

Теперь, когда у вас есть TypeScript, вы можете начать пользоваться некоторыми из них
функции. Язык имеет большое значение для приложений AngularJS.

С одной стороны, TypeScript - это расширенный набор ES2015. Любое приложение, которое ранее
был написан на ES5 - как в примере PhoneCat - может с TypeScript
начать включать все функции JavaScript, которые являются новыми для ES2015.
К ним относятся такие вещи, как  `let`  с  `const`  s, функции стрелок, функция по умолчанию
параметры и деструктурирующие задания.

Еще одна вещь, которую вы можете сделать, это начать добавлять *безопасность типов* в ваш код. Это имеет
фактически частично это уже произошло из-за установленных вами AngularJS-типов.
TypeScript проверяет, правильно ли вы вызываете API AngularJS
такие вещи, как регистрация компонентов в Angular модулях.

Но вы также можете начать добавлять *аннотации типов,* чтобы получить еще больше
вне системы типов TypeScript. Например, вы можете аннотировать галочку
фильтр, так что он явно ожидает логические значения в качестве аргументов. Это делает это понятнее
что фильтр должен делать.

<code-example path="upgrade-phonecat-1-typescript/app/core/checkmark/checkmark.filter.ts" header="app/core/checkmark/checkmark.filter.ts">
</code-example>

в  `Phone`  служба, вы можете явно аннотировать  `$resource`  службы зависимости
как  `angular.resource.IResourceService`  - тип, определенный типизацией AngularJS.

<code-example path="upgrade-phonecat-1-typescript/app/core/phone/phone.service.ts" header="app/core/phone/phone.service.ts">
</code-example>

Вы можете применить тот же трюк к файлу конфигурации маршрута приложения в  `app.config.ts`,
где вы используете местоположение и маршрутные услуги. Путем аннотирования их соответственно TypeScript
можете убедиться, что вы вызываете их API с правильными аргументами.

<code-example path="upgrade-phonecat-1-typescript/app/app.config.ts" header="app/app.config.ts">
</code-example>

<div class="alert is-helpful">

В [AngularJS 1.X типа определений](https://www.npmjs.com/package/@types/angular)
Вы не установлены официально командой Angular
но довольно всеобъемлющие. Можно создать приложение AngularJS 1.x
полностью аннотированный с помощью этих определений.

Если это то, что вы хотели сделать, было бы неплохо включить
 `noImplicitAny` опция конфигурации в  `tsconfig.json`  . Это бы
заставить компилятор TypeScript отображать предупреждение, когда есть какой-либо код
еще не имеет аннотации типа. Вы можете использовать его в качестве руководства для информирования
о том, насколько вы близки к полностью аннотированному проекту.

</div>

Еще одна особенность TypeScript, которую вы можете использовать - это *классы*. В частности, вы
может превратить контроллеры компонентов в классы. Таким образом, они будут шагом
ближе к становлению Angular компонентов классов, которые сделают жизнь
легче, как только вы обновитесь.

AngularJS ожидает, что контроллеры будут функциями конструктора. Это именно то, что
Классы ES2015 / TypeScript находятся внутри, так что это означает, что вы можете просто подключить
класс как компонентный контроллер, и AngularJS с удовольствием его использует.

Вот то, что новый класс для списка телефонов компонентов выглядит контроллер, как:

<code-example path="upgrade-phonecat-1-typescript/app/phone-list/phone-list.component.ts" header="app/phone-list/phone-list.component.ts">
</code-example>

То, что раньше было сделано в функции контроллера, теперь делается в классе
функция конструктора. Аннотации внедрения зависимостей прилагаются
в класс с использованием статического свойства  `$inject`  . Во время выполнения это становится
 `PhoneListController.$inject` свойство.

Класс дополнительно объявляет трех членов: массив телефонов, имя
текущий ключ сортировки и поисковый запрос. Это все, что у вас уже есть
подключался к контроллеру, но это нигде не было явно объявлено.
Последний из них на самом деле не используется в коде TypeScript, поскольку он только
упоминается в шаблоне, но для ясности вы должны определить все
члены контроллера.

В подробном контроллере телефона у вас будет два участника: один для телефона
что пользователь смотрит, а другой для URL отображаемого в данный момент изображения:

<code-example path="upgrade-phonecat-1-typescript/app/phone-detail/phone-detail.component.ts" header="app/phone-detail/phone-detail.component.ts">
</code-example>

Это делает код контроллера уже более похожим на Angular. Ты
все готово для внедрения Angular в проект.

Если у вас есть какие-либо сервисы AngularJS в проекте, они также будут
хороший кандидат для преобразования классов, так как контроллеры,
они также функции конструктора. Но у вас есть только  `Phone`  фабрика
в этом проекте, и это немного особенное, так как это  `ngResource` 
завод. Таким образом, вы не будете ничего делать с ним на стадии подготовки.
Вместо этого вы превратите его непосредственно в сервис Angular.

{@a installing-angular}
### Установка Angular

Закончив подготовительные работы, приступайте к работе с Angular
обновление PhoneCat. Вы будете делать это постепенно с помощью
[ngUpgrade](#upgrading-with-ngupgrade)который поставляется с Angular.
К тому времени, как вы закончите, вы сможете удалить AngularJS из проекта
полностью, но ключ в том, чтобы сделать это по частям, не нарушая приложения.

<div class="alert is-important">

Проект также содержит некоторые анимации.
Вы не будете обновлять их в этой версии руководства.
Обратитесь к руководству [Angular Animation](guide/animations)чтобы узнать об этом.

</div>

Установите Angular в проект вместе с загрузчиком модулей SystemJS.
Посмотрите на результаты [инструкции по установке обновления](guide/upgrade-setup)
и получить следующие конфигурации оттуда:

* Добавьте Angular и другие новые зависимости в  `package.json` 
* Файл конфигурации SystemJS  `systemjs.config.js`  в корневой каталог проекта.

После того, как это делается, выполните:

<code-example format="">
  npm install
</code-example>

Вскоре вы можете загрузить Angular-зависимости в приложение через  `index.html`,
но сначала вам нужно сделать некоторые корректировки пути к каталогу.
Вам нужно будет загрузить файлы из  `node_modules`  и корень проекта вместо
от  `/app`  каталог как вы делали до этого момента.

Переместить  `app/index.html`  файл в корневой каталог проекта. Тогда поменяй
корневой путь сервера разработки в  `package.json`  также указывает на корневой каталог проекта
вместо того  `app`  :

<code-example format="">
  "start": "http-server ./ -a localhost -p 8000 -c-1",
</code-example>

Теперь вы можете обслуживать все, от корня проекта до веб-браузера. Но ты *не*
хотите изменить все изображения и пути к данным, используемые в коде приложения, чтобы они соответствовали
настройка разработки. По этой причине вы добавите  `<base>`  тег для  `index.html`, который будет
вызвать относительные URL-адреса обратно к  `/app`  каталога:

<code-example path="upgrade-phonecat-2-hybrid/index.html" region="base" header="index.html">
</code-example>

Теперь вы можете загрузить Angular через SystemJS. Вы добавите Angular заполнитель и
Конфигурация SystemJS до конца  `<head>`  раздел, и тогда вы будете использовать  `System.import` 
загрузить само приложение:

<code-example path="upgrade-phonecat-2-hybrid/index.html" region="angular" header="index.html">
</code-example>

Вам также необходимо внести пару корректировок
к  `systemjs.config.js`  Файл установленный во время [настройка обновления](guide/upgrade-setup).

При загрузке файлов через SystemJS укажите браузер на корневой каталог проекта
вместо использования  `<base>`  URL.

Установите  `upgrade`  пакет через `npm install @angular/upgrade --save` 
и добавьте отображение для  `@angular/upgrade/static`  package.

<code-example path="upgrade-phonecat-2-hybrid/systemjs.config.1.js" region="paths" header="systemjs.config.js">
</code-example>

{@a creating-the-appmodule}
### Создание _AppModule_

Теперь создайте рут  `NgModule`  Класс называется  `AppModule`.
Уже есть файл с именем  `app.module.ts`  который содержит модуль AngularJS.
Переименуйте его в  `app.module.ajs.ts`  и обновите имя соответствующего скрипта в  `index.html`  также.
Содержимое файла остается:

<code-example path="upgrade-phonecat-2-hybrid/app/app.module.ajs.ts" header="app.module.ajs.ts">
</code-example>

Теперь создайте новый  `app.module.ts`  с минимальным  `NgModule`  класс:

<code-example path="upgrade-phonecat-2-hybrid/app/app.module.ts" region="bare" header="app.module.ts">
</code-example>

{@a bootstrapping-a-hybrid-phonecat}
### Самозагрузка гибридного PhoneCat

Далее вы загрузите приложение как *гибридное приложение*
который поддерживает компоненты AngularJS и Angular. После этого
Вы можете начать преобразование отдельных частей в Angular.

Приложение в настоящее время загружается с помощью AngularJS  `ng-app`  директива
прикреплен к  `<html>`  элемент страницы хоста. Это больше не будет работать в гибриде
приложение. Переключение на [самозагрузки ngUpgrade](#bootstrapping-hybrid-applications)метода
вместо.

Сначала удалите  `ng-app`  атрибут from  `index.html`.
Затем импортировать  `UpgradeModule`  в  `AppModule`  и переопределить его  `ngDoBootstrap`  метод:

<code-example path="upgrade-phonecat-2-hybrid/app/app.module.ts" region="upgrademodule" header="app/app.module.ts">
</code-example>

Обратите внимание, что вы загружаете модуль AngularJS изнутри  `ngDoBootstrap`.
Аргументы такие же, как вы могли бы передать  `angular.bootstrap`  если вы были вручную
начальная загрузка AngularJS: корневой элемент приложения; и массив
AngularJS 1.Модули x, которые вы хотите загрузить.

Наконец, загрузите  `AppModule`  в  `app/main.ts`.
Этот файл был настроен как точка входа приложения в  `systemjs.config.js`,
поэтому он уже загружается браузером.

<code-example path="upgrade-phonecat-2-hybrid/app/main.ts" region="bootstrap" header="app/main.ts">
</code-example>

Теперь вы используете одновременно AngularJS и Angular. Это мило
захватывающий! Вы еще не используете какие-либо фактические компоненты Angular. Это следующее.

<div class="alert is-helpful">

{@a why-declare-angular-as-angular.iangularstatic}
#### Зачем объявлять _angular_ как _angular.IAngularStatic_?

 `@types/angular` объявлено как модуль UMD, и из-за пути
<a href="https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#support-for-umd-module-definitions">UMD печатает </a>
работать, если у вас есть ES6  `import`  оператор в файле также должен содержать все модули UMD
импортируется через  `import`  операторы вместо того, чтобы быть глобально доступным.

AngularJS в настоящее время загружается тегом script в  `index.html`, что означает, что все приложение
имеет доступ к нему как к глобальному и использует тот же экземпляр  `angular`  переменная.
Если вы использовали `import * as angular from 'angular'`, вам также придется
загрузите каждый файл в приложении AngularJS, чтобы использовать модули ES2015, чтобы обеспечить работу AngularJS
загружен правильно.

Это значительное усилие, и оно часто того не стоит, тем более что вы в
процесс перемещения вашего кода в Angular.
Вместо этого объявить  `angular`  как  `angular.IAngularStatic`  чтобы указать, что это глобальная переменная
и до сих пор есть полная поддержка набора текста.

</div>

{@a upgrading-the-phone-service}
### Обновление телефонного сервиса

Первая часть, которую вы перенесете на Angular, это  `Phone`  служба, которая
проживает в  `app/core/phone/phone.service.ts`  и делает это возможным для компонентов
загрузить информацию о телефоне с сервера. Прямо сейчас это реализовано с
ngResource и вы используете его для двух вещей:

* Для загрузки списка всех телефонов в компонент списка телефонов.
* Для загрузки информации об одном телефоне в компонент телефона.

Вы можете заменить эту реализацию классом обслуживания Angular, в то время как
сохраняя контроллеры на земле AngularJS.

В новой версии вы импортируете модуль Angular HTTP и вызываете его  `HttpClient`  вместо  `ngResource`.

Снова откройте  `app.module.ts`  файл, импорт и добавление  `HttpClientModule`  для  `imports`  массив  `AppModule`  :

<code-example path="upgrade-phonecat-2-hybrid/app/app.module.ts" region="httpclientmodule" header="app.module.ts">
</code-example>

Теперь вы готовы обновить сам телефон. Заменить на основе ngResource
служба в  `phone.service.ts`  с классом TypeScript, оформленным как  `@Injectable`  :

<code-example path="upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts" region="classdef" header="app/core/phone/phone.service.ts (skeleton)"></code-example>

 `@Injectable` декоратор будет прикреплять некоторые метаданные внедрения зависимости
к классу, давая Angular знать о его зависимостях. Как описано
по [Dependency Injection Guide](guide/dependency-injection),
это маркерный декоратор, который нужно использовать для классов, которые не имеют других
Angular декораторы, но по-прежнему необходимо вводить их зависимости.

В своем конструкторе класс ожидает получить  `HttpClient`  . Будет
быть введен в него, и он сохраняется как личное поле. Служба тогда
используется в двух методов экземпляра, один из которых загружает список всех телефонов,
и другие нагрузки на детали указанного телефона:

<code-example path="upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts" region="fullclass" header="app/core/phone/phone.service.ts">
</code-example>

Методы теперь возвращают наблюдаемые типа  `PhoneData`  и  `PhoneData[]`  . Это
тип у вас еще нет. Добавьте простой интерфейс для этого:

<code-example path="upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts" region="phonedata-interface" header="app/core/phone/phone.service.ts (interface)"></code-example>

 `@angular/upgrade/static ` имеет ` downgradeInjectable` метод с целью создания
Услуги Angular доступны для кода AngularJS. Используйте его для подключения  `Phone`  службы:

<code-example path="upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts" region="downgrade-injectable" header="app/core/phone/phone.service.ts (downgrade)"></code-example>

Вот полный, окончательный код для службы:

<code-example path="upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts" header="app/core/phone/phone.service.ts">
</code-example>

Обратите внимание, что вы импортируете  `map`  оператор RxJS  `Observable`  отдельно.
Сделайте это для каждого оператора RxJS.

Новый  `Phone`  сервис имеет те же функции, что и оригинал,  `ngResource`  основе.
Поскольку это услуга Angular, вы регистрируете ее в  `NgModule`  провайдеры:

<code-example path="upgrade-phonecat-2-hybrid/app/app.module.ts" region="phone" header="app.module.ts">
</code-example>

Теперь, когда вы загружаете  `phone.service.ts`  через импорт, который решен
SystemJS, вы должны **удалить тег <script>** для службы из  `index.html`.
Это то, что вы будете делать со всеми компонентами при их обновлении. Одновременно
с обновлением AngularJS до Angular вы также переносите код из скриптов в модули.

На этом этапе вы можете переключить два компонента для использования нового сервиса
вместо старого. Пока ты  `$inject`  как пониженный  `phone`  фабрика
это действительно пример  `Phone`  класс и аннотированный его тип соответственно:

<code-example path="upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ajs.ts" header="app/phone-list/phone-list.component.ts">
</code-example>

<code-example path="upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.ajs.ts" header="app/phone-detail/phone-detail.component.ts">
</code-example>

Теперь есть два компонента AngularJS, использующие сервис Angular!
Компоненты не должны знать об этом, хотя тот факт, что
Служба возвращает наблюдаемые, а не обещания, что-то вроде дешевой распродажи.
В любом случае вы добились миграции сервиса на Angular
без необходимости еще переносить компоненты, которые его используют.

<div class="alert is-helpful">

Вы могли бы использовать  `toPromise`  способ  `Observable` чтобы превратить тех
Наблюдаемые в обещания в службе. Во многих случаях это уменьшается
количество изменений в контроллерах компонентов.

</div>

{@a upgrading-components}
### Обновление компонентов

Затем обновите компоненты AngularJS до компонентов Angular.
Делайте это по одному компоненту за раз, сохраняя приложение в гибридном режиме.
Выполняя эти преобразования, вы также определите свои первые Angular *трубы*.

Сначала посмотрите на список телефонов. Прямо сейчас он содержит TypeScript
класс контроллера и объект определения компонента. Вы можете превратить это в
Angular компонент, просто переименовывая класс контроллера и поворачивая
AngularJS компонент определения объекта в Angular  `@Component`  декоратор.
Затем вы также можете удалить статический  `$inject`  свойства из класса:

<code-example path="upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts" region="initialclass" header="app/phone-list/phone-list.component.ts">
</code-example>

 `selector` Атрибут - это селектор CSS, который определяет, где на странице находится компонент
должны идти. В AngularJS вы делаете сопоставление на основе имен компонентов, но в Angular вы
есть эти явные селекторы. Этот будет соответствовать элементам с именем  `phone-list`,
как и в версии AngularJS.

Теперь преобразуйте шаблон этого компонента в Angular синтаксис.
Элементы управления поиском заменяют AngularJS  `$ctrl`  выражений
с двухсторонним Angular  `[(ngModel)]`  связывание Синтаксис:

<code-example path="upgrade-phonecat-2-hybrid/app/phone-list/phone-list.template.html" region="controls" header="app/phone-list/phone-list.template.html (search controls)"></code-example>

Заменить список  `ng-repeat`  с  `*ngFor`  как
[описано на странице «Синтаксис шаблона»](guide/template-syntax#directives).
Заменить тег изображения  `ng-src`  с привязкой к родной  `src`  свойство.

<code-example path="upgrade-phonecat-2-hybrid/app/phone-list/phone-list.template.html" region="list" header="app/phone-list/phone-list.template.html (phones)"></code-example>

{@a no-angular-filter-or-orderby-filters}
#### Нет Angular _filter_ или _orderBy_ фильтров

Встроенный AngularJS  `filter`  и  `orderBy`  Фильтры не существуют в Angular
так что вам нужно сделать фильтрацию и сортировку самостоятельно.

Вы заменили  `filter`  и  `orderBy`  Фильтры с привязками к  `getPhones()`  контроллера
который реализует логику фильтрации и упорядочения внутри самого компонента.

<code-example path="upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts" region="getphones" header="app/phone-list/phone-list.component.ts">
</code-example>

Теперь вам нужно понизить компонент Angular, чтобы вы могли использовать его в AngularJS.
Вместо регистрации компонента, вы регистрируете  `phoneList`   *директива*,
пониженная версия Angular компонента.

 `as angular.IDirectiveFactory` сообщает компилятору TypeScript
что возвращаемое значение  `downgradeComponent`  Метод является фабрикой директив.

<code-example path="upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts" region="downgrade-component" header="app/phone-list/phone-list.component.ts">
</code-example>

Новый  `PhoneListComponent`  использует Angular  `ngModel`  директива, расположенная в  `FormsModule`.
Добавить  `FormsModule`  to  `NgModule`  импортирует, объявляет новый  `PhoneListComponent`  и
наконец, добавьте его в  `entryComponents`  так как Вы понизили его:

<code-example path="upgrade-phonecat-2-hybrid/app/app.module.ts" region="phonelist" header="app.module.ts">
</code-example>

Удалите тег <script> для компонента списка телефонов из  `index.html`.

Теперь установите оставшиеся  `phone-detail.component.ts`  следующим образом :

<code-example path="upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.ts" header="app/phone-detail/phone-detail.component.ts">
</code-example>

Это похоже на компонент списка телефонов.
Новая морщина это  `RouteParams`  типа которая идентифицирует  `routeParams`  Зависимость.

Инжектор AngularJS имеет зависимость от маршрутизатора AngularJS, которая называется  `$routeParams`,
который был введен в  `PhoneDetails`  когда он все еще был контроллером AngularJS.
Вы намерены ввести его в новый  `PhoneDetailsComponent`.

К сожалению, зависимости AngularJS не доступны автоматически для компонентов Angular.
Вы должны обновить эту услугу через [заводской провайдер](guide/upgrade#making-angularjs-dependencies-injectable-to-angular)
делать  `$routeParams`  Angular инъекция.
Сделайте это в новом файле с именем  `ajs-upgraded-providers.ts`  и импортировать его в  `app.module.ts`  :

<code-example path="upgrade-phonecat-2-hybrid/app/ajs-upgraded-providers.ts" header="app/ajs-upgraded-providers.ts">
</code-example>

<code-example path="upgrade-phonecat-2-hybrid/app/app.module.ts" region="routeparams" header="app/app.module.ts ($routeParams)"></code-example>

Преобразовать шаблон компонента телефона подробно в Angular синтаксис выглядит следующим образом :

<code-example path="upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.template.html" header="app/phone-detail/phone-detail.template.html">
</code-example>

Есть несколько заметных изменений здесь:

* Вы удалили  `$ctrl.`  префикс из всех выражений.

* Вы заменили  `ng-src`  с собственностью
  привязки для стандарта  `src`  свойство.

* Вы используете синтаксис привязки свойств вокруг  `ng-class`  . Хоть и Angular
  действительно имеет [очень похожий  `ngClass` ](guide/template-syntax#directives)
  как и AngularJS, его значение магическим образом не оценивается как выражение.
  В Angular вы всегда указываете в шаблоне значение атрибута
  выражение свойства, в отличие от литеральной строки.

* Вы заменили  `ng-repeat`  с  `*ngFor`  с.

* Вы заменили  `ng-click`  с привязкой события для стандарта  `click`.

* Вы завернули весь шаблон в  `ngIf`  это только вызывает
  отображается при наличии телефона. Вам это нужно, потому что, когда компонент
  первые загрузки, у вас нет  `phone`  еще и выражения будут относиться к
  несуществующее значение. В отличие от AngularJS, Angular выражения не работают молча
  при попытке обратиться к свойствам неопределенных объектов. Вы должны быть явными
  о случаях, когда это ожидается.

добавлять  `PhoneDetailComponent`  Компонент для  `NgModule`  _declarations_ и _entryComponents_:

<code-example path="upgrade-phonecat-2-hybrid/app/app.module.ts" region="phonedetail" header="app.module.ts">
</code-example>

Теперь вы должны также удалить тег <script> компонента сведений о телефоне из  `index.html`.

{@a add-the-checkmarkpipe}
#### Добавьте _CheckmarkPipe_

Директива AngularJS имела  `checkmark`  _filter_.
Преврати это в Angular **трубу**.

Не существует метода обновления для преобразования фильтров в трубы.
Вы не пропустите это.
Легко превратить функцию фильтра в эквивалентный класс Pipe.
Реализация такая же, как и раньше, переупакована в  `transform`  метод.
Переименуйте файл в  `checkmark.pipe.ts`  в соответствии с Angularи конвенциями:

<code-example path="upgrade-phonecat-2-hybrid/app/core/checkmark/checkmark.pipe.ts" header="app/core/checkmark/checkmark.pipe.ts"></code-example>

Теперь импортируйте и объявите вновь созданный канал и
удалить тег <script> фильтра из  `index.html`  :

<code-example path="upgrade-phonecat-2-hybrid/app/app.module.ts" region="checkmarkpipe" header="app.module.ts">
</code-example>

{@a aot-compile-the-hybrid-app}
### AOT скомпилировать гибридное приложение

Чтобы использовать AOT с гибридным приложением, вы должны сначала настроить его, как любое другое приложение Angular
как показано в [глава «Опережающее время»](guide/aot-compiler).

Тогда поменяй  `main-aot.ts`  для начальной загрузки  `AppComponentFactory`  который был создан
по АОТУ компилятор:

<code-example path="upgrade-phonecat-2-hybrid/app/main-aot.ts" header="app/main-aot.ts">
</code-example>

Вам нужно загрузить все файлы AngularJS, которые вы уже используете в  `index.html`  в  `aot/index.html` 
а также:

<code-example path="upgrade-phonecat-2-hybrid/aot/index.html" header="aot/index.html">
</code-example>

Эти файлы необходимо скопировать вместе с полифилами. Файлы приложения
необходимо во время выполнения, как  `.json`  телефонов и изображения также необходимо скопировать.

устанавливать  `fs-extra`  через `npm install fs-extra --save-dev` для лучшего копирования и изменения файлов
 `copy-dist-files.js` к следующему:

<code-example path="upgrade-phonecat-2-hybrid/copy-dist-files.js" header="copy-dist-files.js">
</code-example>

И это все, что вам нужно, чтобы использовать AOT при обновлении вашего приложения!

{@a adding-the-angular-router-and-bootstrap}
### Добавление Angular маршрутизатора и начальной загрузки

На этом этапе вы заменили все компоненты приложения AngularJS на
их аналоги Angular, даже если вы по-прежнему обслуживаете их с маршрутизатора AngularJS.

{@a add-the-angular-router}
#### Добавьте Angular маршрутизатор

Angular имеет [совершенно новый маршрутизатор](guide/router).

Как и всем маршрутизаторам, ему нужно место в пользовательском интерфейсе для отображения маршрутизированных представлений.
Для Angular это  `<router-outlet>` и она принадлежит *корневому компоненту*
в верхней части дерева компонентов приложения.

У вас еще нет такого корневого компонента, потому что приложение по-прежнему управляется как приложение AngularJS.
Создать новый  `app.component.ts`  файл со следующим  `AppComponent`  класс:

<code-example path="upgrade-phonecat-3-final/app/app.component.ts" header="app/app.component.ts">
</code-example>

Он имеет простой шаблон, который включает в себя только  `<router-outlet>`.
Этот компонент просто отображает содержимое активного маршрута и ничего больше.

Селектор сообщает Angular подключить этот корневой компонент к  `<phonecat-app>` 
элемент на веб-странице хоста при запуске приложения.

Добавь это  `<phonecat-app>`  для  `index.html`.
Он заменяет старый AngularJS  `ng-view`  директивы:

<code-example path="upgrade-phonecat-3-final/index.html" region="appcomponent" header="index.html (body)"></code-example>

{@a create-the-routing-module}
#### Создайте модуль маршрутизации
Маршрутизатор нуждается в настройке, будь то AngularJS, Angular или любой другой маршрутизатор.

Подробные сведения о конфигурации Angular маршрутизатора лучше оставить [документация по маршрутизации](guide/router)
который рекомендует вам создать  `NgModule`  посвященный настройке маршрутизатора
(называется _Routing Module_).

<code-example path="upgrade-phonecat-3-final/app/app-routing.module.ts" header="app/app-routing.module.ts">
</code-example>

Этот модуль определяет  `routes`  объекта с двумя маршрутами к двум компонентам телефона
и маршрут по умолчанию для пустого пути.
Это проходит  `routes`  к  `RouterModule.forRoot`  метод, который делает все остальное.

Несколько дополнительных провайдеров включают маршрутизацию с «хэш» URL, такими как  `#!/phones` 
вместо принятой по умолчанию стратегии "push state".

Теперь обновите  `AppModule`  для импорта этого  `AppRoutingModule`  а также
объявить корень  `AppComponent`  как компонент начальной загрузки.
Это говорит Angular, что он должен загрузить приложение с помощью _root_  `AppComponent`  и
вставьте его вид на веб-страницу хоста.

Вы также должны удалить загрузчик модуля AngularJS из  `ngDoBootstrap()`  в  `app.module.ts` 
и  `UpgradeModule`  импорт.

<code-example path="upgrade-phonecat-3-final/app/app.module.ts" header="app/app.module.ts">
</code-example>

И так как вы направляетесь в  `PhoneListComponent`  и  `PhoneDetailComponent`  напрямую, а не
используя шаблон маршрута с  `<phone-list>`  или  `<phone-detail>`  тег, вы можете покончить со своими
Angular селекторы также.

{@a generate-links-for-each-phone}
#### Генерация ссылок для каждого телефона

Вам больше не нужно жестко кодировать ссылки на телефонные данные в списке телефонов.
Вы можете создавать привязки данных для каждого телефона  `id`  в  `routerLink`  директива
и пусть эта директива создаст соответствующий URL для  `PhoneDetailComponent`  :

<code-example path="upgrade-phonecat-3-final/app/phone-list/phone-list.template.html" region="list" header="app/phone-list/phone-list.template.html (list with links)"></code-example>

<div class="alert is-helpful">

Смотрите [Маршрутизация](guide/router)страницу для деталей.

</div><br>

{@a use-route-parameters}
#### Используйте параметры маршрута

Маршрутизатор Angular передает параметры маршрута по-разному.
Исправить  `PhoneDetail`  компонента ожидает  `ActivatedRoute` Объект.
Извлечь  `phoneId`  от  `ActivatedRoute.snapshot.params`  и извлечения данных телефона, как раньше:

<code-example path="upgrade-phonecat-3-final/app/phone-detail/phone-detail.component.ts" header="app/phone-detail/phone-detail.component.ts">
</code-example>

Теперь вы работаете с чисто Angular приложением!

{@a say-goodbye-to-angularjs}
### Попрощайся с AngularJS

Пришло время снять учебные колеса и начать приложение
его новая жизнь в виде чистого, блестящего Angular приложения. Остальные задачи все должны
делать с удалением кода - что, конечно, любимая задача каждого программиста!

Приложение по-прежнему загружается как гибридное приложение.
В этом больше нет необходимости.

Переключите метод начальной загрузки приложения из  `UpgradeModule` для Angular пути.

<code-example path="upgrade-phonecat-3-final/app/main.ts" header="main.ts">
</code-example>

Если вы этого еще не сделали, удалите все ссылки на  `UpgradeModule`  от  `app.module.ts`,
как и любой [заводской провайдер](guide/upgrade#making-angularjs-dependencies-injectable-to-angular)
для услуг AngularJS, и  `app/ajs-upgraded-providers.ts`.

Также удалите все  `downgradeInjectable()`  или  `downgradeComponent()`  вы найдете
вместе с соответствующими заводскими или директивными декларациями AngularJS.
Поскольку у вас больше нет устаревших компонентов, вы больше не перечисляете их
в  `entryComponents`.

<code-example path="upgrade-phonecat-3-final/app/app.module.ts" header="app.module.ts">
</code-example>

Вы также можете полностью удалить следующие файлы. Это AngularJS
модуль файлы конфигурации и не требуется в угловому:

*  `app/app.module.ajs.ts` 
*  `app/app.config.ts` 
*  `app/core/core.module.ts` 
*  `app/core/phone/phone.module.ts` 
*  `app/phone-detail/phone-detail.module.ts` 
*  `app/phone-list/phone-list.module.ts` 

Внешние наборы для AngularJS также могут быть удалены. Единственные
вам все еще нужны жасминовые и Angular полифилы.
 `@angular/upgrade` Пакет и его отображение в  `systemjs.config.js`  также может идти.

<code-example format="">
  npm uninstall @angular/upgrade --save
  npm uninstall @types/angular @types/angular-animate @types/angular-cookies @types/angular-mocks @types/angular-resource @types/angular-route @types/angular-sanitize --save-dev
</code-example>

Наконец, из  `index.html`, удалите все ссылки на скрипты AngularJS и jQuery.
Когда вы закончите, это то, что он должен выглядеть следующим образом :

<code-example path="upgrade-phonecat-3-final/index.html" region="full" header="index.html">
</code-example>

Это последнее, что вы увидите в AngularJS! Это послужило нам хорошо, но сейчас
пришло время прощаться.

{@a appendix-upgrading-phonecat-tests}
## Приложение: Обновление тестов PhoneCat

Тесты можно не только сохранить в процессе обновления, но они также могут быть сохранены
используется в качестве ценной меры безопасности при обеспечении того, что приложение не делает
перерыв во время обновления. Тесты E2E особенно полезны для этой цели.

{@a e2e-tests}
### Тесты E2E

В проекте PhoneCat есть как тесты E2E Protractor, так и некоторые модульные тесты Karma.
Из этих двух E2E тесты могут быть решены гораздо проще: по определению
Тесты E2E обращаются к приложению *извне*, взаимодействуя с ним
различные элементы интерфейса, которые приложение выводит на экран. Тесты E2E на самом деле не такие
касается внутренней структуры компонентов приложения. Это
также означает, что, хотя вы вносите в проект небольшие изменения, E2E
Тестовый набор должен продолжать проходить с небольшими изменениями. Вы
не изменилось поведение приложения с точки зрения пользователя.

Во время преобразования TypeScript нечего делать, чтобы сохранить тесты E2E
работает. Но при изменении начальной загрузки к тому, что гибридного приложения,
Вы должны сделать несколько изменений.

Обновите  `protractor-conf.js`  для синхронизации с гибридными приложениями:

<code-example format="">
  ng12Hybrid: true
</code-example>

Когда вы начнете обновлять компоненты и их шаблоны до Angular, вы внесете больше изменений
потому что тесты E2E имеют сопоставления, специфичные для AngularJS.
Для PhoneCat вам необходимо сделать следующие изменения для того, чтобы заставить вещи работать с Angularи:

<table>
  <tr>
    <th>
      Предыдущий код
    </th>
    <th>
      Новый код
    </th>
    <th>
      Примечания
    </th>
  </tr>
  <tr>
    <td>

       `by.repeater('phone in $ctrl.phones').column('phone.name')` 

    </td>
    <td>

       `by.css('.phones .name')` 

    </td>
    <td>

      Повторитель повторителей полагается на AngularJS  `ng-repeat` 

    </td>
  </tr>
  <tr>
    <td>

       `by.repeater('phone in $ctrl.phones')` 

    </td>
    <td>

       `by.css('.phones li')` 

    </td>

    <td>

      Повторитель повторителей полагается на AngularJS  `ng-repeat` 

    </td>
  </tr>
  <tr>
    <td>

       `by.model('$ctrl.query')` 

    </td>
    <td>

       `by.css('input')` 

    </td>
    <td>

      Модель соответствия основывается на AngularJS  `ng-model` 

    </td>
  </tr>
  <tr>
    <td>

       `by.model('$ctrl.orderProp')` 

    </td>
    <td>

       `by.css('select')` 

    </td>
    <td>

      Модель соответствия основывается на AngularJS  `ng-model` 

    </td>
  </tr>
  <tr>
    <td>

       `by.binding('$ctrl.phone.name')` 

    </td>
    <td>

       `by.css('h1')` 

    </td>
    <td>

      Сопоставление привязки опирается на привязку данных AngularJS

    </td>
  </tr>
</table>

Когда метод начальной загрузки переключается с  `UpgradeModule`  для
чисто Angular, AngularJS перестает существовать на странице полностью.
На данный момент, вы должны сказать транспортиру, что он не должен искать
приложение AngularJS больше, но вместо этого оно должно найти *приложения Angular* от
страница.

Заменить  `ng12Hybrid`  ранее добавлен со следующим в  `protractor-conf.js`  :

<code-example format="">
  useAllAngular2AppRoots: true,
</code-example>

Кроме того, в тестовом коде PhoneCat есть несколько вызовов API Protractor
используете AngularJS  `$location`  сервис под капотом. Как то
после обновления сервис больше не присутствует, замените эти звонки на звонки
которые используют общие URL-интерфейсы WebDriver. Первый из них
переназначение спецификации:

<code-example path="upgrade-phonecat-3-final/e2e-spec.ts" region="redirect" header="e2e-tests/scenarios.ts">
</code-example>

И второе - спецификация телефонных ссылок

<code-example path="upgrade-phonecat-3-final/e2e-spec.ts" region="links" header="e2e-tests/scenarios.ts">
</code-example>

{@a unit-tests}
### Модульные тесты

Для юнит-тестов, с другой стороны, требуется больше работы по конвертации. Эффективно
они должны быть *обновлены* вместе с производственным кодом.

Во время преобразования TypeScript никаких изменений не требуется. Но это может быть
хорошая идея преобразовать код модульного теста также в TypeScript.

Например, в спецификации компонентов телефона вы можете использовать ES2015
такие функции, как функции стрелок и переменные в области блока, и преимущества от типа
определения услуг AngularJS вы потребляющие:

<code-example path="upgrade-phonecat-1-typescript/app/phone-detail/phone-detail.component.spec.ts" header="app/phone-detail/phone-detail.component.spec.ts">
</code-example>

После запуска процесса обновления и внесения SystemJS изменения конфигурации
нужны для кармы. Вы должны позволить SystemJS загрузить весь новый код Angular
что можно сделать с помощью следующего вида прокладки файла:

<code-example path="upgrade-phonecat-2-hybrid/karma-test-shim.1.js" header="karma-test-shim.js">
</code-example>

Сначала shim загружает конфигурацию SystemJS, затем библиотеки поддержки тестирования Angular
а затем сами спецификации файлов приложения.

Затем необходимо изменить конфигурацию Karma, чтобы она использовала корневой каталог приложения
в качестве базового каталога, а не  `app`.

<code-example path="upgrade-phonecat-2-hybrid/karma.conf.ajs.js" region="basepath" header="karma.conf.js">
</code-example>

После этого вы можете загрузить SystemJS и другие зависимости, а также переключить конфигурацию
для загрузки файлов приложений, чтобы *не* Карма добавляла их на страницу. Вы позволите
Шим и SystemJS загружают их.

<code-example path="upgrade-phonecat-2-hybrid/karma.conf.ajs.js" region="files" header="karma.conf.js">
</code-example>

Поскольку HTML-шаблоны компонентов Angular также будут загружены, вы должны помочь
Карма из немногих, так что он может направить их на право пути:

<code-example path="upgrade-phonecat-2-hybrid/karma.conf.ajs.js" region="html" header="karma.conf.js">
</code-example>

Сами файлы модульных тестов также должны быть переключены на Angular при их создании
аналоги меняются. Спецификации для канала с галочками, вероятно, самые простые
как труба не имеет зависимостей:

<code-example path="upgrade-phonecat-2-hybrid/app/core/checkmark/checkmark.pipe.spec.ts" header="app/core/checkmark/checkmark.pipe.spec.ts">
</code-example>

Модульный тест для телефонной службы немного сложнее. Вам нужно переключиться с макета
AngularJS  `$httpBackend`  на бэкэнд Angular Http.

<code-example path="upgrade-phonecat-2-hybrid/app/core/phone/phone.service.spec.ts" header="app/core/phone/phone.service.spec.ts">
</code-example>

Для спецификации компонентов, вы можете макетировать  `Phone`  Сам сервис, и пусть это обеспечит
консервированные данные телефона. Для обоих компонентов вы используете API модульного тестирования компонентов Angular.

<code-example path="upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.spec.ts" header="app/phone-detail/phone-detail.component.spec.ts">
</code-example>

<code-example path="upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.spec.ts" header="app/phone-list/phone-list.component.spec.ts">
</code-example>

И наконец, еще раз проверьте оба теста компонентов, когда вы переключаетесь на Angular
маршрутизатор. Для компонента детали, предоставьте макет Angular  `ActivatedRoute`  Объект
вместо использования AngularJS  `$routeParams`.

<code-example path="upgrade-phonecat-3-final/app/phone-detail/phone-detail.component.spec.ts" region="activatedroute" header="app/phone-detail/phone-detail.component.spec.ts">
</code-example>

А для компонента списка телефонов внесены некоторые изменения в маршрутизатор
 `RouteLink` Директивы работают.

<code-example path="upgrade-phonecat-3-final/app/phone-list/phone-list.component.spec.ts" region="routestuff" header="app/phone-list/phone-list.component.spec.ts">
</code-example>
