{@a form-validation}
# Проверка формы




Улучшите общее качество данных, проверяя вводимые пользователем данные на предмет точности и полноты.

На этой странице показано, как проверить пользовательский ввод в пользовательском интерфейсе и отобразить полезные сообщения проверки
используя как реактивные, так и управляемые шаблонами формы. Это предполагает некоторые базовые знания двух
модули форм.

<div class="alert is-helpful">

Если вы новичок в формах, начните с просмотра [Формы](guide/forms)и
[Реактивные формы](guide/reactive-forms)руководства.

</div>


{@a template-driven-validation}
## Проверка на основе шаблонов

Чтобы добавить проверку в форму на основе шаблона, вы добавляете те же атрибуты проверки, что и вы
будет с [собственная проверка формы HTML](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation).
Angular использует директивы для сопоставления этих атрибутов с функциями валидатора в каркасе.

Каждый раз, когда значение элемента управления формы изменяется, Angular запускает проверку и генерирует
либо список ошибок валидации, который приводит к статусу INVALID, либо null, который приводит к статусу VALID.

Затем вы можете проверить состояние элемента управления, экспортируя `ngModel` для локальной переменной шаблона.
Следующий пример экспорта `NgModel` в переменную с именем `name` :

<code-example path="form-validation/src/app/template/hero-form-template.component.html" region="name-with-error-msg" header="template/hero-form-template.component.html (name)"></code-example>


Обратите внимание на следующее:

* `<input>` Элемент содержит атрибуты проверки HTML: `required` и `minlength` . Это
также несет пользовательскую директиву валидатора, `forbiddenName` . Для большего
информацию смотрите в разделе [Пользовательские валидаторы](guide/form-validation#custom-validators).

* `#name="ngModel" ` exports ` NgModel` в локальную переменную с именем `name` . `NgModel` отражает многие свойства своего базового
 `FormControl`, так что вы можете использовать это в шаблоне для проверки состояний управления, таких как `valid` и `dirty` . Полный список свойств элемента управления см. В [AbstractControl](api/forms/AbstractControl)
Справочник по API.

* `*ngIf ` на ` <div>` элемент показывает набор вложенных сообщений `divs` 
но только если `name` неверно и элемент управления `dirty` или `touched`.

* Каждый вложенный `<div>` может представить пользовательское сообщение для одной из возможных ошибок проверки.
Есть сообщения для `required`, `minlength` и `forbiddenName`.


<div class="alert is-helpful">



{@a why-check-dirty-and-touched}
#### Зачем проверять _dirty_ и _touched_?

Возможно, вы не захотите, чтобы ваше приложение отображало ошибки, прежде чем пользователь сможет изменить форму.
Чеки для `dirty` и `touched` чтобы предотвратить отображение ошибок до пользователя
делает одно из двух: изменяет значение,
грязное управление; или размывает элемент управления формы, устанавливая элемент управления на касание.

</div>

{@a reactive-form-validation}
## Реактивная проверка формы

В реактивной форме источником истины является класс компонентов. Вместо того, чтобы добавлять валидаторы через атрибуты в шаблоне, вы добавляете функции валидатора непосредственно в модель управления формой в классе компонента. Затем Angular вызывает эти функции всякий раз, когда значение элемента управления изменяется.

{@a validator-functions}
### Функции валидатора

Существует два типа функций валидатора: валидаторы синхронизации и асинхронные валидаторы.

* **Синхронизировать валидаторы**: функции, которые берут экземпляр управления и немедленно возвращают либо набор ошибок валидации, либо `null` . Вы можете передать их в качестве второго аргумента при создании экземпляра `FormControl`.

* **Асинхронные валидаторы элемента**: функции, которые принимают экземпляр управления и возвращают Promise
или наблюдаемый, который позже выдает набор ошибок проверки или `null` . Вы можете
передать их в качестве третьего аргумента, когда вы создаете `FormControl`.

Примечание: по соображениям производительности Angular запускает только асинхронные валидаторы, если все валидаторы синхронизации проходят. Каждый должен завершить, прежде чем ошибки будут установлены.

{@a built-in-validators}
### Встроенные валидаторы

Вы можете выбрать [написать свои собственные функции проверки](guide/form-validation#custom-validators), или вы можете использовать некоторые из
Встроенные валидаторы Angular.

Те же встроенные валидаторы, которые доступны как атрибуты в формах на основе шаблонов, например `required` и `minlength`, все доступны для использования в качестве функций из `Validators` Класс . Полный список встроенных валидаторов см. В [Validators](api/forms/Validators)справочнике API.

Чтобы обновить форму героя до реактивной, вы можете использовать некоторые из них
встроенные валидаторы - на этот раз в виде функции. Смотрите ниже:

{@a reactive-component-class}

<code-example path="form-validation/src/app/reactive/hero-form-reactive.component.1.ts" region="form-group" header="reactive/hero-form-reactive.component.ts (validator functions)"></code-example>

Обратите внимание, что:

* Элемент управления именем устанавливает два встроенных валидатора: `Validators.required` и `Validators.minLength(4)` - и один пользовательский валидатор, `forbiddenNameValidator` . Для более подробной информации см [пользовательские валидаторы](guide/form-validation#custom-validators)раздел в данном руководстве.
* Поскольку все эти валидаторы являются валидаторами синхронизации, вы передаете их как второй аргумент.
* Поддержка нескольких валидаторов, передавая функции в виде массива.
* Этот пример добавляет несколько методов получения. В реактивной форме вы всегда можете получить доступ к любому элементу управления формы через `get` Метод в родительской группе, но иногда полезно определить получатели как сокращения
для шаблона.


Если вы снова посмотрите на шаблон для ввода имени, он довольно похож на пример на основе шаблона.

<code-example path="form-validation/src/app/reactive/hero-form-reactive.component.html" region="name-with-error-msg" header="reactive/hero-form-reactive.component.html (name with error msg)"></code-example>

Основные тезисы:

 * Форма больше не экспортирует никаких директив, а вместо этого использует `name` получателя определено в
класс компонентов.
 * `required` атрибут все еще присутствует. Пока это не нужно для проверки
Вы можете захотеть сохранить его в своем шаблоне по стилю CSS или по причинам доступности.


{@a custom-validators}
## Пользовательские валидаторы

Поскольку встроенные валидаторы не всегда соответствуют точному варианту использования вашего приложения, иногда вам может понадобиться создать собственный валидатор.

Рассмотрим `forbiddenNameValidator` Функция из предыдущего
[примеры](guide/form-validation#reactive-component-class)в
это руководство. Вот что определение этой функции выглядит следующим образом :

<code-example path="form-validation/src/app/shared/forbidden-name.directive.ts" region="custom-validator" header="shared/forbidden-name.directive.ts (forbiddenNameValidator)"></code-example>

Функция на самом деле является фабрикой, которая берет регулярное выражение для обнаружения _specific_ запрещенного имени и возвращает функцию валидатора.

В этом примере запрещенное имя - «боб», поэтому валидатор отклонит любое имя героя, содержащее «боб».
В другом месте он может отклонить «alice» или любое имя, которое совпадает с регулярным выражением конфигурации.

 `forbiddenNameValidator` фабрика возвращает настроенную функцию валидатора.
Эта функция принимает объект управления Angular и возвращает _either_
null, если управляющее значение действительно _или_ объект ошибки проверки.
Объект ошибки проверки обычно имеет свойство, именем которого является ключ проверки, `'forbiddenName'`,
и значение которого является произвольным словарем значений, которые вы можете вставить в сообщение об ошибке, `{name}`.

Пользовательские асинхронные валидаторы похожи на валидаторы синхронизации, но вместо этого они должны возвращать Promise или Observable
который позже испускает ноль или объект ошибки проверки. В случае наблюдаемой наблюдаемая должна завершиться
в этот момент форма использует последнее значение, выданное для проверки.

{@a adding-to-reactive-forms}
### Добавление к реактивным формам

В реактивных формах пользовательские валидаторы довольно просто добавить. Все, что вам нужно сделать, это передать функцию напрямую
к `FormControl`.

<code-example path="form-validation/src/app/reactive/hero-form-reactive.component.1.ts" region="custom-validator" header="reactive/hero-form-reactive.component.ts (validator functions)"></code-example>

{@a adding-to-template-driven-forms}
### Добавление к шаблонно-управляемым формам

В формах на основе шаблонов у вас нет прямого доступа к `FormControl`, так что вы не можете передать
валидатор, как вы можете для реактивных форм. Вместо этого вам нужно добавить директиву в шаблон.

Соответствующий `ForbiddenValidatorDirective` служит оберткой вокруг `forbiddenNameValidator`.

Angular распознает роль директивы в процессе валидации, потому что директива регистрируется сама
с `NG_VALIDATORS` Поставщик, поставщик с расширяемой коллекцией валидаторов.

<code-example path="form-validation/src/app/shared/forbidden-name.directive.ts" region="directive-providers" header="shared/forbidden-name.directive.ts (providers)"></code-example>

Класс директивы затем реализует `Validator` Интерфейс, так что он может легко интегрироваться
с угловатыми формами. Вот остальная часть директивы, чтобы помочь вам понять, как все это
приходит вместе:

<code-example path="form-validation/src/app/shared/forbidden-name.directive.ts" region="directive" header="shared/forbidden-name.directive.ts (directive)">
</code-example>

Однажды `ForbiddenValidatorDirective` готов, вы можете просто добавить его селектор, `appForbiddenName`, к любому элементу ввода, чтобы активировать его. Например:

<code-example path="form-validation/src/app/template/hero-form-template.component.html" region="name-input" header="template/hero-form-template.component.html (forbidden-name-input)"></code-example>


<div class="alert is-helpful">

Возможно, вы заметили, что пользовательская директива проверки создается с помощью `useExisting` 
скорее, чем `useClass` . Зарегистрированный валидатор должен быть _this instance_ of
 `ForbiddenValidatorDirective` - экземпляр в форме с
его `forbiddenName` свойство связано с «боб». Если вы должны были заменить
 `useExisting ` с ` useClass`, тогда вы будете регистрировать новый экземпляр класса, тот, который
не имеет `forbiddenName`.

</div>

{@a control-status-css-classes}
## Контроль состояния CSS классов

Как и в AngularJS, Angular автоматически отображает многие свойства элемента управления в элементе управления формы как классы CSS. Вы можете использовать эти классы для стилизации элементов управления формы в соответствии с состоянием формы. Следующие классы в настоящее время поддерживаются:

* `.ng-valid` 
* `.ng-invalid` 
* `.ng-pending` 
* `.ng-pristine` 
* `.ng-dirty` 
* `.ng-untouched` 
* `.ng-touched` 

Форма героя использует `.ng-valid` и `.ng-invalid` классы
установить цвет границы каждого элемента управления формы.

<code-example path="form-validation/src/assets/forms.css" header="forms.css (status classes)">

</code-example>

{@a cross-field-validation}
## Межполевая валидация
В этом разделе показано, как выполнить перекрестную проверку поля. Это предполагает некоторые базовые знания по созданию пользовательских валидаторов.

<div class="alert is-helpful">

Если вы ранее не создавали пользовательские валидаторы, начните с просмотра [раздел пользовательских валидаторов](guide/form-validation#custom-validators).

</div>

В следующем разделе мы позаботимся о том, чтобы наши герои не раскрыли свою истинную личность, заполнив форму героя. Мы сделаем это, проверив, что имена героев и альтер эго не совпадают.

{@a adding-to-reactive-forms}
### Добавление к реактивным формам

Форма имеет следующую структуру:

```javascript
const heroForm = new FormGroup({
  'name': new FormControl(),
  'alterEgo': new FormControl(),
  'power': new FormControl()
});
```

Обратите внимание, что имя и alterEgo являются родственными элементами управления. Чтобы оценить оба элемента управления в одном настраиваемом валидаторе, мы должны выполнить валидацию в элементе управления общего предка: `FormGroup` . Таким образом, мы можем запросить `FormGroup` для дочерних элементов управления, которые позволят нам сравнивать их значения.

Чтобы добавить валидатор в `FormGroup`, передайте новый валидатор в качестве второго аргумента при создании.

```javascript
const heroForm = new FormGroup({
  'name': new FormControl(),
  'alterEgo': new FormControl(),
  'power': new FormControl()
}, { validators: identityRevealedValidator });
```

Код проверки достоверности заключается в следующем:

<code-example path="form-validation/src/app/shared/identity-revealed.directive.ts" region="cross-validation-validator" header="shared/identity-revealed.directive.ts"></code-example>

Валидатор идентичности реализует `ValidatorFn` Интерфейс . Он принимает объект управления Angular в качестве аргумента и возвращает либо ноль, если форма верна, либо `ValidationErrors` противном случае.

Сначала мы получаем дочерние элементы управления, вызывая `FormGroup` «s [прибудет](api/forms/AbstractControl#get)метод. Затем мы просто сравниваем значения `name` и `alterEgo` контролирует.

Если значения не совпадают, личность героя остается в секрете, и мы можем безопасно вернуть ноль. В противном случае раскрывается личность героя, и мы должны пометить форму как недействительную, возвращая объект ошибки.

Далее, чтобы обеспечить лучший пользовательский опыт, мы показываем соответствующее сообщение об ошибке, когда форма недействительна.
<code-example path="form-validation/src/app/reactive/hero-form-reactive.component.html" region="cross-validation-error-message" header="reactive/hero-form-template.component.html"></code-example>

Обратите внимание, что мы проверяем, если:
- `FormGroup` имеет ошибку перекрестной проверки, возвращаемую `identityRevealed` валидатор,
- пользователю еще предстоит [взаимодействовать](guide/form-validation#why-check-dirty-and-touched)с формой.

{@a adding-to-template-driven-forms}
### Добавление в шаблон управляемых форм
Сначала мы должны создать директиву, которая обернет функцию валидатора. Мы предоставляем его в качестве валидатора, используя `NG_VALIDATORS` Токен . Если вы не уверены почему или не полностью понимаете синтаксис, вернитесь к предыдущему [раздел](guide/form-validation#adding-to-template-driven-forms).

<code-example path="form-validation/src/app/shared/identity-revealed.directive.ts" region="cross-validation-directive" header="shared/identity-revealed.directive.ts"></code-example>

Далее мы должны добавить директиву в шаблон HTML. Поскольку валидатор должен быть зарегистрирован на самом высоком уровне в форме, мы помещаем директиву в `form` тег.
<code-example path="form-validation/src/app/template/hero-form-template.component.html" region="cross-validation-register-validator" header="template/hero-form-template.component.html"></code-example>

Чтобы улучшить взаимодействие с пользователем, мы показываем соответствующее сообщение об ошибке, когда форма недействительна.
<code-example path="form-validation/src/app/template/hero-form-template.component.html" region="cross-validation-error-message" header="template/hero-form-template.component.html"></code-example>

Обратите внимание, что мы проверяем, если:
- форма имеет ошибку перекрестной проверки, возвращаемую `identityRevealed` валидатор,
- пользователю еще предстоит [взаимодействовать](guide/form-validation#why-check-dirty-and-touched)с формой.

Это завершает пример перекрестной проверки. Нам удалось:
- проверить форму на основе значений двух родственных элементов управления
- показать описательное сообщение об ошибке после того, как пользователь взаимодействовал с формой и проверка не удалась.

{@a async-validation}
## Асинхронная проверка
В этом разделе показано, как создавать асинхронные валидаторы. Это предполагает некоторые базовые знания по созданию [пользовательские валидаторы](guide/form-validation#custom-validators).

{@a the-basics}
### Основы
Так же, как синхронные валидаторы имеют `ValidatorFn ` и ` Validator` интерфейсы, асинхронные валидаторы имеют свои аналоги: `AsyncValidatorFn` и `AsyncValidator`.

Они очень похожи, с той лишь разницей,:

* Они должны вернуть Обещание или Наблюдаемое
* Возвращаемая наблюдаемая должна быть конечной, то есть должна завершиться в какой-то момент. Чтобы преобразовать бесконечное наблюдаемое в конечное, направьте наблюдаемое через оператор фильтрации, такой как `first`, `last`, `take` или `takeUntil`.

Важно отметить, что асинхронная проверка происходит после синхронной проверки и выполняется только в случае успешной синхронной проверки. Эта проверка позволяет формам избегать потенциально дорогих асинхронных процессов проверки, таких как HTTP-запрос, в случае сбоя более простых методов проверки.

После начала асинхронной проверки элемент управления формы вводит `pending` состояние . Вы можете проверить контроль `pending` свойства и использовать его для визуальной обратной связи о текущей проверке.

Обычным шаблоном пользовательского интерфейса является показ счетчика во время выполнения асинхронной проверки. В следующем примере представляет, как добиться этого с формами на основе шаблонов:

```html
<input [(ngModel)]="name" #model="ngModel" appSomeAsyncValidator>
<app-spinner *ngIf="model.pending"></app-spinner>
```

{@a implementing-custom-async-validator}
### Реализация пользовательского асинхронного валидатора
В следующем разделе проверка выполняется асинхронно, чтобы гарантировать, что наши герои выберут альтер-эго, которое еще не взято. Новые герои постоянно вербуются, а старые герои покидают службу. Это означает, что у нас нет списка доступных альтернативных вариантов заранее.

Чтобы проверить потенциальное альтернативное эго, нам нужно обратиться к центральной базе данных всех зачисленных в настоящее время героев. Процесс асинхронный, поэтому для этого нам нужен специальный валидатор.

Давайте начнем с создания класса валидатора.

<code-example path="form-validation/src/app/shared/alter-ego.directive.ts" region="async-validator"></code-example>

Как видите, `UniqueAlterEgoValidator` Класс реализует `AsyncValidator` Интерфейс . В конструкторе мы вводим `HeroesService` которая имеет следующий интерфейс:

```typescript
interface HeroesService {
  isAlterEgoTaken: (alterEgo: string) => Observable<boolean>;
}
```

В реальных приложениях `HeroesService` отвечает за HTTP-запроса в базу данных героев, чтобы проверить, доступно ли альтернативное эго. С точки зрения валидатора, фактическая реализация сервиса не важна, поэтому мы можем просто кодировать против `HeroesService` Интерфейс.

Когда начинается проверка, `UniqueAlterEgoValidator` делегирует `HeroesService` `isAlterEgoTaken()` метод с текущим значением управления. На этом этапе элемент управления помечен как `pending` и остается в этом состоянии до тех пор, пока наблюдаемая цепь не вернется из `validate()` Метод завершается.

 `isAlterEgoTaken()` отправляет HTTP-запрос, который проверяет, доступно ли альтернативное эго, и возвращает `Observable<boolean>` как результат. Мы направляем ответ через `map` оператор и преобразовать его в результат проверки. Как всегда, мы возвращаемся `null` если форма действительна, и `ValidationErrors` если это не так. Мы уверены, что справимся с любыми потенциальными ошибками `catchError` оператор.

Здесь мы решили, что `isAlterEgoTaken()` считается успешной проверкой, поскольку невозможность сделать запрос проверки не обязательно означает, что альтернативное эго недействительно. Вы можете обработать ошибку по-другому и вернуть `ValidationError` Вместо этого объект.

Через некоторое время наблюдаемая цепочка завершается, и асинхронная проверка выполняется. `pending` флаг установлен в `false`, и срок действия формы обновляется.

{@a note-on-performance}
### Обратите внимание на производительность

По умолчанию все валидаторы запускаются после каждого изменения значения формы. С синхронными валидаторами это вряд ли окажет заметное влияние на производительность приложения. Однако асинхронные валидаторы обычно выполняют какой-то HTTP-запрос для проверки элемента управления. Отправка HTTP-запроса после каждого нажатия клавиши может создать нагрузку на бэкэнд-API, и его следует по возможности избегать.

Мы можем отложить обновление срока действия формы, изменив `updateOn` от `change` (по умолчанию) на `submit` или `blur`.

С формами на основе шаблонов:

```html
<input [(ngModel)]="name" [ngModelOptions]="{updateOn: 'blur'}">
```

При реактивных форм:

```typescript
new FormControl('', {updateOn: 'blur'});
```

**Вы можете запустить, <live-example></live-example>чтобы увидеть полный пример кода, основанного на реактивах и шаблонах.**
