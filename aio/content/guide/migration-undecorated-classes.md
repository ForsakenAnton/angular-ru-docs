{@a missing-directive-component-decorator-migration}
# Отсутствует `@Directive()` / `@Component()` миграция декоратора

{@a what-does-this-migration-do}
## Что делает эта миграция?

Эта миграция добавляет пустой `@Directive()` декоратора, чтобы без отделки
базовые классы:

- использовать Angular функции
- расширены директивами или компонентами

Например, в diff ниже, `@Directive()` декоратор `BaseMenu` потому что `BaseMenu` использует внедрение зависимостей.


  **Перед тем как:**
  ```ts
  export class BaseMenu {
    constructor(private vcr: ViewContainerRef) {}
  }

  @Directive({selector: '[settingsMenu]'})
  export class SettingsMenu extends BaseMenu {}
  ```

  **После того, как:**
  ```ts
  @Directive()
  export class BaseMenu {
    constructor(private vcr: ViewContainerRef) {}
  }

  @Directive({selector: '[settingsMenu]'})
  export class SettingsMenu extends BaseMenu {}
  ```

Если директива или компонент расширяется классом без декоратора, схема копирует любые унаследованные директивы или метаданные компонента в производный класс.

**Перед тем как:**
```ts
@Component({
  selector: 'base-menu',
  template: '<div></div>'
})
class BaseMenu {}

export class SettingsMenu extends BaseMenu {}
```

**После того, как:**
```ts
@Component({
  selector: 'base-menu',
  template: '<div></div>'
})
class BaseMenu {}

@Component({
  selector: 'base-menu',
  template: '<div></div>'
})
export class SettingsMenu extends BaseMenu {}
```

Эта схема также украсит классы, которые используют угловое поле декоратор, в том числе:
- `@Input()` 
- `@Output()` 
- `@HostBinding()` 
- `@HostListener()` 
- `@ViewChild()` / `@ViewChildren()` 
- `@ContentChild()` / `@ContentChildren()` 


**Перед тем как:**
```ts
class Base {
  @Output()
  countChanged = new EventEmitter<number>();
}

@Directive({
  selector: '[myDir]'
})
class Dir extends Base {
}
```

**После того, как :**
```ts
@Directive() // schematic adds @Directive()
class Base {
  @Output()
  countChanged = new EventEmitter<number>();
}

@Directive({
  selector: '[myDir]'
})
class Dir extends Base {
}
```


{@a why-is-this-migration-necessary}
## Почему эта миграция необходима?

{@a migrating-classes-that-use-di}
### Миграция классов, которые используют DI

Когда у класса есть `@Directive()` или `@Component()` декоратор, Angular компилятор генерирует дополнительный код для вставки зависимостей в конструктор.
При использовании наследования Ivy нужен родительский класс и дочерний класс, чтобы применить декоратор для генерации правильного кода.

Вы можете думать об этом изменении как о двух случаях: родительский класс отсутствует
декоратор или дочерний класс отсутствует декоратор.
В обоих сценариях среда выполнения Angular требует дополнительной информации от компилятора.
Эта дополнительная информация поступает от добавления декораторов.


{@a decorator-missing-from-parent-class}
#### Декоратор отсутствует в родительском классе

Когда декоратор отсутствует в родительском классе, подкласс унаследует конструктор от класса, для которого компилятор не генерировал специальную информацию конструктора (поскольку он не был оформлен как директива).
Когда Angular пытается создать подкласс, у него нет правильной информации для его создания.

В View Engine компилятор обладает глобальными знаниями, поэтому он может искать недостающие данные.
Однако компилятор Ivy обрабатывает каждую директиву изолированно.
Это означает, что компиляция может быть быстрее, но компилятор не может автоматически выводить ту же информацию, что и раньше.
Добавление `@Directive()` явно предоставляет эту информацию.

В будущем добавлю `@Directive()` для базовых классов, которые еще не имеют декораторов и расширены директивами.

{@a decorator-missing-from-child-class}
#### Декоратор отсутствует в дочернем классе

Когда в дочернем классе отсутствует декоратор, дочерний класс наследует от родительского класса, но не имеет собственных декораторов.
Без декоратора компилятор не может знать, что класс является `@Directive` или `@Component`, поэтому он не генерирует надлежащие инструкции для директивы.

{@a migrating-classes-that-use-field-decorators}
### Перенос классов, которые используют декораторы полей

В ViewEngine базовые классы с полевыми декораторами, такими как `@Input()` работал, даже когда у класса не было `@Directive()` или `@Component()` декоратор.
Например:

```ts
class Base {
  @Input()
  foo: string;
}

@Directive(...)
class Dir extends Base {
  ngOnChanges(): void {
    // notified when bindings to [foo] are updated
  }
}
```

Однако этот пример не будет компилироваться с Ivy, потому что `Base` класс _requires_ либо `@Directive()` или `@Component()` для генерации кода для входов, выходов, запросов и привязок хоста.

Всегда, требующие класс декоратор приводит к двум основнымам преимущества для Angular:

1. Предыдущее поведение было противоречивым.
   Некоторые функции Angular требуют декоратора (внедрение зависимости), а другие - нет.
   Теперь все функции Angular постоянно требуют декоратор класса.

1. Поддержка неокрашенных классов увеличивает размер кода и сложность Angular.
   Всегда требующий декораторов классов позволяет каркасу становиться меньше и проще для всех пользователей.


{@a what-does-it-mean-to-have-a-directive-decorator-with-no-metadata-inside-of-it}
## Что значит иметь `@Directive()` декоратор без метаданных внутри?

Наличие `@Directive` decorator заставляет Angular генерировать дополнительный код для затронутого класса.
Если этот декоратор не содержит свойств (метаданных), директива не будет сопоставляться с элементами или создаваться непосредственно, но другие классы, которые _extend_ класс директивы будут наследовать этот сгенерированный код.
Вы можете думать об этом как об «абстрактной» директиве.

Добавление абстрактной директивы к `NgModule` вызовет ошибку.
Директива должна иметь `selector` свойство определенное для соответствия некоторому элементу в шаблоне.

{@a when-do-i-need-a-directive-decorator-without-a-selector}
## Когда мне нужно `@Directive()` декоратор без селектора?

Если вы используете внедрение зависимостей или любую специфическую для Angular функцию, такую ​​как `@HostBinding()`, `@ViewChild()` или `@Input()`, вам нужен `@Directive()` или `@Component()` декоратор.
Декоратор сообщает компилятору, чтобы он генерировал правильные инструкции для создания этого класса и любых классов, которые его расширяют.
Если вы не хотите использовать этот базовый класс в качестве директивы напрямую, оставьте селектор пустым.
Если вы хотите, чтобы он мог использоваться независимо, заполните метаданные как обычно.

Классы, которые не используют Angular объекты, не нуждаются в угловом декораторе.

{@a im-a-library-author-should-i-add-the-directive-decorator-to-base-classes}
## Я автор библиотеки. Должен ли я добавить `@Directive()` декоратор для базовых классов?

Поскольку в Angular версии 9 введена поддержка декораторов без селектора, если вы хотите поддерживать версию Angular 8 и более ранние, не следует добавлять селектор без выбора. `@Directive()` декоратор.
Вы можете добавить `@Directive()` с селектором или переместите специфичные для Angular функции к затронутым подклассам.

{@a what-about-applications-using-non-migrated-libraries}
## А как насчет приложений, использующих немигрированные библиотеки?

[Угловое компилятор совместимости](guide/glossary#ngcc)(`ngcc`) должен автоматически преобразовывать любые библиотеки для генерации правильного кода.
