{@a pipes}
# Трубы

Каждое приложение начинается с простой задачи: получить данные, преобразовать их и показать пользователям.
Получение данных может быть таким же простым, как создание локальной переменной, или таким же сложным, как потоковая передача данных через WebSocket.

Как только данные поступят, вы можете отправить их `toString` значения непосредственно в представление
но это редко делает для хорошего пользовательского опыта.
Например, в большинстве случаев пользователи предпочитают видеть дату в простом формате, например
15 апреля 1988 г.а не формат необработанной строки
Пт 15 апреля 1988 00:00:00 GMT-0700 (тихоокеанское летнее время),

Очевидно, что некоторые значения выигрывают от небольшого редактирования. Вы можете заметить, что вы
необходимо многократное повторение одних и тех же преобразований как внутри, так и во многих приложениях.
Вы можете почти думать о них как о стилях.
На самом деле, вы можете применить их в своих шаблонах HTML, как и стили.

Представляем Angular pipe, способ писать преобразования отображаемых значений, которые вы можете объявить в своем HTML.

Вы можете запустить <live-example></live-example>в Stackblitz и скачать код оттуда.


{@a using-pipes}
## Используя трубы

Канал принимает данные в качестве входных данных и преобразует их в желаемый выходной.
На этой странице вы будете использовать каналы для преобразования свойства дня рождения компонента в
дружеское свидание.


<code-example path="pipes/src/app/hero-birthday1.component.ts" header="src/app/hero-birthday1.component.ts"></code-example>



Сосредоточьтесь на шаблоне компонента.


<code-example path="pipes/src/app/app.component.html" region="hero-birthday-template" header="src/app/app.component.html"></code-example>



Внутри интерполяционного выражения вы передаете компоненту `birthday` значение через
[оператор трубы](guide/template-syntax#pipe)(|) к [Дата трубы](api/common/DatePipe)
функция справа. Все трубы работают таким образом.




{@a built-in-pipes}
## Встроенные трубы
Angular поставляется с запасом труб, таких как
 `DatePipe `, ` UpperCasePipe `, ` LowerCasePipe `, ` CurrencyPipe ` и ` PercentPipe`.
Все они доступны для использования в любом шаблоне.


<div class="alert is-helpful">



Подробнее об этих и многих других встроенных труб в [трубы тем](api?type=pipe)из
[Справочник по API](api); фильтр для записей, которые включают слово «труба».

Angular не имеет `FilterPipe` или `OrderByPipe` по причинам, объясненным в [Приложении](guide/pipes#no-filter-pipe)этой страницы.


</div>




{@a parameterizing-a-pipe}
## Параметризация трубы

Канал может принимать любое количество необязательных параметров для точной настройки своего вывода.
Чтобы добавить параметры в канал, введите имя канала с двоеточием (:), а затем значение параметра
(Такие как `currency:'EUR'`). Если канал принимает несколько параметров, разделите значения двоеточиями (например, `slice:1:5`)

Измените шаблон дня рождения, чтобы дать трубе даты параметр формата.
После форматирования 15-го дня рождения героя он выглядит как**04/15/88**:


<code-example path="pipes/src/app/app.component.html" region="format-birthday" header="src/app/app.component.html"></code-example>



Значением параметра может быть любое допустимое выражение шаблона
(см [выражения шаблона](guide/template-syntax#template-expressions)раздел
[Шаблон синтаксиса](guide/template-syntax)страницы)
такой как строковый литерал или свойство компонента.
Другими словами, вы можете управлять форматом через привязку так же, как вы управляете значением дня рождения через привязку.

Напишите второй компонент, который *связывает* параметр формата канала
к компоненту `format` свойство . Вот шаблон для этого компонента:


<code-example path="pipes/src/app/hero-birthday2.component.ts" region="template" header="src/app/hero-birthday2.component.ts (template)"></code-example>



Вы также добавили кнопку в шаблон и привязали ее событие нажатия к компоненту `toggleFormat()`.
Этот метод переключает компонент `format` свойство между краткой формой
(`'shortDate'`) и более длинная форма (`'fullDate'`).


<code-example path="pipes/src/app/hero-birthday2.component.ts" region="class" header="src/app/hero-birthday2.component.ts (class)"></code-example>



Когда вы нажимаете кнопку, отображаемая дата чередуется
"**04/15/1988**"и
"**Пятница, 15 апреля 1988 г.**».

<div class="lightbox">
  <img src='generated/images/guide/pipes/date-format-toggle-anim.gif' alt="Date Format Toggle">
</div>


<div class="alert is-helpful">



Подробнее о `DatePipe` формата в [Date Pipe](api/common/DatePipe)
Справочная страница API.


</div>



{@a chaining-pipes}
## Цепные трубы

Вы можете объединить трубы в потенциально полезные комбинации.
В следующем примере, чтобы отобразить день рождения в верхнем регистре,
день рождения прикован к `DatePipe` и на `UpperCasePipe`.
День рождения отображается как**15 апреля 1988 г.**,


<code-example path="pipes/src/app/app.component.html" region="chained-birthday" header="src/app/app.component.html"></code-example>



Этот пример, который отображает**Пятница, 15 апреля 1988 г.**- цепи
те же каналы, что и выше, но передаются в параметре `date` также.


<code-example path="pipes/src/app/app.component.html" region="chained-parameter-birthday" header="src/app/app.component.html"></code-example>




{@a custom-pipes}
## Нестандартные трубы

Вы можете написать свои собственные трубы.
Вот пользовательский канал с именем `ExponentialStrengthPipe` что может увеличить силы героя:


<code-example path="pipes/src/app/exponential-strength.pipe.ts" header="src/app/exponential-strength.pipe.ts"></code-example>



Это определение трубы позволяет выявить следующие ключевые моменты:

* Труба - это класс, украшенный метаданными трубы.
* Класс pipe реализует `PipeTransform` интерфейс `transform` метод, который
принимает входное значение, за которым следуют необязательные параметры, и возвращает преобразованное значение.
* Там будет один дополнительный аргумент `transform` метод для каждого параметра, передаваемого в канал.
У вашей трубы есть один такой параметр: `exponent`.
* Чтобы сказать Angular, что это труба, вы применяете
 `@Pipe` decorator, который вы импортируете из базовой библиотеки Angular.
* `@Pipe` позволяет вам определить
   имя канала, которое вы будете использовать в выражениях шаблонов. Это должен быть действительный идентификатор JavaScript.
   Название вашей трубы `exponentialStrength`.


<div class="alert is-helpful">



{@a the-*pipetransform*-interface}
## *PipeTransform* интерфейс

 `transform` Метод имеет важное значение для трубы.
 `PipeTransform` *Интерфейс* определяет этот метод и управляет как инструментами, так и компилятором.
Технически это необязательно; Angular ищет и выполняет `transform` метод независимо.

</div>

Теперь вам нужен компонент для демонстрации трубы.

<code-example path="pipes/src/app/power-booster.component.ts" header="src/app/power-booster.component.ts"></code-example>

<div class="lightbox">
  <img src='generated/images/guide/pipes/power-booster.png' alt="Power Booster">
</div>



Обратите внимание на следующее:

* Вы используете свою собственную трубу так же, как вы используете встроенные трубы.
* Вы должны включить свою трубу в `declarations` массив `AppModule` 
* Если вы решите внедрить свою трубу в класс, вы должны указать ее в `providers` массив вашего `NgModule`.

<div class="callout is-helpful">

<header>
  Запомните массив объявлений
</header>


Вы должны зарегистрировать пользовательские каналы.
Если вы этого не сделаете, Angular сообщает об ошибке.
[Angular CLI в](cli)генератор автоматически регистрирует трубку.


</div>



Для того, чтобы исследовать поведение в <live-example></live-example>,
изменить значение и необязательный показатель степени в шаблоне.

{@a power-boost-calculator}
## Power Boost Calculator

Обновление шаблона для тестирования пользовательского канала не очень интересно.
Обновите пример до «Power Boost Calculator», который объединяет
ваш канал и двустороннее связывание данных с `ngModel`.


<code-example path="pipes/src/app/power-boost-calculator.component.ts" header="src/app/power-boost-calculator.component.ts">

</code-example>



<div class="lightbox">
  <img src='generated/images/guide/pipes/power-boost-calculator-anim.gif' alt="Power Boost Calculator">
</div>




{@a change-detection}


{@a pipes-and-change-detection}
## Трубы и обнаружение изменений

Angular выглядит для изменений значений с привязкой к данным через *обнаружение изменений* процесса, который запускается после каждого события DOM:
каждое нажатие клавиши, движение мыши, отметка таймера и ответ сервера. Это может быть дорого.
Angular стремится снизить стоимость, когда это возможно и уместно.

Angular выбирает более простой и быстрый алгоритм обнаружения изменений при использовании канала.

<h3 class="no-toc">Нет трубы </h3>

В следующем примере компонент использует стандартную стратегию агрессивного обнаружения изменений для мониторинга и обновления
его отображение каждого героя в `heroes` массив . Вот шаблон:


<code-example path="pipes/src/app/flying-heroes.component.html" region="template-1" header="src/app/flying-heroes.component.html (v1)"></code-example>



Компонент класса-компаньона предоставляет героев, добавляет героев в массив и может сбросить массив.

<code-example path="pipes/src/app/flying-heroes.component.ts" region="v1" header="src/app/flying-heroes.component.ts (v1)"></code-example>



Вы можете добавлять героев и обновления Angular, когда вы делаете.
Если вы нажмете `reset` кнопка, Angular заменяет `heroes` с новым массивом оригинальных героев и обновлений дисплея.
Если вы добавите возможность удалять или менять героя, Angular обнаружит эти изменения и обновит отображение.

<h3 class="no-toc"><i>FlyingHeroesPipe </i></h3>

Добавить `FlyingHeroesPipe` к `*ngFor` повторителя, который фильтрует список героев только тем героям, которые могут летать.

<code-example path="pipes/src/app/flying-heroes.component.html" region="template-flying-heroes" header="src/app/flying-heroes.component.html (flyers)"></code-example>



Вот `FlyingHeroesPipe` Реализация, которая следует шаблону для пользовательских каналов, описанному ранее.

<code-example path="pipes/src/app/flying-heroes.pipe.ts" region="pure" header="src/app/flying-heroes.pipe.ts"></code-example>



Обратите внимание на странное поведение в <live-example></live-example>:
Когда вы добавляете летающих героев, ни один из них не отображается в разделе «Герои, которые летают».

Хотя вы не получаете желаемого поведения, Angular не сломлен.
Он просто использует другой алгоритм обнаружения изменений, который игнорирует изменения в списке или любых его элементах.

Обратите внимание на то, как добавляется герой:

<code-example path="pipes/src/app/flying-heroes.component.ts" region="push" header="src/app/flying-heroes.component.ts"></code-example>



Вы добавляете героя в `heroes` массив . Ссылка на массив не изменилась.
Это тот же массив. Это все, что заботит Angular. С его точки зрения, *тот же массив, без изменений, без обновления дисплея*.

Чтобы это исправить, создайте массив с добавленным новым героем и назначьте его `heroes`.
На этот раз Angular обнаруживает, что ссылка на массив изменилась.
Он выполняет трубу и обновляет отображение новым массивом, в который входит новый летающий герой.

Если вы *изменяете* массив, канал не вызывается и отображение не обновляется;
если вы *замените* массив, канал будет запущен и дисплей обновится.
Приложение Flying Heroes расширяет
код с переключателями и дополнительными дисплеями, чтобы помочь вам испытать эти эффекты.


<div class="lightbox">
  <img src='generated/images/guide/pipes/flying-heroes-anim.gif' alt="Flying Heroes">
</div>



Замена массива - эффективный способ сообщить Angular об обновлении дисплея.
Когда вы заменяете массив? Когда данные меняются.
Это простое правило, которому нужно следовать в *этом* примере
где единственный способ изменить данные - добавить героя.

Чаще вы не знаете, когда изменились данные
особенно в приложениях, которые изменяют данные разными способами
возможно, в местах приложения далеко.
Компонент в таком приложении обычно не может знать об этих изменениях.
Более того, неразумно искажать конструкцию компонента для размещения трубы.
Стремитесь сохранить класс компонента независимым от HTML.
Компонент не должен знать о трубах.

Для фильтрации летающих героев рассмотрим *нечистую трубу*.



{@a pure-and-impure-pipes}
## Чистые и нечистые трубы

Есть две категории труб: *чистые* и *нечистые*.
Трубы чистые по умолчанию. Каждая труба, которую вы видели до сих пор, была чистой.
Вы делаете трубу нечистой, устанавливая ее чистый флаг в false. Вы могли бы сделать `FlyingHeroesPipe` 
нечистый, как это:


<code-example path="pipes/src/app/flying-heroes.pipe.ts" region="pipe-decorator" header="src/app/flying-heroes.pipe.ts"></code-example>



Прежде чем делать это, поймите разницу между чистым и нечистым, начиная с чистой трубы.

<h3 class="no-toc">Чистые трубы </h3>

Angular выполняет *чистый канал* только тогда, когда обнаруживает *чистое изменение* входного значения.
Чистое изменение - это либо изменение примитивного входного значения (`String`, `Number`, `Boolean`, `Symbol`)
или измененная ссылка на объект (`Date`, `Array`, `Function`, `Object`).

Angular игнорирует изменения внутри (составных) объектов.
Он не будет вызывать чистый канал, если вы измените месяц ввода, добавите его во входной массив или обновите свойство объекта ввода.

Это может показаться ограничительным, но это также быстро.
Проверка ссылки на объект выполняется быстро - намного быстрее, чем для глубокой проверки
Различия - так что Angular может быстро определить, может ли он пропустить оба
конвейерное исполнение и обновление вида.

По этой причине чистый канал предпочтительнее, когда вы можете жить со стратегией обнаружения изменений.
Когда вы не можете, вы *можете* использовать нечистую трубу.


<div class="alert is-helpful">



Или вы не можете использовать трубу вообще.
Может быть лучше следовать цели трубы с помощью свойства компонента
точка, которая обсуждается позже на этой странице.


</div>



<h3 class="no-toc">Нечистые трубы </h3>

Angular выполняет *нечистую трубу* во время каждого цикла обнаружения изменений компонентов.
Нечистый канал вызывается часто, так же часто, как каждое нажатие клавиши или движение мыши.

Помня об этом, осторожно используйте нечистую трубу.
Дорогая, долговечная труба может разрушить пользовательский опыт.


{@a impure-flying-heroes}


<h3 class="no-toc">Нечистый <i>летучий герой пайп </i></h3>

Щелчок переключателя поворачивает `FlyingHeroesPipe` в `FlyingHeroesImpurePipe`.
Полная реализация выглядит следующим образом :

<code-tabs>

  <code-pane header="FlyingHeroesImpurePipe" path="pipes/src/app/flying-heroes.pipe.ts" region="impure">

  </code-pane>

  <code-pane header="FlyingHeroesPipe" path="pipes/src/app/flying-heroes.pipe.ts" region="pure">

  </code-pane>

</code-tabs>



Вы наследуете от `FlyingHeroesPipe` чтобы доказать, что внутри ничего не изменилось.
Единственная разница заключается в `pure` флаг в метаданных канала.

Это хороший кандидат на нечистую трубу, потому что `transform` Функция тривиальна и быстра.


<code-example path="pipes/src/app/flying-heroes.pipe.ts" header="src/app/flying-heroes.pipe.ts (filter)" region="filter"></code-example>



Вы можете получить `FlyingHeroesImpureComponent` от `FlyingHeroesComponent`.


<code-example path="pipes/src/app/flying-heroes-impure.component.html" header="src/app/flying-heroes-impure.component.html (excerpt)" region="template-flying-heroes"></code-example>



Единственное существенное изменение - это труба в шаблоне.
Вы можете подтвердить в том, <live-example></live-example>что _flying героев_
отображать обновления по мере добавления героев, даже если вы изменили `heroes` массив.


{@a async-pipe}
<h3 class="no-toc">Нечистый <i>AsyncPipe </i></h3>


Angular `AsyncPipe` - интересный пример нечистой трубы.
 `AsyncPipe ` принимает ` Promise ` или ` Observable` качестве ввода
и подписывается на вход автоматически, в конечном итоге возвращает испущенные значения.

 `AsyncPipe` также с состоянием.
Канал поддерживает подписку на вход `Observable` и
продолжает доставлять ценности из этого `Observable` мере их поступления.

Следующий пример связывает `Observable` из строк сообщения
(`message$`) для просмотра с `async` труба.


<code-example path="pipes/src/app/hero-async-message.component.ts" header="src/app/hero-async-message.component.ts">

</code-example>



Асинхронная труба сохраняет шаблон в коде компонента.
Компонент не должен подписываться на асинхронный источник данных
извлечь разрешенные значения и выставить их для привязки
и должны отписаться, когда он будет уничтожен
(мощный источник утечек памяти).

<h3 class="no-toc">Нечистая кеширующая труба </h3>

Напишите еще один нечистый канал, канал, который делает HTTP-запрос.

Помните, что нечистые каналы вызываются каждые несколько миллисекунд.
Если вы не будете осторожны, этот канал накажет сервер запросами.

В следующем коде канал вызывает сервер только при изменении запрошенного URL-адреса и кэширует ответ сервера.
Код использует [Angular HTTP](guide/http)клиент для получения данных:


<code-example path="pipes/src/app/fetch-json.pipe.ts" header="src/app/fetch-json.pipe.ts">

</code-example>



Теперь продемонстрируйте это в компоненте проводки, шаблон которого определяет две привязки к этой трубе
оба просят героев из `heroes.json` файл.


<code-example path="pipes/src/app/hero-list.component.ts" header="src/app/hero-list.component.ts">

</code-example>



Компонент оказывает как следующие:


<div class="lightbox">
  <img src='generated/images/guide/pipes/hero-list.png' alt="Hero List">
</div>



Точки останова по запросу трубы для данных показывают следующее:

* Каждая привязка получает свой собственный экземпляр канала.
* Каждый экземпляр канала кэширует свой собственный URL и данные.
* Каждый экземпляр канала вызывает сервер только один раз.

<h3 class="no-toc"><i>JsonPipe </i></h3>

В предыдущем примере кода второй `fetch` привязка труб демонстрирует большее сцепление труб.
Он отображает те же данные о героях в формате JSON, соединяя их со встроенным `JsonPipe`.


<div class="callout is-helpful">



<header>
  Отладка с помощью JSON-канала
</header>



[JsonPipe](api/common/JsonPipe)
предоставляет простой способ диагностирования таинственно сбойной привязки данных или
осмотреть объект для будущего связывания.


</div>



{@a pure-pipe-pure-fn}


<h3 class="no-toc">Чистые трубы и чистые функции </h3>

Чистая труба использует чистые функции.
Чистые функции обрабатывают входные данные и возвращают значения без обнаруживаемых побочных эффектов.
При одинаковом вводе они всегда должны возвращать одинаковый вывод.

Каналы, обсужденные ранее на этой странице, реализованы с чистыми функциями.
Встроенный `DatePipe` - это чистый канал с чистой реализацией функции.
Таковы `ExponentialStrengthPipe` и `FlyingHeroesPipe`.
Несколько шагов назад вы рассмотрели `FlyingHeroesImpurePipe` - нечистая труба с чистой функцией.

Но всегда реализуйте *чистую трубу* с *чистой функцией*.
В противном случае вы увидите много консольных ошибок, касающихся выражений, которые изменились после их проверки.



{@a next-steps}
## Следующие шаги

Трубы - отличный способ инкапсулировать и совместно использовать общую отображаемую стоимость
преобразования. Используйте их как стили, отбрасывая их
в выражениях вашего шаблона, чтобы обогатить привлекательность и удобство использования
ваших взглядов.

Изучите инвентарь встроенных труб Angular в [Справочник по API](api?type=pipe).
Попробуйте написать собственный канал и, возможно, внести свой вклад в сообщество.


{@a no-filter-pipe}



{@a appendix-no-*filterpipe*-or-*orderbypipe*}
## Приложение: Нет *FilterPipe* или *OrderByPipe*

Angular не предоставляет каналы для фильтрации или сортировки списков.
Разработчики, знакомые с AngularJS, знают это как `filter` и `orderBy`.
В Angular нет аналогов.

Это не упущение. Angular не предлагает такие трубы, потому что
они плохо работают и препятствуют агрессивному минимизации.
И то и другое `filter` и `orderBy` требуются параметры, которые ссылаются на свойства объекта.
Ранее на этой странице вы узнали, что такие трубы должны быть [нечистыми](guide/pipes#pure-and-impure-pipes)и что
Angular вызовы загрязняют трубы почти в каждом цикле обнаружения изменений.

Фильтрация и особенно сортировка - дорогостоящие операции.
Пользовательский интерфейс может значительно ухудшиться даже для списков среднего размера, когда Angular вызывает эти методы канала много раз в секунду.
 `filter ` и ` orderBy` часто использовался в приложениях AngularJS, что приводило к жалобам на медлительность самого Angular.
Это обвинение справедливо в косвенном смысле, что AngularJS подготовил эту ловушку производительности
предлагая `filter` и `orderBy` в первую очередь.

Опасность минификации также очевидна, хотя и менее очевидна. Представьте себе трубу сортировки, примененную к списку героев.
Список может быть отсортирован по герою `name` и `planet` свойств происхождения следующим образом:

<code-example language="html">
  &lt;!-- NOT REAL CODE! -->
  &lt;div *ngFor="let hero of heroes | orderBy:'name,planet'">&lt;/div>
</code-example>



Вы определяете поля сортировки по текстовым строкам, ожидая, что канал будет ссылаться на значение свойства путем индексации
(Такие как `hero['name']`).
К сожалению, агрессивное минимизация манипулирует `Hero` Имена свойств чтобы `Hero.name` и `Hero.planet` 
стать чем-то вроде `Hero.a` и `Hero.b` . очевидно `hero['name']` не работает.

Хотя некоторые, возможно, не хотят минимизировать это агрессивно
Angular продукт не должен мешать агрессивному минированию.
Поэтому команда Angular решила, что все, что предоставляет Angular, безопасно минимизируется.

Команда Angular и многие опытные разработчики Angular настоятельно рекомендуют переехать
фильтрация и сортировка логики в самом компоненте.
Компонент может выставить `filteredHeroes` или `sortedHeroes` и получить контроль
когда и как часто выполнять вспомогательную логику.
Любые возможности, которые вы могли бы поместить в канал и использовать в приложении, могут быть
записывается в сервисе фильтрации / сортировки и внедряется в компонент.

Если эти соображения производительности и минимизации не относятся к вам, вы всегда можете создать свои собственные такие каналы
(аналогично [FlyingHeroesPipe](guide/pipes#impure-flying-heroes)) или найдите их в сообществе.
