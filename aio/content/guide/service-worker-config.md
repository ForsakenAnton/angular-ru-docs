{@a service-worker-configuration}
# Конфигурация сервисного работника

{@a prerequisites}
#### Предпосылки

Основное понимание следующего:
* [Сервисный работник на производстве](guide/service-worker-devops).

<hr />

 `ngsw-config.json` конфигурации указывает, какие файлы и URL-адреса данных используются сервисом Angular
Рабочий должен кешировать и как он должен обновлять кэшированные файлы и данные. [Angular CLI](cli)
обрабатывает файл конфигурации во время `ng build --prod` . Вручную вы можете обработать его с помощью
 `ngsw-config` инструмент (где `<project-name>` этого название проекта строится)

<code-example language="sh">
./node_modules/.bin/ngsw-config ./dist/&lt;project-name&gt; ./ngsw-config.json [/base/href]
</code-example>

Файл конфигурации использует формат JSON. Все пути к файлам должны начинаться с `/`, что соответствует
в каталог развертывания - обычно `dist/<project-name>` проекта в проектах CLI.

{@a glob-patterns}
Если не указано иное, образцы используют ограниченный формат Глоб:

* `**` соответствует 0 или более сегментам пути.
* `*` соответствует 0 или более символам, исключая `/`,
* `?` соответствует ровно одному символу, исключая `/`,
* `!` Префикс помечает шаблон как отрицательный, что означает, что будут включены только файлы, которые не соответствуют шаблону.

Пример структуры:

* `/**/*.html` определяет все файлы HTML.
* `/*.html` указывает только файлы HTML в корне.
* `!/**/*.map` исключить все исходные карты.

Каждый раздел файла конфигурации описан ниже.

{@a appdata}
## `appData` 

Этот раздел позволяет передавать любые данные, которые вы хотите, которые описывают эту конкретную версию приложения.
 `SwUpdate` включает эти данные в уведомления об обновлениях. Многие приложения используют этот раздел, чтобы предоставить дополнительную информацию для отображения всплывающих окон пользовательского интерфейса, уведомляя пользователей о доступном обновлении.

{@a index-file}
{@a index}
## `index` 

Указывает файл, который служит страницей индекса для удовлетворения запросов навигации. Обычно это `/index.html`.

{@a assetgroups}
## `assetGroups` 

*Активы* - это ресурсы, являющиеся частью версии приложения, которые обновляются вместе с приложением. Они могут включать ресурсы, загруженные из источника страницы, а также сторонние ресурсы, загруженные из CDN и других внешних URL-адресов. Поскольку не все такие внешние URL-адреса могут быть известны во время сборки, шаблоны URL-адресов могут быть сопоставлены.

Это поле содержит массив групп активов, каждая из которых определяет набор ресурсов и политику, в которой они кэшируются.

```json
{
  "assetGroups": [{
    ...
  }, {
    ...
  }]
}
```

Каждая группа активов определяет как группу ресурсов, так и политику, которая ими управляет. Эта политика определяет, когда ресурсы выбираются и что происходит при обнаружении изменений.

Группы активов следуют интерфейсу машинописи, показанный здесь:

```typescript
interface AssetGroup {
  name: string;
  installMode?: 'prefetch' | 'lazy';
  updateMode?: 'prefetch' | 'lazy';
  resources: {
    files?: string[];
    urls?: string[];
  };
}
```

{@a name}
### `name` 

 `name` обязательно. Он идентифицирует эту конкретную группу активов между версиями конфигурации.

{@a installmode}
### `installMode` 

 `installMode` определяет, как эти ресурсы изначально кэшируются. `installMode` может быть одно из двух значений:

* `prefetch` сообщает работнику службы Angular о необходимости извлечения каждого из перечисленных ресурсов во время кэширования текущей версии приложения. Это интенсивно использует пропускную способность, но обеспечивает доступность ресурсов, когда они запрашиваются, даже если браузер в данный момент отключен.

* `lazy` не кеширует любые ресурсы заранее. Вместо этого работник службы Angular кэширует только те ресурсы, к которым он получает запросы. Это режим кэширования по требованию. Ресурсы, которые никогда не запрашиваются, не будут кэшироваться. Это полезно для таких вещей, как изображения с различным разрешением, поэтому работник службы кэширует только правильные ресурсы для определенного экрана и ориентации.

По умолчанию `prefetch`.

{@a updatemode}
### `updateMode` 

Для ресурсов, уже находящихся в кеше, `updateMode` определяет поведение кэширования при обнаружении новой версии приложения. Любые ресурсы в группе, которые изменились с предыдущей версии, обновляются в соответствии с `updateMode`.

* `prefetch` сообщает сервисному работнику немедленно загрузить и кэшировать измененные ресурсы.

* `lazy` говорит сервисному работнику не кэшировать эти ресурсы. Вместо этого он обрабатывает их как незапрошенные и ждет, пока их не запросят снова, прежде чем обновлять их. `updateMode ` of ` lazy` действителен только если `installMode` также `lazy`.

По умолчанию это значение `installMode` установлен в.

{@a resources}
### `resources` 

В этом разделе описаны ресурсы в кэш, разбитых на следующие группы:

* `files` перечислены шаблоны, соответствующие файлам в каталоге распространения. Это могут быть отдельные файлы или глобальные шаблоны, которые соответствуют нескольким файлам.

* `urls` включают в себя как URL, так и шаблоны URL, которые будут сопоставляться во время выполнения. Эти ресурсы не извлекаются напрямую и не содержат хэшей контента, но они будут кэшироваться в соответствии с их заголовками HTTP. Это наиболее полезно для CDN, таких как сервис Google Fonts. <br>
  _(Отрицательные шаблоны глобуса не поддерживаются и `?` будет соответствовать буквально; т.е. он не будет соответствовать ни одному символу, кроме `?` .) _

{@a datagroups}
## `dataGroups` 

В отличие от ресурсов ресурсов, запросы данных не версионируются вместе с приложением. Они кэшируются в соответствии с настроенными вручную политиками, которые более полезны для таких ситуаций, как запросы API и другие зависимости данных.

Группы данных следуют этому интерфейсу Машинопись:

```typescript
export interface DataGroup {
  name: string;
  urls: string[];
  version?: number;
  cacheConfig: {
    maxSize: number;
    maxAge: string;
    timeout?: string;
    strategy?: 'freshness' | 'performance';
  };
}
```

{@a name}
### `name` 
Похожий на `assetGroups`, каждая группа данных имеет `name` которое однозначно идентифицирует его.

{@a urls}
### `urls` 
Список шаблонов URL. URL-адреса, соответствующие этим шаблонам, кэшируются в соответствии с политикой этой группы данных. Только немутирующие запросы (GET и HEAD) кэшируются.
 * Отрицательные шаблоны глобуса не поддерживаются.
 * `?` подбирается буквально; то есть соответствует*только * персонажу `?`,

{@a version}
### `version` 
Иногда API изменяют форматы способом, который не является обратно совместимым. Новая версия приложения может быть несовместима со старым форматом API и, следовательно, может быть несовместима с существующими кэшированными ресурсами этого API.

 `version` предоставляет механизм для указания того, что кэшируемые ресурсы были обновлены обратно несовместимым способом, и что старые записи в кэше - записи из предыдущих версий - должны быть отброшены.

 `version` является целочисленным полем и по умолчанию `1`.

{@a cacheconfig}
### `cacheConfig` 
Этот раздел определяет политику, по которой соответствующие запросы будут кэшироваться.

{@a maxsize}
#### `maxSize` 
(обязательно) Максимальное количество записей или ответов в кэше. Кэши открытого типа могут неограниченно увеличиваться и в конечном итоге превышать квоты хранилища, требуя выселения.

{@a maxage}
#### `maxAge` 
(обязательно) `maxAge` Параметр указывает, как долго ответы могут оставаться в кэше, прежде чем они будут считаться недействительными и исключенными. `maxAge` является строкой, длительность, используя следующие единицы суффиксы:

* `d` : дни
* `h` : ч
* `m` : мин
* `s` : секунды
* `u` : миллисекунды

Например, строка `3d12h` будет кешировать контент на срок до трех с половиной дней.

{@a timeout}
#### `timeout` 
Эта строка длительности указывает время ожидания сети. Время ожидания сети - это время, в течение которого работник службы Angular будет ждать ответа от сети, прежде чем использовать кэшированный ответ, если он настроен для этого. `timeout` является строкой, длительность, используя следующие единицы суффиксы:

* `d` : дни
* `h` : ч
* `m` : мин
* `s` : секунды
* `u` : миллисекунды

Например, строка `5s30u` переведет на пять секунд и 30 миллисекунд времени ожидания сети.

{@a strategy}
#### `strategy` 

Работник службы Angular может использовать любую из двух стратегий кэширования для ресурсов данных.

* `performance` по умолчанию оптимизируется для максимально быстрых ответов. Если ресурс существует в кэше, используется кэшированная версия, и сетевой запрос не выполняется. Это учитывает некоторую несостоятельность, в зависимости от `maxAge`, в обмен на лучшую производительность. Это подходит для ресурсов, которые не меняются часто; например, изображения аватара пользователя.

* `freshness` оптимизируется для валюты данных, преимущественно выбирая запрошенные данные из сети. Только если время сети истекло, согласно `timeout`, запрос возвращается в кеш. Это полезно для ресурсов, которые часто меняются; например, остатки на счетах.

{@a navigationurls}
## `navigationUrls` 

Этот необязательный раздел позволяет указать пользовательский список URL-адресов, которые будут перенаправлены в индексный файл.

{@a handling-navigation-requests}
### Обработка навигационных запросов

ServiceWorker будет перенаправлять запросы навигации, которые не соответствуют ни одному `asset` или `data` группы к указанному [индексный файл](#index-file). Запрос считается запрос навигации, если:

1. Его [режим](https://developer.mozilla.org/en-US/docs/Web/API/Request/mode)является `navigation`.
2. Он принимает `text/html` ответ (определяется значением `Accept` заголовок).
3. Его URL соответствует определенным критериям (см. Ниже).

По умолчанию эти критерии:

1. URL не должен содержать расширение файла (т.е. `.`) в последнем сегменте пути.
2. URL не должен содержать `__`.

{@a matching-navigation-request-urls}
### Соответствие URL запроса навигации

Хотя эти критерии по умолчанию подходят в большинстве случаев, иногда желательно настроить другие правила. Например, вы можете игнорировать определенные маршруты (которые не являются частью приложения Angular) и передавать их на сервер.

Это поле содержит массив URL-адресов и [глобальных](#glob-patterns)шаблонов URL-адресов, которые будут сопоставляться во время выполнения. Он может содержать как негативные паттерны (т. Е. Паттерны, начинающиеся с `!`) и неотрицательные шаблоны и URL.

Только запросы, URL-адреса которых соответствуют _any_ неотрицательных URL / шаблонов и _none_ отрицательных, будут считаться навигационными запросами. URL-запрос будет игнорироваться при сопоставлении.

Если поле опущено, то по умолчанию:

```ts
[
  '/**', // Include all URLs.
  '!/**/*.*', // Exclude URLs to files.
  '!/**/*__*', // Exclude URLs containing `__` in the last segment.
  '!/**/*__*/**', // Exclude URLs containing `__` in any other segment.
]
```
