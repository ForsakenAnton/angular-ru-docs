{@a security}
# Безопасность

Эта страница описывает встроенный Angular
защита от распространенных уязвимостей веб-приложений и таких атак, как кросс-сайт
скриптовые атаки. Он не охватывает безопасность на уровне приложений, такую ​​как аутентификация (_Who
Этот пользователь? _) И авторизация (_What может этот пользователь делать? _).

Для получения дополнительной информации об атаках и мерах по их устранению, описанных ниже, см. [Руководство OWASP Project](https://www.owasp.org/index.php/Category:OWASP_Guide_Project).

Вы можете запустить <live-example></live-example>в Stackblitz и скачать код оттуда.



<h2 id='report-issues'>
  Сообщение об уязвимостях
</h2>



Чтобы сообщить об уязвимостях в самом Angular, напишите нам по адресу [security@angular.io](mailto:security@angular.io).

Для получения дополнительной информации о том, как Google решает проблемы безопасности, см. [Безопасность Google. Философия](https://www.google.com/about/appsecurity/).



<h2 id='best-practices'>
  Лучшие практики
</h2>



* **Будьте в курсе последних выпусков библиотеки Angular.**
Мы регулярно обновляем библиотеки Angular, и эти обновления могут исправлять дефекты безопасности, обнаруженные в
предыдущие версии. Проверь Angular [сдача. журнал](https://github.com/angular/angular/blob/master/CHANGELOG.md)для обновлений, связанных с безопасностью.

* **Не изменяйте свою копию Angular.**
Частные, настроенные версии Angular имеют тенденцию отставать от текущей версии и могут не включать
важные исправления безопасности и улучшения. Вместо этого поделитесь своими Angularи улучшениями с
сообщество и сделать запрос на получение.

* **Избегайте использования Angular API, помеченного в документации как «_Security Risk_».**
Для получения дополнительной информации см [Доверяя безопасные значения](guide/security#bypass-security-apis)раздел этой страницы.



<h2 id='xss'>
  Предотвращение межсайтовых скриптов (XSS)
</h2>



[Межсайтовый скриптинг (XSS)](https://en.wikipedia.org/wiki/Cross-site_scripting)позволяет злоумышленникам
внедрить вредоносный код в веб-страницы. Такой код может затем, например, украсть пользовательские данные (в
Частности, Логин данных) или выполнять действия, чтобы выдавать пользователю. Это один из самых
распространенные атаки в сети.

Чтобы заблокировать атаки XSS, вы должны предотвратить попадание вредоносного кода в DOM (объектную модель документа). Например, если
злоумышленники могут заставить вас вставить  `<script>`  тега в DOM, они могут запускать произвольный код
Ваш сайт. Атака не ограничивается  `<script>`  теги - множество элементов и свойств в
DOM разрешает выполнение кода, например, `<img onerror="..."> ` и ` <a href="javascript:...">` . Если
контролируемые злоумышленником данные поступают в DOM, ожидайте уязвимостей в безопасности.

{@a angular’s-cross-site-scripting-security-model}
### Модель безопасности межсайтовых скриптов Angular

Чтобы систематически блокировать ошибки XSS, Angular обрабатывает все значения как ненадежные по умолчанию. Когда значение
вставляется в DOM из шаблона, через свойство, атрибут, стиль, класс связывания, или интерполяции
Angular дезинфицирует и избегает ненадежных ценностей.

_Ангулярные шаблоны такие же, как исполняемый код_: HTML, атрибуты и выражения привязки
(но не связанные значения) в шаблонах доверяют безопасности. Это означает, что приложения должны
не допускать попадания значений, которые злоумышленник может сделать, в исходный код
шаблон. Никогда не создавайте исходный код шаблона, объединяя пользовательский ввод и шаблоны.
Чтобы предотвратить эти уязвимости, используйте
[отсутствует шаблон компилятора](guide/security#offline-template-compiler), также известный как _template injection_.

{@a sanitization-and-security-contexts}
### Санитарная обработка и безопасность

_Sanitization_ - это проверка ненадежного значения, превращение его в значение, в которое можно безопасно вставить
ДОМ. Во многих случаях очистка не меняет значение вообще. Санитарная обработка зависит от контекста
значение, которое безвредно в CSS, потенциально опасно в URL.

Angular определяет следующие контексты безопасности:

* **HTML** используется при интерпретации значения как HTML, например, при привязке к  `innerHtml`.
* **Стиль** используется при связывании CSS в  `style`  свойство.
* **URL** используется для свойств URL, таких как `<a href>`.
* **Ресурсный URL-адрес** - это URL-адрес, который будет загружен и выполнен в виде кода, например, в `<script src>`.

Angular очищает ненадежные значения для HTML, стилей и URL; дезинфицирующий URL - ресурсов не
возможно, потому что они содержат произвольный код. В режиме разработки Angular выводит предупреждение консоли
когда это должно изменить значение во время санитарной обработки.

{@a sanitization-example}
### Пример санации

Следующий шаблон связывает значение  `htmlSnippet`, один раз путем интерполяции его в элемент
содержание, и один раз, связав его с  `innerHTML`  свойство элемента:


<code-example path="security/src/app/inner-html-binding.component.html" header="src/app/inner-html-binding.component.html"></code-example>



Интерполированный контент всегда экранируется - HTML не интерпретируется и отображается браузер
Angular скобки в текстовом содержимом элемента.

Чтобы интерпретировать HTML, свяжите его со свойством HTML, таким как  `innerHTML`  . Но обязательна
значение, которое злоумышленник может контролировать в  `innerHTML`  обычно вызывает XSS
уязвимость. Например, код, содержащийся в  `<script>`  тег выполняется:


<code-example path="security/src/app/inner-html-binding.component.ts" header="src/app/inner-html-binding.component.ts (class)" region="class"></code-example>



Angular распознает значение как небезопасное и автоматически очищает его, удаляя  `<script>` 
тег, но сохраняет безопасный контент, такой как  `<b>`  элемент.


<div class="lightbox">
  <img src='generated/images/guide/security/binding-inner-html.png' alt='A screenshot showing interpolated and bound HTML values'>
</div>


{@a direct-use-of-the-dom-apis-and-explicit-sanitization-calls}
### Прямое использование API DOM и явные вызовы очистки

Встроенные в DOM API-интерфейсы браузера не защищают вас автоматически от уязвимостей системы безопасности.
Например,  `document`, доступный через узел  `ElementRef`  и многие сторонние API
содержат небезопасные методы. Точно так же, если вы взаимодействуете с другими библиотеками, которые манипулируют
DOM, вы, вероятно, не будете иметь такую ​​же автоматическую очистку, как с Angularи интерполяциями.
Избегайте прямого взаимодействия с DOM и вместо этого используйте шаблоны Angular, где это возможно.

В случаях, когда это неизбежно, используйте встроенные функции Angular очистки.
Очистите ненадежные значения с помощью [DomSanitizer.sanitize](api/platform-browser/DomSanitizer#sanitize)
метод и соответствующий  `SecurityContext`  . Эта функция также принимает значения, которые были
помечены как доверенные с помощью  `bypassSecurityTrust`  ... функционирует и не будет их дезинфицировать
как [описано ниже](#bypass-security-apis).

{@a content-security-policy}
### Политика безопасности контента

Политика безопасности контента (CSP) - это глубокая защита
Техника предотвращения XSS. Чтобы включить CSP, настройте свой веб-сервер для возврата соответствующего
 `Content-Security-Policy` HTTP-заголовок . Узнайте больше о политике безопасности контента на
[Введение в политику безопасности контента](http://www.html5rocks.com/en/tutorials/security/content-security-policy/)
на веб-сайте HTML5Rocks.


{@a offline-template-compiler}


{@a use-the-offline-template-compiler}
### Используйте автономный компилятор шаблонов

Автономный компилятор шаблонов предотвращает целый класс уязвимостей, называемый внедрением шаблонов
и значительно повышает производительность приложений. Используйте автономный компилятор шаблонов в производстве
развертывание; не динамически генерировать шаблоны. Angular доверяет шаблону кода, поэтому генерирует
шаблоны, в частности шаблоны, содержащие пользовательские данные, обходят встроенные средства защиты Angular.
Информацию о динамическом построении безопасных форм см
[Динамические формы](guide/dynamic-form)страница руководства.

{@a server-side-xss-protection}
### Защита XSS на стороне сервера

HTML, созданный на сервере, уязвим для инъекционных атак. Внедрение кода шаблона в
Angular приложение - это то же самое, что внедрение исполняемого кода в
Приложение: дает злоумышленнику полный контроль над приложением. Чтобы предотвратить это,
использовать язык шаблонов, который автоматически экранирует значения для предотвращения уязвимостей XSS в
сервер. Не генерируйте Angular шаблоны на стороне сервера, используя язык шаблонов; делаю это
несет в себе высокий риск внедрения уязвимостей при внедрении шаблонов.



<h2 id='bypass-security-apis'>
  Доверие безопасным ценностям
</h2>



Иногда приложения действительно должны включать исполняемый код, отображать  `<iframe>`  от некоторых
URL или создать потенциально опасные URL. Для предотвращения автоматической санации в любом из них
В ситуациях вы можете сообщить Angular, что вы проверили значение, проверили, как оно было сгенерировано и создано
уверен, что он всегда будет в безопасности. Но *будь осторожен*. Если вы доверяете значению, которое может быть вредоносным, вы
внедряем уязвимость безопасности в ваше приложение. Если сомневаешься, найди профессионала
эксперт по безопасности.

Чтобы пометить значение как доверенное, введите  `DomSanitizer`  и вызвать один из
следующие методы:

*  `bypassSecurityTrustHtml` 
*  `bypassSecurityTrustScript` 
*  `bypassSecurityTrustStyle` 
*  `bypassSecurityTrustUrl` 
*  `bypassSecurityTrustResourceUrl` 

Помните, является ли значение безопасным, зависит от контекста, поэтому выберите правильный контекст для
Ваше предполагаемое использование стоимости. Представьте, что следующий шаблон должен привязать URL к
 `javascript:alert(...)` вызов:


<code-example path="security/src/app/bypass-security.component.html" header="src/app/bypass-security.component.html (URL)" region="URL"></code-example>



Обычно Angular автоматически очищает URL-адрес, отключает опасный код и
в режиме разработки записывает это действие на консоль. Чтобы предотвратить
пометьте значение URL как надежный URL, используя  `bypassSecurityTrustUrl`  вызов:


<code-example path="security/src/app/bypass-security.component.ts" header="src/app/bypass-security.component.ts (trust-url)" region="trust-url"></code-example>



<div class="lightbox">
  <img src='generated/images/guide/security/bypass-security-component.png' alt='A screenshot showing an alert box created from a trusted URL'>
</div>



Если вам нужно преобразовать пользовательский ввод в доверенное значение, используйте
Контроллер метод. Следующий шаблон позволяет пользователям вводить идентификатор видео YouTube и загружать
соответствующее видео в  `<iframe>`  .  `<iframe src>` Атрибут является безопасностью URL ресурса
контекст, потому что ненадежный источник может, например, переправить загрузку файлов, что ничего не подозревающих пользователей
мог выполнить. Поэтому вызовите метод на контроллере для создания надежного URL-адреса видео, которое вызывает
Angular, чтобы позволить связывание в `<iframe src>` :


<code-example path="security/src/app/bypass-security.component.html" header="src/app/bypass-security.component.html (iframe)" region="iframe"></code-example>



<code-example path="security/src/app/bypass-security.component.ts" header="src/app/bypass-security.component.ts (trust-video-url)" region="trust-video-url"></code-example>




<h2 id='http'>
  Уязвимости на уровне HTTP
</h2>



Angular имеет встроенную поддержку, чтобы помочь предотвратить две распространенные уязвимости HTTP, межсайтовый запрос
подделка (CSRF или XSRF) и включение межсайтовых скриптов (XSSI). Оба из них должны быть смягчены в первую очередь
на стороне сервера, но Angular предоставляет помощников для облегчения интеграции на стороне клиента.


<h3 id='xsrf'>
  Подделка межсайтовых запросов
</h3>



В подделке межсайтовых запросов (CSRF или XSRF) злоумышленник обманывает пользователя при посещении
другая веб-страница (например,  `evil.com`) со злонамеренным кодом, который тайно отправляет вредоносный запрос
на веб-сервер приложения (например,  `example-bank.com`).

Предположим, что пользователь вошел в приложение на  `example-bank.com`.
Пользователь открывает электронное письмо и щелкает ссылку на  `evil.com`, который открывается в новой вкладке.

 `evil.com` Страница немедленно отправляет вредоносный запрос  `example-bank.com`.
Возможно, это запрос на перевод денег со счета пользователя на счет злоумышленника.
Браузер автоматически отправляет  `example-bank.com`  cookie (включая файлы cookie для аутентификации) с этим запросом.

Если  `example-bank.com`  сервер не хватает защиты XSRF, он не может сказать, разница между законным
запрос из заявки и поддельный запрос от  `evil.com`.

Чтобы предотвратить это, приложение должно гарантировать, что пользовательский запрос происходит из реального
приложение, а не с другого сайта.
Сервер и клиент должны сотрудничать, чтобы предотвратить эту атаку.

В обычной технике анти-XSRF сервер приложений отправляет случайным образом
сгенерированный токен аутентификации в куки.
Код клиента считывает куки и добавляет пользовательский заголовок запроса с токеном во все последующие запросы.
Сервер сравнивает полученное значение cookie со значением заголовка запроса и отклоняет запрос, если значения отсутствуют или не совпадают.

Этот метод эффективен, потому что все браузеры реализуют политику _same origin_. Только код с сайта
на котором установлены куки могут читать куки с этого сайта и устанавливать пользовательские заголовки на запросы к этому сайту.
Это означает, что только ваше приложение может прочитать этот токен cookie и установить собственный заголовок. Вредоносный код на  `evil.com`  не может.

Angular's  `HttpClient`  имеет встроенную поддержку клиентской части этого метода. Подробнее об этом [читайте в руководстве HttpClient](/guide/http#security-xsrf-protection).

Для получения информации о CSRF в открытом проекте безопасности веб-приложений (OWASP) см
<a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29">Подделка межсайтовых запросов (CSRF) </a>и
<a href="https://www.owasp.org/index.php/CSRF_Prevention_Cheat_Sheet">Шпаргалка по предотвращению межсайтовых запросов (CSRF) </a>.
Статья Стэнфордского университета
<a href="https://seclab.stanford.edu/websec/csrf/csrf.pdf">Надежная защита для подделки межсайтовых запросов </a>является богатым источником деталей.

Смотрите также Дейва Смита, легкого для понимания
<a href="https://www.youtube.com/watch?v=9inczw6qtpY" title="Cross Site Request Funkery Securing Your Angular Apps From Evil Doers">поговорить о XSRF на AngularConnect 2016 </a>.


<h3 id='xssi'>
  Межсайтовый скрипт включения (XSSI)
</h3>



Включение межсайтового скрипта, также известного как уязвимость JSON, может позволить веб-сайту злоумышленника сделать это
читать данные из JSON API. Атака работает на старых браузерах путем переопределения нативного JavaScript
конструкторы объектов, а затем включение URL-адреса API с использованием  `<script>`  тег.

Эта атака успешна только в том случае, если возвращаемый JSON исполняется как JavaScript. Серверы могут
предотвратить атаку, добавив префикс всех ответов JSON, чтобы сделать их неисполняемыми, по соглашению, используя
известная строка `") ]}',\n"`.

Angular's  `HttpClient`  Библиотека распознает это соглашение и автоматически удаляет строку
 `") ]}',\n"` из всех ответов перед дальнейшим анализом.

Для получения дополнительной информации см. Раздел XSSI этого [блог о веб-безопасности Google. Post](https://security.googleblog.com/2011/05/website-security-for-webmasters.html).



<h2 id='code-review'>
  Аудит Angular приложений
</h2>



Angular-приложения должны следовать тем же принципам безопасности, что и обычные веб-приложения
должны быть проверены как таковые. Специфичные для углов API, которые должны проверяться в обзоре безопасности
такие как [_bypassSecurityTrust_](guide/security#bypass-security-apis)методы, отмеченные в документации
как чувствительный к безопасности.
