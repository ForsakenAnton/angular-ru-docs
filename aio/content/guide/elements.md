{@a angular-elements-overview}
# Обзор Angular элементов

_Angular elements_ - это Angular компоненты, упакованные как _custom elements_ (также называемые веб-компонентами), веб-стандарт для определения новых HTML-элементов без учета фреймворка.

[Пользовательские элементы](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements)- это функция веб-платформы, в настоящее время поддерживаемая Chrome, Edge (на основе Chromium), Firefox, Opera и Safari и доступная в других браузерах через полифиллы (см. браузеров [Поддержка](#browser-support)).
Пользовательский элемент расширяет HTML, позволяя вам определять тег, содержимое которого создается и контролируется кодом JavaScript.
Браузер поддерживает  `CustomElementRegistry`  определенных пользовательских элементов, который отображает инстанцируемый класс JavaScript в тег HTML.

 `@angular/elements` Пакет экспортирует  `createCustomElement()`  API который обеспечивает мост между компонентным интерфейсом Angular и функцией обнаружения изменений во встроенный DOM API.

Преобразование компонента в пользовательский элемент делает всю необходимую инфраструктуру Angular доступной для браузера.
Создание пользовательского элемента является простым и понятным и автоматически связывает ваше определяемое компонентом представление с обнаружением изменений и привязкой данных, сопоставляя функциональность Angular с соответствующими собственными эквивалентами HTML.

<div class="alert is-helpful">

    Мы работаем над пользовательскими элементами, которые могут использоваться веб-приложениями, созданными на других платформах.
    Минимальная, автономная версия Angular Framework будет внедрена как сервис для поддержки функции обнаружения изменений и привязки данных компонента.
    Для получения дополнительной информации о направлении развития, проверьте это [видео презентация](https://www.youtube.com/watch?v=Z1gLFPLVJjY&t=4s).

</div>

{@a using-custom-elements}
## Использование пользовательских элементов

Пользовательские элементы загружаются сами - они запускаются автоматически при добавлении в DOM и автоматически уничтожаются при удалении из DOM. Как только пользовательский элемент добавляется в DOM для любой страницы, он выглядит и ведет себя как любой другой HTML-элемент и не требует специальных знаний об англоязычных терминах или соглашениях об использовании.

- <b>Легкий динамический контент в приложении Angular </b>

  Преобразование компонента в пользовательский элемент обеспечивает простой способ создания динамического HTML-содержимого в приложении Angular. Содержимое HTML, которое вы добавляете непосредственно в DOM в приложении Angular, обычно отображается без обработки Angular, если только вы не определите _dynamic component_, добавив свой собственный код для подключения тега HTML к данным приложения и участия в обнаружении изменений. С пользовательским элементом вся эта проводка обрабатывается автоматически.

- <b>Содержательные приложения </b>

  Если у вас есть приложение с богатым контентом, такое как приложение Angular, которое представляет эту документацию, пользовательские элементы позволят вам предоставить поставщикам контента сложные функциональные возможности Angular, не требуя знания Angular. Например, такой Angular справочник добавляется непосредственно в DOM с помощью инструментов Angular навигации, но может включать специальные элементы, такие как  `<code-snippet>`  который выполняет сложные операции. Все, что вам нужно сообщить поставщику контента, - это синтаксис вашего пользовательского элемента. Им не нужно ничего знать об Angular или что-либо о структурах данных или реализации вашего компонента.

{@a how-it-works}
### Как это работает

Использовать  `createCustomElement()`  для преобразования компонента в класс, который можно зарегистрировать в браузере как пользовательский элемент.
После того, как вы зарегистрировать настроенный класс с настраиваемым-элементным реестром браузера, вы можете использовать новый элемент так же, как встроенный в HTML - элементе контента, который вы добавляете непосредственно в DOM:

```
<my-popup message="Use Angular!"></my-popup>
```

Когда ваш пользовательский элемент размещается на странице, браузер создает экземпляр зарегистрированного класса и добавляет его в DOM. Содержимое предоставляется шаблоном компонента, который использует синтаксис шаблона Angular, и визуализируется с использованием данных компонента и DOM. Входные свойства в компоненте соответствуют входным атрибутам для элемента.

<div class="lightbox">
  <img src="generated/images/guide/elements/customElement1.png" alt="Custom element in browser" class="left">
</div>

<hr class="clear">

{@a transforming-components-to-custom-elements}
## Преобразование компонентов в пользовательские элементы

Angular обеспечивает  `createCustomElement()`  для преобразования Angular компонента
вместе с его зависимостями, к пользовательскому элементу. Функция собирает компоненты
наблюдаемые свойства, а также функциональность Angular, необходимая браузеру
создавать и уничтожать экземпляры, а также обнаруживать и реагировать на изменения.

Процесс преобразования реализует  `NgElementConstructor`  интерфейс, и создает
Класс конструктора, который настроен на создание самозагрузочного экземпляра вашего компонента.

Используйте функцию JavaScript,  `customElements.define()`, чтобы зарегистрировать настроенный конструктор
и связанный с ним тег пользовательского элемента с браузером  `CustomElementRegistry`.
Когда браузер обнаруживает тег для зарегистрированного элемента, он использует конструктор для создания экземпляра пользовательского элемента.

<div class="lightbox">
  <img src="generated/images/guide/elements/createElement.png" alt="Transform a component to a custom element" class="left">
</div>

{@a mapping}
### Mapping

Пользовательский элемент _hosts_ Angular компонент, обеспечивающий мост между данными и логикой, определенной в компоненте, и стандартными API-интерфейсами DOM. Свойства и логика компонентов отображаются непосредственно в атрибуты HTML и систему событий браузера.

- API создания анализирует компонент в поисках входных свойств и определяет соответствующие атрибуты для пользовательского элемента. Он преобразует имена свойств, чтобы сделать их совместимыми с пользовательскими элементами, которые не распознают различия в регистре. Полученные имена атрибутов используют разделенные дефисом строчные буквы. Например, для компонента с `@Input('myInputProp') inputProp`, соответствующий пользовательский элемент определяет атрибут  `my-input-prop`.

- Выходные данные компонента отправляются в виде HTML [пользовательские события](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent), а имя пользовательского события соответствует имени выходного файла. Например, для компонента с `@Output() valueChanged = new EventEmitter()`, соответствующий пользовательский элемент будет отправлять события с именем «valueChanged», и отправленные данные будут сохранены в событии  `detail`  собственности. Если вы предоставляете псевдоним, это значение используется; например, `@Output('myClick') clicks = new EventEmitter<string>();` приводит к событиям отправки с именем «myClick».


Для получения дополнительной информации см. Документацию веб-компонента для [Создание пользовательских событий](https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events#Creating_custom_events).


{@a browser-support}

{@a browser-support-for-custom-elements}
## Браузерная поддержка пользовательских элементов

Недавно разработанная [настраиваемые элементы](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements)функция веб-платформы в настоящее время поддерживается во многих браузерах.

<table>
<tr>
  <th>Browser </th>
  <th>Поддержка пользовательских элементов </th>
</tr>
<tr>
  <td>Хром</td>
  <td>Поддерживается изначально. </td>
</tr>
<tr>
  <td>Edge (на основе хрома) </td>
  <td>Поддерживается изначально. </td>
</tr>
<tr>
  <td>Firefox </td>
  <td>Поддерживается изначально. </td>
</tr>
<tr>
  <td>Опера </td>
  <td>Поддерживается изначально. </td>
</tr>
<tr>
  <td>Safari </td>
  <td>Поддерживается изначально. </td>
</tr>
</table>

В браузерах, которые изначально поддерживают пользовательские элементы, спецификация требует, чтобы разработчики использовали классы ES2015 для определения пользовательских элементов - разработчики могут включить это, установив `target: "es2015"` собственность в их проекте  `tsconfig.json`  . Поскольку поддержка Custom Element и ES2015 может быть доступна не во всех браузерах, разработчики могут вместо этого выбрать использование полифилла для поддержки старых браузеров и кода ES5.

Используйте [Angular CLI](cli)для автоматической настройки вашего проекта с правильным заполнением: `ng add @angular/elements --name=*your_project_name*`.
- Для получения дополнительной информации о полифиллах см. [Документация по полифиллам](https://www.webcomponents.org/polyfills).

- Для получения дополнительной информации о поддержке браузера Angular см. [Поддержка браузера](guide/browser-support).


{@a example-a-popup-service}
## Пример: всплывающая служба

Ранее, когда вы хотели добавить компонент в приложение во время выполнения, вы должны были определить _dynamic component_. Модуль приложения должен будет перечислить ваш динамический компонент в  `entryComponents`, чтобы приложение не ожидало, что оно будет присутствовать при запуске, а затем вам придется загрузить его, прикрепить к элементу в DOM и подключить все зависимости, обнаружение изменений и обработку событий, как описано в [Динамический загрузчик компонентов](guide/dynamic-component-loader).

Использование пользовательского элемента Angular делает процесс намного проще и прозрачнее, автоматически предоставляя всю инфраструктуру и структуру - все, что вам нужно сделать, - это определить, какой тип обработки событий вы хотите. (Вам все равно придется исключить компонент из компиляции, если вы не собираетесь использовать его в своем приложении.)

Пример приложения Popup Service (показан ниже) определяет компонент, который вы можете загружать динамически или преобразовывать в пользовательский элемент.

-  `popup.component.ts` определяет простой всплывающий элемент, который отображает входное сообщение с некоторой анимацией и стилем.
-  `popup.service.ts` создает инъецируемую службу, которая предоставляет два разных способа вызова PopupComponent; как динамический компонент или как пользовательский элемент. Обратите внимание, насколько больше настроек требуется для метода динамической загрузки.
-  `app.module.ts` добавляет PopupComponent в модуль  `entryComponents`  список, чтобы исключить его из компиляции и избежать предупреждений или ошибок при запуске.
-  `app.component.ts` определяет корневой компонент приложения, который использует PopupService для добавления всплывающего окна в DOM во время выполнения. Когда приложение запускается, конструктор корневого компонента преобразует PopupComponent в пользовательский элемент.

Для сравнения в демоверсии показаны оба метода. Одна кнопка добавляет всплывающее окно, используя метод динамической загрузки, а другая использует пользовательский элемент. Вы можете видеть, что результат тот же; только подготовка отличается.

<code-tabs>

  <code-pane header="popup.component.ts" path="elements/src/app/popup.component.ts">

  </code-pane>

  <code-pane header="popup.service.ts" path="elements/src/app/popup.service.ts">

  </code-pane>

  <code-pane header="app.module.ts" path="elements/src/app/app.module.ts">

  </code-pane>

  <code-pane header="app.component.ts" path="elements/src/app/app.component.ts">

  </code-pane>
</code-tabs>

<!--
  StackBlitz transpiles code to ES5. The live example will not work without a polyfill.
  Only offer a  `.zip`  to download for now.
-->
Вы можете скачать полный код для примера <live-example downloadOnly>здесь </live-example>.


{@a typings-for-custom-elements}
## Наборы для пользовательских элементов

Универсальные API DOM, такие как  `document.createElement()`  или  `document.querySelector()`, возвращает тип элемента, который подходит для указанных аргументов. Например, позвонив  `document.createElement('a')`  вернет  `HTMLAnchorElement`, который, как знает TypeScript, имеет  `href`  собственности. По аналогии,  `document.createElement('div')`  вернет  `HTMLDivElement`, который, как знает TypeScript, не имеет  `href`  собственности.

При вызове с неизвестными элементами, такими как имя пользовательского элемента (  `popup-element`  в нашем примере), методы будут возвращать универсальный тип, такой как  `HTMLElement`, поскольку TypeScript не может определить правильный тип возвращаемого элемента.

Пользовательские элементы, созданные с Angular расширением  `NgElement`  (который в свою очередь расширяется  `HTMLElement`). Кроме того, эти пользовательские элементы будут иметь свойство для каждого входа соответствующего компонента. Например, наш  `popup-element`  будет иметь  `message`  свойство типа  `string`.

Есть несколько вариантов, если вы хотите получить правильные типы для ваших пользовательских элементов. Давайте предположим, что вы создаете  `my-dialog`  пользовательских элементов на основе следующих компонентов:

```ts
@Component(...)
class MyDialog {
  @Input() content: string;
}
```

Самый простой способ получить точную типизацию - привести возвращаемое значение соответствующих методов DOM к правильному типу. Для этого вы можете использовать  `NgElement`  и  `WithProperties`  Типы (оба экспортируются из  `@angular/elements`)

```ts
const aDialog = document.createElement('my-dialog') as NgElement & WithProperties<{content: string}>;
aDialog.content = 'Hello, world!';
aDialog.content = 123;  // <-- ERROR: TypeScript knows this should be a string.
aDialog.body = 'News';  // <-- ERROR: TypeScript knows there is no  `body`  property on  `aDialog`.
```

Это хороший способ быстро получить функции TypeScript, такие как проверка типов и поддержка автозаполнения, для вашего пользовательского элемента. Но это может стать громоздким, если вам это нужно в нескольких местах, потому что вы должны приводить тип возвращаемого значения в каждом случае.

Альтернативным способом, который требует только определения типа каждого пользовательского элемента, является увеличение  `HTMLElementTagNameMap`, который TypeScript использует для вывода типа возвращаемого элемента на основе его имени тега (для таких методов DOM, как  `document.createElement()`, `document.querySelector()`  и т.д.):

```ts
declare global {
  interface HTMLElementTagNameMap {
    'my-dialog': NgElement & WithProperties<{content: string}>;
    'my-other-element': NgElement & WithProperties<{foo: 'bar'}>;
    ...
  }
}
```

Теперь, машинопись может вывести правильный тип так же, как это делает для встроенных элементов:

```ts
document.createElement('div')               //--> HTMLDivElement (built-in element)
document.querySelector('foo')               //--> Element        (unknown element)
document.createElement('my-dialog')         //--> NgElement & WithProperties<{content: string}> (custom element)
document.querySelector('my-other-element')  //--> NgElement & WithProperties<{foo: 'bar'}>      (custom element)
```
