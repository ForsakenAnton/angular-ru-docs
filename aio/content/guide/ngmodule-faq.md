{@a ngmodule-faq}
# NgModule FAQ

NgModules помогают организовать приложение в единые блоки функциональности.

Эта страница отвечает на вопросы, которые многие разработчики задают о дизайне и реализации NgModule.


{@a what-classes-should-i-add-to-the-declarations-array}
## Какие классы я должен добавить к  `declarations`  массив ?

Добавьте [объявляемые](guide/bootstrapping#the-declarations-array)классы - компоненты, директивы и каналы - к  `declarations`  список.

Объявите эти классы в одном модуле приложения.
Объявите их в модуле, если они принадлежат этому конкретному модулю.

<hr/>

{@a q-declarable}

{@a what-is-a-declarable}
## Что такое _declarable_?

Объявление - это типы классов - компоненты, директивы и каналы
Вы можете добавить к модулю  `declarations`  список.
Это единственные классы, которые вы можете добавить в  `declarations`.

<hr/>

{@a what-classes-should-i-not-add-to-declarations}
## Какие классы я не должен добавлять  `declarations`  ?

Добавляйте только [объявляемые](guide/bootstrapping#the-declarations-array)классы в NgModule  `declarations`  список.

Вы *не* заявить следующее:

* Класс, который уже объявлен в другом модуле, будь то модуль приложения, @NgModule или сторонний модуль.
* Массив директив, импортированных из другого модуля.
Например, не объявляйте  `FORMS_DIRECTIVES`  от  `@angular/forms`  потому что  `FormsModule`  уже заявляет об этом.

* Модульные занятия.
* Классы обслуживания.
* Неангулярные классы и объекты, такие как
строки, числа, функции, модели сущностей, конфигурации, бизнес-логика и вспомогательные классы.

<hr/>


{@a why-list-the-same-component-in-multiple-ngmodule-properties}
## Зачем перечислять один и тот же компонент в нескольких  `NgModule`  свойства?

 `AppComponent` часто перечисляется в обоих  `declarations`  и  `bootstrap`.
Вы можете увидеть тот же компонент, перечисленный в  `declarations`, `exports`  и  `entryComponents`.

Хотя это кажется избыточным, эти свойства имеют разные функции.
Членство в одном списке не подразумевает членство в другом списке.

*  `AppComponent` может быть объявлен в этом модуле, но не загружен.
*  `AppComponent` может быть загружен в этом модуле, но объявлен в другом функциональном модуле.
* Компонент может быть импортирован из другого модуля приложения (поэтому вы не можете объявить его) и реэкспортироваться этим модулем.
* Компонент может быть экспортирован для включения в шаблон внешнего компонента
а также динамически загружается во всплывающем диалоге.

<hr/>

{@a what-does-cant-bind-to-x-since-it-isnt-a-known-property-of-y-mean}
## Что означает «Невозможно связать с« х », поскольку это не известное свойство у»?

Эта ошибка часто означает, что вы не объявили директиву "x"
или не импортировали модуль NgModule, к которому принадлежит «x».

<div class="alert is-helpful">

Возможно, вы объявили «x» в подмодуле приложения, но забыли его экспортировать.
Класс "x" не виден другим модулям, пока вы не добавите его в  `exports`  список.

</div>

<hr/>

{@a what-should-i-import}
## Что я должен импортировать?

Импортировать NgModules, чьи публичные (экспортируемые) [декларируемые классы](guide/bootstrapping#the-declarations-array)
вам нужно сослаться в шаблонах компонентов этого модуля.

Это всегда означает импорт  `CommonModule`  from  `@angular/common`  для доступа к
Angular директивы, такие как  `NgIf`  и  `NgFor`.
Вы можете импортировать его напрямую или из другого модуля NgModule, который [реэкспортирует](guide/ngmodule-faq#q-reexport)его.

Импортировать  `FormsModule`  from  `@angular/forms` 
если ваши компоненты имеют  `[(ngModel)]`  выражения двустороннего связывания.

Импортируйте модули _shared_ и _feature_, когда компоненты этого модуля включают их
компоненты, директивы и трубы.

Импорт [BrowserModule](guide/ngmodule-faq#q-browser-vs-common-module)только в корень  `AppModule`.

<hr/>

{@a q-browser-vs-common-module}

{@a should-i-import-browsermodule-or-commonmodule}
## Должен ли я импортировать  `BrowserModule`  или  `CommonModule`  ?

Модуль корневого приложения,  `AppModule`, почти каждого приложения браузера
следует импортировать  `BrowserModule`  from  `@angular/platform-browser`.

 `BrowserModule` предоставляет сервисы, которые необходимы для запуска и запуска приложения браузера.

 `BrowserModule` также реэкспортирует  `CommonModule`  from  `@angular/common`,
Это означает, что компоненты в  `AppModule`  Модуль также имеет доступ к
Angular директивы, которые нужны каждому приложению, такие как  `NgIf`  и  `NgFor`.

Не импортировать  `BrowserModule`  в любом другом модуле.
*Функциональные модули* и *лениво загруженные модули* должны импортировать  `CommonModule`  вместо.
Им нужны общие директивы. Им не нужно переустанавливать поставщиков приложений.

Импорт  `CommonModule`  также освобождает функциональные модули для использования на _any_ целевой платформе, а не только в браузерах.

<hr/>

{@a q-reimport}

{@a what-if-i-import-the-same-module-twice}
## Что если я импортирую один и тот же модуль дважды?

Это не проблема. Когда три модуля все импорт модуль «A»,
Angular оценивает модуль 'A' один раз, когда он впервые сталкивается с ним, и больше не делает этого.

Это правда на любом уровне  `A`  появляется в иерархии импортированных NgModules.
Когда модуль «B» импортирует модуль «A», модуль «C» импортирует «B», а модуль «D» импортирует `[C, B, A]`,
затем «D» запускает оценку «C», которая запускает оценку «B», которая оценивает «A».
Когда Angular добирается до «B» и «A» в «D», они уже кешируются и готовы к работе.

Angular не любит NgModules с круговыми ссылками, поэтому не позволяйте модулю «A» импортировать модуль «B», который импортирует модуль «A».

<hr/>

{@a q-reexport}

{@a what-should-i-export}
## Что я должен экспортировать?

Экспортируйте [объявляемые](guide/bootstrapping#the-declarations-array)классы, которые компоненты в _other_ NgModules
могут ссылаться в своих шаблонах.
Если вы не экспортируете декларируемый класс, он остается _private_, видимым только для других компонентов
объявлено в этом NgModule.

Вы можете экспортировать любой декларируемый класс - компоненты, директивы и каналы
он объявлен в этом NgModule или в импортированном NgModule.

Вы _можете_ реэкспортировать все импортированные NgModules, которые эффективно реэкспортируют все их экспортированные классы.
NgModule может даже экспортировать модуль, который он не импортирует.

<hr/>

{@a what-should-i-*not*-export}
## Что я должен *не* экспортировать?

Не экспортировать следующее:

* Частные компоненты, директивы и каналы, которые вам нужны только внутри компонентов, объявленных в этом NgModule.
Если вы не хотите, чтобы другой NgModule видел его, не экспортируйте его.
* Не декларируемые объекты, такие как службы, функции, конфигурации и модели объектов.
* Компоненты, которые загружаются только динамически маршрутизатором или при начальной загрузке.
Такие [входные компоненты](guide/ngmodule-faq#q-entry-component-defined)никогда не могут быть выбраны в шаблоне другого компонента.
Хотя их экспорт не приносит вреда, он также не приносит никакой пользы.
* Чистые сервисные модули, которые не имеют публичных (экспортируемых) объявлений.
Например, нет смысла реэкспортировать  `HttpClientModule`  потому что он ничего не экспортирует.
Его единственная цель - добавить поставщиков услуг http в приложение в целом.

<hr/>



{@a can-i-re-export-classes-and-modules}
## Могу ли я повторно экспортировать классы и модули?

Абсолютно.

NgModules - отличный способ выборочно объединить классы из других NgModules и
реэкспортируйте их в сводный удобный модуль.

NgModule может реэкспортировать все NgModules, что эффективно реэкспортирует все их экспортируемые классы.
Собственный Angular  `BrowserModule`  экспортирует пару NgModules как это:

```typescript
  exports: [CommonModule, ApplicationModule]
```

NgModule может экспортировать комбинацию своих собственных объявлений, выбранных импортированных классов и импортированных NgModule.

Не беспокойтесь о реэкспорте чистых сервисных модулей.
Чистые сервисные модули не экспортируют [объявляемые](guide/bootstrapping#the-declarations-array)классы, которые мог бы использовать другой NgModule.
Например, нет смысла реэкспортировать  `HttpClientModule`  потому что он ничего не экспортирует.
Его единственная цель - добавить поставщиков услуг http в приложение в целом.


<hr/>


{@a what-is-the-forroot-method}
## Что  `forRoot()`  ?

 `forRoot()` Статический метод - это соглашение, облегчающее разработчикам настройку служб и поставщиков, которые предназначены для использования в качестве одиночных пакетов. Хороший пример  `forRoot()`  является  `RouterModule.forRoot()`.

Приложения проходят  `Routes`  объект в  `RouterModule.forRoot()`  для настройки всего приложения  `Router`  сервис с маршрутами.
 `RouterModule.forRoot()` возвращает [ModuleWithProviders](api/core/ModuleWithProviders).
Вы добавляете этот результат к  `imports`  список корня  `AppModule`.

Только позвонить и импортировать  `forRoot()`  в модуле корневого приложения,  `AppModule`.
Избегайте импорта его в любой другой модуль, особенно в модуль с отложенной загрузкой. Для большего
информация о  `forRoot()`  см [ `forRoot ()`  рисунок](guide/singleton-services#the-forroot-pattern)раздел [Singleton Services](guide/singleton-services)руководства.

Для службы вместо использования  `forRoot()`, укажите `providedIn: 'root'` на сервисе  `@Injectable()`  декоратор, который
делает сервис автоматически доступным для всего приложения и, таким образом, по умолчанию одноэлементным.

 `RouterModule` также предлагает  `forChild()`  Статический метод для настройки маршрутов лениво загруженных модулей.

 `forRoot() ` и ` forChild()` - это условные имена методов, которые
настроить службы в корневом и функциональном модулях соответственно.

Следуйте этому соглашению при написании аналогичных модулей с настраиваемыми поставщиками услуг.


<hr/>


{@a why-is-a-service-provided-in-a-feature-module-visible-everywhere}
## Почему сервис, предоставляемый в функциональном модуле, виден везде?

Поставщики, перечисленные в  `@NgModule.providers`  загрузочного модуля имеют область применения.
Добавление поставщика услуг в  `@NgModule.providers`  эффективно публикует сервис для всего приложения.

При импорте NgModule,
Angular добавляет поставщиков услуг модуля (содержимое его  `providers`  список)
к корневому инжектору приложения.

Это делает провайдера видимым для каждого класса в приложении, которому известен токен или имя провайдера.

Расширяемость за счет импорта NgModule является основной целью системы NgModule.
Слияние провайдеров NgModule с инжектором приложений
облегчает для библиотеки модулей пополнение всего приложения новыми сервисами.
Добавляя  `HttpClientModule`  один раз, каждый компонент приложения может делать HTTP-запросы.

Тем не менее, это может показаться нежелательным сюрпризом, если вы ожидаете, что услуги модуля
быть видимым только для компонентов, объявленных этим функциональным модулем.
Если  `HeroModule`  предоставляет  `HeroService`  и рут  `AppModule`  импорт  `HeroModule`,
любой класс, который знает  `HeroService`  _type_ может внедрить этот сервис
не только классы, объявленные в  `HeroModule`.

Чтобы ограничить доступ к службе, рассмотрите ленивую загрузку модуля NgModule, который предоставляет эту службу. Посмотрите [Как я ограничиваю область обслуживания модулем?](guide/ngmodule-faq#service-scope)Для получения дополнительной информации.

<hr/>

{@a q-lazy-loaded-module-provider-visibility}

{@a why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module}
## Почему сервис, предоставляемый в модуле с отложенной загрузкой, виден только этому модулю?

В отличие от провайдеров модулей, загружаемых при запуске
поставщики модулей с загрузкой имеют *отложенной область действия модулей*.

Когда Angular-маршрутизатор лениво загружает модуль, он создает новый контекст выполнения.
Что [контекст имеет свой собственный инжектор](guide/ngmodule-faq#q-why-child-injector "Why Angular creates a child injector"),
который является прямым потомком инжектора приложения.

Маршрутизатор добавляет провайдеров ленивого модуля и провайдеров импортированных им NgModules в этот дочерний инжектор.

Эти поставщики изолированы от изменений поставщиков приложений с помощью одного и того же токена поиска.
Когда маршрутизатор создает компонент в пределах ленивого нагруженного контекста
Angular предпочитает экземпляры службы, созданные от этих поставщиков, экземплярам службы корневого инжектора приложения.

<hr/>


{@a what-if-two-modules-provide-the-same-service}
## Что если два модуля предоставляют одинаковые услуги?

Когда два импортированных модуля загружаются одновременно, укажите поставщика с одинаковым токеном
провайдер второго модуля "выигрывает". Это потому, что оба провайдера добавляются к одному и тому же инжектору.

Когда Угловое внешность, чтобы ввести услугу для этого маркера,
он создает и доставляет экземпляр, созданный вторым поставщиком.

_Every_ класс, который внедряет этот сервис, получает экземпляр, созданный вторым провайдером.
Даже классы, объявленные в первом модуле, получают экземпляр, созданный вторым поставщиком.

Если NgModule А обеспечивает услугу лексемы «X» и импортирует NgModule B
это также предоставляет сервис для токена 'X', тогда определение сервиса NgModule A "выигрывает".

Сервис, предоставляемый рутом  `AppModule`  имеет приоритет над услугами, предоставляемыми импортированными NgModules.
 `AppModule` всегда побеждает.

<hr/>

{@a service-scope}

{@a how-do-i-restrict-service-scope-to-a-module}
## Как ограничить область обслуживания для модуля?

Когда модуль загружается при запуске приложения,
его  `@NgModule.providers`  имеют *область применения*;
то есть они доступны для инъекций во всем приложении.

Импортированные провайдеры легко заменяются провайдерами из другого импортированного NgModule.
Такая замена может быть умышленной. Это может быть непреднамеренным и иметь неблагоприятные последствия.

Как правило, импортируйте модули с поставщиками _ровно один раз_, предпочтительно в _root module_ приложения.
Обычно это также лучшее место для их настройки, переноса и переопределения.

Предположим, что модуль требует  `HttpBackend`  который добавляет специальный заголовок для всех запросов Http.
Если другой модуль в другом месте приложения также настраивает  `HttpBackend` 
или просто импортирует  `HttpClientModule`, он может переопределить этот модуль  `HttpBackend`  провайдер
потерять специальный заголовок. Сервер отклонит http-запросы от этого модуля.

Чтобы избежать этой проблемы, импортируйте  `HttpClientModule`  только в  `AppModule`, приложение _root module_.

Если вы должны остерегаться такого рода «порчи провайдера», *не полагайтесь на модуль времени запуска  `providers`  .*

Загрузите модуль лениво, если можете.
Angular дает [модуль с отложенной загрузкой](guide/ngmodule-faq#q-lazy-loaded-module-provider-visibility)собственный дочерний инжектор.
Поставщики модуля видны только внутри дерева компонентов, созданного с помощью этого инжектора.

Если вам необходимо загрузить модуль с нетерпением, когда приложение запускается,
*вместо этого предоставьте услугу в компоненте.*

Продолжая с тем же примером, предположим, что компоненты модуля действительно требуют частного  `HttpBackend`.

Создайте «верхний компонент», который действует как корень для всех компонентов модуля.
Добавить кастом  `HttpBackend`  провайдер для верхнего компонента  `providers`  список а не модуля  `providers`.
Напомним, что Angular создает дочерний инжектор для каждого экземпляра компонента и заполняет инжектор
с собственными поставщиками компонента.

Когда дочерний элемент этого компонента запрашивает  `HttpBackend`  обслуживание,
Angular обеспечивает местный  `HttpBackend`  обслуживание,
не версия, указанная в приложении root root.
Дочерние компоненты делают правильные HTTP-запросы независимо от того, что другие модули делают с  `HttpBackend`.

Обязательно создайте компоненты модуля как дочерние элементы верхнего компонента этого модуля.

Вы можете встроить дочерние компоненты в шаблон верхнего компонента.
Или же сделайте верхний компонент хостом маршрутизации, предоставив ему  `<router-outlet>`.
Определите дочерние маршруты и дайте маршрутизатору загрузить компоненты модуля в эту розетку.

Хотя вы можете ограничить доступ к сервису, предоставив его в загруженном модуле или предоставив его в компоненте, предоставление сервисов в компоненте может привести к множеству экземпляров этих сервисов. Таким образом, ленивая загрузка предпочтительнее.

<hr/>

{@a q-root-component-or-module}


{@a should-i-add-application-wide-providers-to-the-root-appmodule-or-the-root-appcomponent}
## Должен ли я добавить провайдеров приложений в корень  `AppModule`  или рут  `AppComponent`  ?

Определите поставщиков всего приложения, указав `providedIn: 'root'` на своем  `@Injectable()`  (в случае сервисов) или в  `InjectionToken`  Конструкция (в случае, если предоставляются токены). Поставщики, которые создаются таким способом автоматически, становятся доступными для всего приложения и не должны быть перечислены ни в одном модуле.

Если поставщик не может быть настроен таким образом (возможно, потому что у него нет разумного значения по умолчанию), тогда зарегистрируйте поставщиков всего приложения в корневом каталоге.  `AppModule`, а не в  `AppComponent`.

Ленивые модули и их компоненты могут вводить  `AppModule`  ;
они не могут вводить  `AppComponent`  услуги.

Зарегистрировать услугу в  `AppComponent`  Поставщики _only_, если сервис должен быть скрыт
из компонентов за пределами  `AppComponent`  tree. Это редкий случай использования.

В более общем смысле [предпочитайте регистрировать провайдеров в NgModules](guide/ngmodule-faq#q-component-or-module)регистрироваться в компонентах.

<h3 class="no-toc">Обсуждение </h3>

Angular регистрирует всех поставщиков модулей запуска с помощью корневого инжектора приложения.
Сервисы, которые создают корневые поставщики инжекторов, имеют область применения, которая
означает, что они доступны для всего приложения.

Некоторые услуги, такие как  `Router`, работает только при регистрации их в корневом инжекторе приложения.

В отличие от Angular регистров  `AppComponent`  провайдеры с  `AppComponent`  собственный инжектор.
 `AppComponent` доступны только для этого компонента и его дерева компонентов.
У них есть компонентный охват.

 `AppComponent` является дочерним элементом корневого инжектора, который находится в иерархии инжекторов.
Для приложений, которые не используют маршрутизатор, это почти все приложение.
Но в маршрутизируемых приложениях маршрутизация работает на корневом уровне
где  `AppComponent`  не существуют.
Это означает, что лениво загруженные модули не могут получить к ним доступ.

<hr/>

{@a q-component-or-module}

{@a should-i-add-other-providers-to-a-module-or-a-component}
## Должен ли я добавить других поставщиков в модуль или компонент?

Поставщики должны быть настроены с использованием  `@Injectable`  синтаксис. По возможности их следует указывать в корне приложения (`providedIn: 'root'`). Службы, которые настроены таким образом, загружаются лениво, если они используются только из лениво загруженного контекста.

Если это решение потребителя, является ли поставщик приложения доступна по всему или нет,
затем зарегистрируйте провайдеров в модулях (`@NgModule.providers`) вместо регистрации в компонентах (`@Component.providers`).

Зарегистрируйте провайдера с компонентом, когда вы должны _ ограничить область действия экземпляра службы
к этому компоненту и его компонентному дереву.
Примените те же аргументы к регистрации поставщика с директивой.

Например, должен быть зарегистрирован компонент редактирования, которому требуется личная копия службы кэширования
сервис с компонентом.
Затем каждый новый экземпляр компонента получает свой собственный кэшированный экземпляр службы.
Изменения, которые редактор вносит в свой сервис, не затрагивают экземпляры в другом месте приложения.

[Обязательно зарегистрируйте _application-wide_ услуги с корнем  `AppModule` ](guide/ngmodule-faq#q-root-component-or-module),
не корень  `AppComponent`.

<hr/>

{@a q-why-bad}


{@a why-is-it-bad-if-a-shared-module-provides-a-service-to-a-lazy-loaded-module}
## Почему плохо, если совместно используемый модуль предоставляет услугу для лениво загруженного модуля?

{@a the-eagerly-loaded-scenario}
### Сильно загруженный сценарий
Когда загруженный модуль предоставляет услугу, например,  `UserService`, этот сервис доступен для всего приложения. Если корневой модуль предоставляет  `UserService`  и
импортирует другой модуль, который обеспечивает тот же  `UserService`, Angular регистрирует один из
их в инжекторе корневого приложения (см. [Что, если я импортирую один и тот же модуль дважды?](guide/ngmodule-faq#q-reimport)).

Затем, когда какой-либо компонент вводит  `UserService`, Angular находит его в корневом инжекторе приложения
и предоставляет единый сервис для всего приложения. Нет проблем.

{@a the-lazy-loaded-scenario}
### Ленивый загруженный сценарий

Теперь рассмотрим лениво загруженный модуль, который также предоставляет сервис под названием  `UserService`.

Когда ленивый маршрутизатор загружает модуль, он создает дочерний инжектор и регистрирует  `UserService` 
поставщик с этим детским инжектором. Дочерний инжектор не является корневым инжектором.

Когда Angular создает ленивый компонент для этого модуля и внедряет  `UserService`,
он находит  `UserService`  Поставщик в _child инжекторе ленивого модуля
и создает _new_ экземпляр  `UserService`.
Это совершенно другое  `UserService`  экземпляр
чем синглтон-версия всего приложения, которую Angular внедрил в один из загруженных компонентов.

Этот сценарий заставляет ваше приложение каждый раз создавать новый экземпляр вместо использования синглтона.
<!--KW--What does this cause? I wasn't able to get the suggestion of this to work from
the current FAQ:
To demonstrate, run the <live-example name="ngmodule">live example</live-example>.
Modify the  `SharedModule`  so that it provides the  `UserService`  rather than the  `CoreModule`.
Then toggle between the "Contact" and "Heroes" links a few times.
The username goes bonkers as the Angular creates a new  `UserService`  instance each time.
I'd like to see the error so I can include it.-->

<hr/>

{@a q-why-child-injector}

{@a why-does-lazy-loading-create-a-child-injector}
## Почему ленивая загрузка создает детский инжектор?

Angular добавляет  `@NgModule.providers`  для корневого инжектора приложения, если только NgModule не загружен с отложенным доступом.
Для лениво загруженного модуля NgModule Angular создает инжектор _child_ и добавляет поставщиков модуля в дочерний инжектор.

Это означает, что NgModule ведет себя по-разному в зависимости от того, загружен ли он при запуске приложения
или ленивый позже. Пренебрежение этой разницей может привести к [неблагоприятным последствиям](guide/ngmodule-faq#q-why-bad).

Почему Angular не добавляет провайдеров с отложенной загрузкой в ​​корневой инжектор приложения, как это делается для активно загружаемых NgModules?

Ответ основан на фундаментальной характеристике системы Angular зависимости-инжекции.
Инжектор может добавлять провайдеров _ пока он не используется впервые.
Как только инжектор начинает создавать и предоставлять услуги, список его поставщиков блокируется; новые провайдеры не допускаются.

Когда приложение запускается, Angular сначала настраивает корневой инжектор с поставщиками всех загруженных NgModules
_before_ создание своего первого компонента и внедрение любой из предоставляемых услуг.
После запуска приложения корневой инжектор приложения закрывается для новых поставщиков.

Проходит время и логика приложения вызывает ленивую загрузку NgModule.
Angular должен добавить провайдеров лениво загруженного модуля к инжектору где-нибудь.
Он не может добавить их в корневой инжектор приложения, потому что этот инжектор закрыт для новых поставщиков.
Таким образом, Angular создает новый дочерний инжектор для лениво-загруженного контекста модуля.

<hr/>

{@a q-is-it-loaded}

{@a how-can-i-tell-if-an-ngmodule-or-service-was-previously-loaded}
## Как я могу узнать, был ли ранее загружен NgModule или сервис?

Некоторые NgModules и их сервисы должны загружаться только один раз root  `AppModule`.
Импортирование модуля во второй раз с помощью отложенной загрузки модуля может [производить странствующее поведение](guide/ngmodule-faq#q-why-bad)
это может быть трудно обнаружить и диагностировать.

Чтобы предотвратить эту проблему, напишите конструктор, который пытается внедрить модуль или службу
из инжектора корневого приложения. Если внедрение прошло успешно, класс был загружен второй раз.
Вы можете выдать ошибку или предпринять другие корректирующие действия.

Некоторые NgModules, такие как  `BrowserModule`, реализовать такую ​​охрану.
Вот пользовательский конструктор для NgModule с именем  `GreetingModule`.

<code-example path="ngmodules/src/app/greeting/greeting.module.ts" region="ctor" header="src/app/greeting/greeting.module.ts (Constructor)"></code-example>

<hr/>

{@a q-entry-component-defined}

{@a what-is-an-entry-component}
## Что такое `entry component` ?

Компонент ввода - это любой компонент, который Angular загружает _imperatively_ по типу.

Компонент, загруженный _declaratively_ через его селектор, _не_ компонент ввода.

Angular загрузка компонента декларативно, когда
используя селектор компонента, чтобы найти элемент в шаблоне.
Затем Angular создает HTML-представление компонента и вставляет его в DOM на выбранном элементе. Это не входные компоненты.

Загрузочный корень  `AppComponent`  является компонентом _entry_.
Правда, его селектор соответствует тегу элемента в  `index.html`.
Но  `index.html`  не является шаблоном компонента, а  `AppComponent` 
селектор не соответствует элементу в любом шаблоне компонента.

Компоненты в определениях маршрута также являются _entry components_.
Определение маршрута ссылается на компонент по его _type_.
Маршрутизатор игнорирует селектор маршрутизируемого компонента, если он есть, и
загружает компонент динамически в  `RouterOutlet`.

Для получения дополнительной информации см. [Компоненты ввода](guide/entry-components).

<hr/>

{@a whats-the-difference-between-a-bootstrap-component-and-an-entry-component}
## В чем разница между компонентом _bootstrap_ и компонентом _entry_?

Начальный компонент _is_ an [компонент входа](guide/ngmodule-faq#q-entry-component-defined)
что Angular загружается в DOM во время процесса начальной загрузки (запуска приложения).
Другие компоненты входа загружаются динамически с помощью других средств, таких как маршрутизатор.

 `@NgModule.bootstrap` сообщает компилятору, что это компонент ввода _and_
он должен генерировать код для начальной загрузки приложения с этим компонентом.

Нет необходимости перечислять компонент в  `bootstrap`  и  `entryComponents`  списки
хотя делать это безвредно.

Для получения дополнительной информации см. [Компоненты ввода](guide/entry-components).

<hr/>

{@a when-do-i-add-components-to-entrycomponents}
## Когда я добавляю компоненты в _entryComponents_?

Большинству разработчиков приложений не нужно добавлять компоненты в  `entryComponents`.

Angular автоматически добавляет определенные компоненты в _entry components_.
Компоненты, перечисленные в  `@NgModule.bootstrap`  добавляются автоматически.
Компоненты, указанные в конфигурации маршрутизатора, добавляются автоматически.
Эти два механизма составляют почти все входные компоненты.

Если ваше приложение происходит для начальной загрузки или динамически загружать компонент _by type_ каким - либо иным образом,
Вы должны добавить это к  `entryComponents`  явно.

Хотя добавлять компоненты в этот список безопасно
Лучше всего добавлять только те компоненты, которые действительно являются _entry components_.
Не включать в себя компоненты, которые [упоминаются](guide/ngmodule-faq#q-template-reference)
в шаблонах других компонентов.

Для получения дополнительной информации см. [Компоненты ввода](guide/entry-components).

<hr/>


{@a why-does-angular-need-entrycomponents}
## Почему Angular нужен _entryComponents_?

Причина в том, что дерево трясется. Для производственных приложений вы хотите загрузить наименьший, самый быстрый код. Код должен содержать только те классы, которые вам действительно нужны.
Он должен исключать компонент, который никогда не используется, независимо от того, объявлен он или нет.

Фактически, многие библиотеки объявляют и экспортируют компоненты, которые вы никогда не будете использовать.
Если вы не ссылаетесь на них, шейкер дерева удаляет эти компоненты из окончательного пакета кода.

Если бы [Angular компилятор](guide/ngmodule-faq#q-angular-compiler)генерировал код для каждого объявленного компонента, он бы потерпел поражение от цели создания дерева.

Вместо этого компилятор принимает рекурсивную стратегию, которая генерирует код только для компонентов, которые вы используете.

Компилятор начинается с компонентов ввода
Затем он генерирует код для заявленных компонентов он [находки](guide/ngmodule-faq#q-template-reference)в шаблоне компонента вступления, в
то для заявленных компонентов он обнаруживает в шаблонах ранее составленных компонентов
и так далее. В конце процесса компилятор сгенерировал код для каждого компонента ввода
и каждый компонент доступен из компонента ввода.

Если компонент не является _entry component_ или не был найден в шаблоне
компилятор пропускает это.

<hr/>

{@a what-kinds-of-modules-should-i-have-and-how-should-i-use-them}
## Какие у меня должны быть модули и как их использовать?

Каждое приложение отличается. Разработчики имеют различные уровни опыта и комфорта с доступным выбором.
Некоторые предложения и рекомендации, кажется, имеют широкую привлекательность.

{@a sharedmodule}
###  `SharedModule` 
 `SharedModule` - это условное название  `NgModule`  с компонентами, директивами и трубами, которые вы используете
везде в вашем приложении. Этот модуль должен состоять исключительно из  `declarations`,
большинство из них экспортируется.

 `SharedModule` может повторно экспортировать другие модули виджетов, такие как  `CommonModule`,
 `FormsModule` и NgModules с элементами управления пользовательского интерфейса, которые вы используете наиболее широко.

 `SharedModule` не должен иметь  `providers`  по причинам [объясненным ранее](guide/ngmodule-faq#q-why-bad).
Ни один из его импортированных или реэкспортированных модулей не должен иметь  `providers`.

Импортировать  `SharedModule`  в ваших _feature_ модулях
и те, которые загружаются при запуске приложения, и те, которые вы загружаете позже.

{@a feature-modules}
### Функциональные модули

Функциональные модули - это модули, которые вы создаете для определенных бизнес-доменов приложений, рабочих процессов пользователей и наборов утилит. Они поддерживают ваше приложение, так как содержат определенную функцию
такие как маршруты, сервисы, виджеты и т. д. Чтобы понять, какой функциональный модуль может быть у вас
приложение, считает, что если бы вы поместить эти файлы, связанные с определенной функциональностью, как поиск,
в одной папке, содержимое этой папки будет функциональным модулем, который вы можете вызвать
твой  `SearchModule`  . Он будет содержать все компоненты, маршрутизацию и шаблоны, которые
составил бы функциональность поиска.

Для получения дополнительной информации см. [Функциональные модули](guide/feature-modules)и
[Типы модулей](guide/module-types)



{@a whats-the-difference-between-ngmodules-and-javascript-modules}
## В чем разница между модулями NgModules и JavaScript?

В приложении Angular модули NgModules и JavaScript работают вместе.

В современном JavaScript каждый файл является модулем
(см. [Модули](http://exploringjs.com/es6/ch_modules.html)страницу на веб-сайте Exploring ES6).
В каждом файле вы пишете  `export`  заявление на чтобы сделать части модуля общедоступными.

Angular NgModule - это класс с  `@NgModule`  decorator - модули JavaScript
не должен иметь  `@NgModule`  decorator. Angular's  `NgModule`  имеет  `imports`  и  `exports`  и они служат аналогичной цели.

Вы _импортируете_ другие NgModules, чтобы вы могли использовать их экспортированные классы в шаблонах компонентов.
Вы _экспортируете_ классы этого NgModule, чтобы они могли импортироваться и использоваться компонентами _other_ NgModules.

Для получения дополнительной информации см. [Модули JavaScript против NgModules](guide/ngmodule-vs-jsmodule).

<hr/>

{@a q-template-reference}

{@a how-does-angular-find-components-directives-and-pipes-in-a-template<br>what-is-a-<i><b>template-reference</b></i>}
## Как Angular находит компоненты, директивы и каналы в шаблоне? <br>Что такое на <i><b>ссылка шаблон </b></i>?

The [Angular компилятор](guide/ngmodule-faq#q-angular-compiler)смотрит внутри шаблонов компонентов
для других компонентов, директив и труб. Когда он находит, это ссылка на шаблон.

Компилятор Angular находит компонент или директиву в шаблоне, когда он может сопоставить *селектор* этого компонента или директивы с некоторым HTML-кодом в этом шаблоне.

Компилятор находит трубу, если трубы *имя* появляется в синтаксисе трубы шаблона HTML.

Angular соответствует только селекторам и именам каналов для классов, объявленных этим модулем
или экспортируется модулем, который импортирует этот модуль.

<hr/>

{@a q-angular-compiler}

{@a what-is-the-angular-compiler}
## Что такое Angular компилятор?

Компилятор Angular преобразует код приложения, который вы пишете, в высокопроизводительный код JavaScript.
 `@NgModule` Метаданные играют важную роль в управлении процессом компиляции.

Код, который вы пишете, не сразу исполняется. Например, компоненты имеют шаблоны, которые содержат пользовательские элементы, директивы атрибутов, Angular обязательные декларации,
и некоторый специфический синтаксис, который явно не является родным HTML.

Angular компилятор читает разметку шаблона
объединяет его с соответствующим кодом класса компонента и испускает _component factories_.

Фабрика компонентов создает чистое 100% представление JavaScript
компонента, который включает в себя все, что описано в его  `@Component`  метаданные:
HTML, инструкции по связыванию, прикрепленные стили.

Потому что директивы и каналы появляются в шаблонах компонентов
Angular компилятор также включает их в код скомпилированного компонента.

 `@NgModule` Метаданные Angular-компилятору, какие компоненты и для чего нужно скомпилировать
как связать этот модуль с другими модулями.
