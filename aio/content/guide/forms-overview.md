{@a introduction-to-forms-in-angular}
# Введение в формы в Angular

Обработка пользовательского ввода с помощью форм является краеугольным камнем многих распространенных приложений. Приложения используют формы, чтобы пользователи могли войти в систему, обновить профиль, ввести конфиденциальную информацию и выполнить множество других задач ввода данных.

Angular предоставляет два разных подхода к обработке пользовательского ввода через формы: реактивный и управляемый шаблоном. Оба захватывают события пользовательского ввода из представления, проверяют пользовательский ввод, создают модель формы и модель данных для обновления и предоставляют способ отслеживания изменений.

Реактивные и управляемые шаблоном формы обрабатывают и обрабатывают данные формы по-разному. Каждый предлагает разные преимущества.

**В целом:**

* **Реактивные формы** более надежны: они более масштабируемы, многократно используются и тестируемы. Если формы являются ключевой частью вашего приложения или вы уже используете реактивные шаблоны для создания приложения, используйте реактивные формы.
* **Шаблонно-управляемые формы** полезны для добавления в приложение простой формы, например формы регистрации в списке рассылки. Их легко добавить в приложение, но они не так масштабируются, как реагирующие формы. Если у вас есть базовые требования к форме и логике, которыми можно управлять только в шаблоне, используйте формы на основе шаблона.

Это руководство содержит информацию, которая поможет вам решить, какой тип формы лучше всего подходит для вашей ситуации. Он вводит общие строительные блоки, используемые в обоих подходах. Он также суммирует ключевые различия между двумя подходами и демонстрирует эти различия в контексте настройки, потока данных и тестирования.

<div class="alert is-helpful">

**Примечание.** Для получения полной информации о формах каждого типа см. [Реактивные формы](guide/reactive-forms)и [Формы на основе шаблонов](guide/forms).

</div>

{@a key-differences}
## Основные отличия

В таблице ниже приведены основные различия между формами реагирования и шаблонами.

<style>
  table {width: 100%};
  td, th {vertical-align: top};
</style>

|| Реактивный | Шаблон привод |
| --- | --- | --- |
| Настройка (модель формы) | Более явный, созданный в классе компонентов | Менее явный, созданный директивами |
| Модель данных | Структурированная | Неструктурированная |
| Предсказуемость | синхронный | Асинхронный |
| Проверка формы | Функции | Директивы |
| Изменчивость | Неизменное | Mutable |
| Масштабируемость | Низкоуровневый доступ к API | Абстракция поверх API |

{@a common-foundation}
## Общий фундамент

И реактивные, и управляемые шаблоном формы имеют общие строительные блоки.


* `FormControl` отслеживает значение и статус проверки отдельного элемента управления формы.

* `FormGroup` отслеживает те же значения и статус для коллекции элементов управления формы.

* `FormArray` отслеживает те же значения и статус для массива элементов управления формы.

* `ControlValueAccessor` создает мост между Angular `FormControl` и собственные элементы DOM.

В разделе [Настройка модели формы](#setup-the-form-model)ниже приведено введение в создание и управление этими экземплярами элементов управления с помощью реактивных и управляемых шаблонами форм. Дальнейшие подробности представлены в [секциях потока данных](#data-flow-in-forms)данное руководство.

{@a setup-the-form-model}

{@a form-model-setup}
## Настройка модели формы

Реактивные и управляемые шаблоном формы используют модель формы для отслеживания изменений значений между Angularи формами и элементами ввода формы. Приведенные ниже примеры показывают, как модель формы определяется и создается.

{@a setup-in-reactive-forms}
### Настройка в реактивных формах

Вот компонент с полем ввода для одного элемента управления, реализованного с использованием реактивных форм.

<code-example path="forms-overview/src/app/reactive/favorite-color/favorite-color.component.ts">
</code-example>

Источник правды предоставляет значение и статус элемента формы в данный момент времени. В реактивных формах модель формы является источником истины. В приведенном выше примере модель формы `FormControl`.

<div class="lightbox">
  <img src="generated/images/guide/forms-overview/key-diff-reactive-forms.png" alt="Reactive forms key differences">
</div>

В случае реактивных форм модель формы явно определяется в классе компонентов. Директива о реактивной форме (в данном случае `FormControlDirective`) затем связывает существующие `FormControl` для определенного элемента формы в представлении с использованием метода доступа к значению (`ControlValueAccessor`).

{@a setup-in-template-driven-forms}
### Настройка в шаблонно-управляемых формах

Вот тот же компонент с полем ввода для одного элемента управления, реализованного с использованием шаблонно-управляемых форм.

<code-example path="forms-overview/src/app/template/favorite-color/favorite-color.component.ts">
</code-example>

В формах, управляемых шаблонами, источником истины является шаблон.

<div class="lightbox">
  <img src="generated/images/guide/forms-overview/key-diff-td-forms.png" alt="Template-driven forms key differences">
</div>

Абстракция модели формы способствует простоте структуры. Директива на основе шаблонов `NgModel` отвечает за создание и управление `FormControl` для данного элемента формы. Это менее очевидно, но вы больше не имеете прямого контроля над моделью формы.

{@a data-flow-in-forms}

{@a data-flow-in-forms}
## Поток данных в формах

При создании форм в Angular важно понимать, как платформа обрабатывает данные, поступающие от пользователя или от программных изменений. Реактивные и управляемые шаблоном формы следуют двум различным стратегиям при обработке ввода формы. Приведенные ниже примеры потока данных начинаются с приведенного выше примера поля ввода любимого цвета, а затем показывают, как изменения в любимом цвете обрабатываются в реактивных формах по сравнению с формами на основе шаблонов.

{@a data-flow-in-reactive-forms}
### Поток данных в реактивных формах

Как описано выше, в реактивных формах каждый элемент формы в представлении напрямую связан с моделью формы (`FormControl`). Обновления из представления в модель и из модели в представление являются синхронными и не зависят от отображаемого пользовательского интерфейса. На приведенных ниже схемах используется тот же пример избранного цвета, чтобы продемонстрировать, как данные передаются при изменении значения поля ввода из представления, а затем из модели.

<div class="lightbox">
  <img src="generated/images/guide/forms-overview/dataflow-reactive-forms-vtm.png" alt="Reactive forms data flow - view to model" width="100%">
</div>

Следующие шаги описывают поток данных от вида к модели.

1. Пользователь вводит значение в элемент ввода, в данном случае любимый цвет *синий*.
1. Элемент ввода формы генерирует событие «input» с самым последним значением.
1. Метод доступа к управляющему значению, прослушивающий события в элементе ввода формы, немедленно передает новое значение `FormControl`.
1. `FormControl` выдает новое значение через `valueChanges` наблюдаемые.
1. Любые подписчики на `valueChanges` observable получает новое значение.

<div class="lightbox">
  <img src="generated/images/guide/forms-overview/dataflow-reactive-forms-mtv.png" alt="Reactive forms data flow - model to view" width="100%">
</div>

Следующие шаги описывают поток данных от модели к представлению.

1. Пользователь вызывает `favoriteColorControl.setValue()` метод, который обновляет `FormControl` Значение.
1. `FormControl` выдает новое значение через `valueChanges` наблюдаемые.
1. Любые подписчики на `valueChanges` observable получает новое значение.
1. Метод доступа к управляющему значению в элементе ввода формы обновляет элемент новым значением.

{@a data-flow-in-template-driven-forms}
### Поток данных в управляемых шаблонами формах

В управляемых шаблонами формах каждый элемент формы связан с директивой, которая управляет моделью формы внутри. На приведенных ниже схемах используется тот же пример избранного цвета, чтобы продемонстрировать, как данные передаются при изменении значения поля ввода из представления, а затем из модели.

<div class="lightbox">
  <img src="generated/images/guide/forms-overview/dataflow-td-forms-vtm.png" alt="Template-driven forms data flow - view to model" width="100%">
</div>

Приведенные ниже шаги описывают поток данных от вида к модели, когда входное значение изменяется с *красного* на *синий*.

1. Пользователь вводит *синий* в элемент ввода.
1. Элемент input генерирует событие «input» со значением *Blue*.
1. Аксессор значения управления, подключенный к входу, запускает `setValue()` на `FormControl`.
1. `FormControl` выдает новое значение через `valueChanges` наблюдаемые.
1. Любые подписчики на `valueChanges` observable получает новое значение.
1. Метод доступа к значению управления также вызывает `NgModel.viewToModelUpdate()` который `ngModelChange` Событие.
1. Поскольку шаблон компонента использует двустороннюю привязку данных для `favoriteColor` собственности, `favoriteColor` свойство в компоненте
обновляется до значения, испускаемого `ngModelChange` Событие ( *синий*).

<div class="lightbox">
  <img src="generated/images/guide/forms-overview/dataflow-td-forms-mtv.png" alt="Template-driven forms data flow - model to view" width="100%">
</div>

Приведенные ниже шаги описывают поток данных от модели для просмотра, когда `favoriteColor` меняется с *синего* на *красный*.

1. `favoriteColor` значение обновляется в компоненте.
1. Обнаружение изменений начинается.
1. Во время обнаружения изменений `ngOnChanges` жизненного цикла вызывается на `NgModel` директивы потому что значение одного из его входов изменилось.
1. `ngOnChanges()` очередь асинхронную задачу, чтобы установить значение для внутреннего `FormControl`.
1. Обнаружение изменений завершено.
1. На следующем тике задача установить `FormControl` экземпляра выполняется.
1. `FormControl` выдает последнее значение через `valueChanges` наблюдаемые.
1. Любые подписчики на `valueChanges` observable получает новое значение.
1. Средство доступа к значению элемента управления обновляет элемент ввода формы в представлении самыми последними `favoriteColor` значение.

{@a form-validation}
## Проверка формы

Валидация является неотъемлемой частью управления любым набором форм. Независимо от того, проверяете ли вы обязательные поля или запрашиваете внешний API для существующего имени пользователя, Angular предоставляет набор встроенных валидаторов, а также возможность создавать собственные валидаторы.

* **Реактивные формы** определяют пользовательские валидаторы как**функции,** которые получают элемент управления для проверки.
* **Формы, управляемые** шаблоном привязаны к шаблона**директивам**, и должны предоставлять пользовательские директивы валидатора, которые обертывают функции валидации.

Для получения дополнительной информации см. [Проверка формы](guide/form-validation).

{@a testing}
## Тестирование

Тестирование играет большую роль в сложных приложениях, и более простая стратегия тестирования полезна для проверки правильности работы ваших форм. Реактивные формы и формы на основе шаблонов имеют разную степень зависимости от визуализации пользовательского интерфейса для выполнения утверждений на основе управления формой и изменений полей формы. Следующие примеры демонстрируют процесс тестирования форм с реактивными и управляемыми шаблонами формами.

{@a testing-reactive-forms}
### Тестирование реактивных форм

Реактивные формы обеспечивают относительно простую стратегию тестирования, поскольку они обеспечивают синхронный доступ к форме и моделям данных, и их можно тестировать без визуализации пользовательского интерфейса. В этих тестах состояние и данные запрашиваются и управляются через элемент управления, не взаимодействуя с циклом обнаружения изменений.

В следующих тестах используются любимые компоненты цвета, упомянутые ранее, чтобы проверить потоки данных от представления к модели и модели для просмотра на реактивную форму.

Следующий тест проверяет поток данных от представления к модели.

<code-example path="forms-overview/src/app/reactive/favorite-color/favorite-color.component.spec.ts" region="view-to-model" header="Favorite color test - view to model">
</code-example>

Вот шаги, выполняемые с целью проверки модели.

1. Запросите представление для элемента ввода формы и создайте пользовательское событие ввода для теста.
1. Установите новое значение для ввода *Red*и отправьте событие «input» на элемент ввода формы.
1. Утверждают, что компонент `favoriteColorControl` значение соответствует значению от входа.

Следующий тест проверяет поток данных от модели к представлению.

<code-example path="forms-overview/src/app/reactive/favorite-color/favorite-color.component.spec.ts" region="model-to-view" header="Favorite color test - model to view">
</code-example>

Вот шаги, выполненные в модели для просмотра теста.

1. Использовать `favoriteColorControl`, `FormControl`, чтобы установить новое значение.
1. Запросите представление для элемента ввода формы.
1. Утвердите, что новое значение, установленное в элементе управления, совпадает со значением на входе.

{@a testing-template-driven-forms}
### Тестирование шаблонно-управляемых форм

Написание тестов с использованием шаблонно-управляемых форм требует детального знания процесса обнаружения изменений и понимания того, как выполняются директивы в каждом цикле, чтобы гарантировать, что элементы запрашиваются, тестируются или изменяются в нужное время.

В следующих тестах используются любимые компоненты цвета, упомянутые ранее, для проверки потоков данных от представления к модели и модели для просмотра формы на основе шаблона.

Следующий тест проверяет поток данных от представления к модели.

<code-example path="forms-overview/src/app/template/favorite-color/favorite-color.component.spec.ts" region="view-to-model" header="Favorite color test - view to model">
</code-example>

Вот шаги, выполняемые с целью проверки модели.

1. Запросите представление для элемента ввода формы и создайте пользовательское событие ввода для теста.
1. Установите новое значение для ввода *Red*и отправьте событие «input» на элемент ввода формы.
1. Запустите обнаружение изменений через тестовое устройство.
1. Утверждают, что компонент `favoriteColor` Значение свойства соответствует значению из входных данных.

Следующий тест проверяет поток данных от модели к представлению.

<code-example path="forms-overview/src/app/template/favorite-color/favorite-color.component.spec.ts" region="model-to-view" header="Favorite color test - model to view">
</code-example>

Вот шаги, выполненные в модели для просмотра теста.

1. Используйте экземпляр компонента, чтобы установить значение `favoriteColor` собственности.
1. Запустите обнаружение изменений через тестовое устройство.
1. Использовать `tick()` метод для имитации времени в течение `fakeAsync()`.
1. Запросите представление для элемента ввода формы.
1. Утверждают, что входное значение соответствует значению `favoriteColor` свойство в экземпляре компонента.

{@a mutability}
## Изменчивость

Метод отслеживания изменений играет роль в эффективности вашего приложения.


* **Реактивные формы** обеспечивают чистоту модели данных, предоставляя ее в качестве неизменной структуры данных. Каждый раз, когда происходит изменение в модели данных, `FormControl` возвращает новую модель данных, а не обновляет существующую модель данных. Это дает вам возможность отслеживать уникальные изменения в модели данных через наблюдаемый элемент управления. Это обеспечивает один из способов повышения эффективности обнаружения изменений, поскольку требуется обновлять только уникальные изменения. Это также следует за реактивными моделями, которые объединяются с наблюдаемыми операторами для преобразования данных.

* **шаблонов** Формы на основе полагаются на изменчивость с двусторонним связыванием данных для обновления модели данных в компоненте по мере внесения изменений в шаблон. Поскольку при использовании двусторонней привязки данных не существует уникальных изменений, которые нужно отслеживать в модели данных, обнаружение изменений менее эффективно при определении необходимости обновления.

Разница демонстрируется в приведенных выше примерах с использованием **любимого цвета** элемента ввода.


* С реактивными формами** `FormControl` экземпляр** всегда возвращает новое значение, когда значение элемента управления обновляется.

* В формах на основе шаблона**свойство избранного цвета** всегда изменяется на новое значение.

{@a scalability}
## Масштабируемость

Если формы являются центральной частью вашего приложения, масштабируемость очень важна. Возможность повторного использования моделей форм в компонентах имеет решающее значение.


* **Реактивные формы** предоставляют доступ к низкоуровневым API и синхронный доступ к модели форм, что облегчает создание крупномасштабных форм.

* **Шаблон приводом** формы ориентированы на простые сценарии, не являются многократно используемыми, абстрагируются от низкоуровневых API и обеспечивают асинхронный доступ к модели формы. Абстракция с управляемыми шаблоном формами также проявляется в тестировании, где тестирование реактивных форм требует меньше настроек и не зависит от цикла обнаружения изменений при обновлении и проверке формы и моделей данных во время тестирования.

{@a final-thoughts}
## Заключительные мысли

Выбор стратегии начинается с понимания сильных и слабых сторон представленных вариантов. Низкоуровневый доступ к API и модели форм, предсказуемость, изменчивость, простые стратегии валидации и тестирования, а также масштабируемость - все это важные факторы при выборе инфраструктуры, используемой для создания форм в Angular. Формы на основе шаблонов аналогичны шаблонам в AngularJS, но имеют ограничения с учетом критериев многих современных крупномасштабных приложений Angular. Реактивные формы минимизируют эти ограничения. Реактивные формы интегрируются с реактивными шаблонами, уже присутствующими в других областях Angular архитектуры, и хорошо дополняют эти требования.

{@a next-steps}
## Следующие шаги



Чтобы узнать больше о реактивных форм см в следующих руководствах:

* [Реактивные формы](guide/reactive-forms)
* [Проверка формы](guide/form-validation#reactive-form-validation)
* [Динамические формы](guide/dynamic-form)

Чтобы узнать больше о формах на основе шаблонов, см в следующих руководствах:

* [Шаблонно-управляемые формы](guide/forms#template-driven-forms)
* [Проверка формы](guide/form-validation#template-driven-validation)
