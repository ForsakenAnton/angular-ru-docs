{@a glossary}
# Глоссарий

Angular имеет свой словарный запас.
Большинство Angular терминов являются общими английскими словами или компьютерными терминами
которые имеют особое значение в Angular системе.

В этом глоссарии перечислены наиболее важные термины
и несколько менее знакомых с необычным или
неожиданные определения.

[A](#A) [B](#B) [C](#C) [D](#D) [E](#E) [F](#F) [G](#G) [H](#H) [I](#I)
[J](#J) [K](#K) [L](#L) [M](#M) [N](#N) [O](#O) [P](#P) [Q](#Q) [R](#R)
[S](#S) [T](#T) [U](#U) [V](#V) [W](#W) [X](#X) [Y](#Y) [Z](#Z)


{@a A}
{@a aot}


{@a ahead-of-time-aot-compilation}
## опережающая (AOT) компиляция

Компилятор Angular заблаговременно (AOT) преобразует код Angular HTML и TypeScript
в эффективный код JavaScript на этапе сборки, до загрузки браузера
и запускает этот код.
Это лучший режим компиляции для производственной среды, с уменьшением времени загрузки и увеличения производительности по сравнению с [точно в срок (JIT) компиляции](#jit).

Составляя ваше приложение, используя `ngc` командной строки, вы можете загрузить непосредственно на фабрику модулей, так что вам не нужно включать компилятор Angular в ваш пакет JavaScript.

{@a angular-element}

{@a angular-element}
## Angular элемент

Angular [компонент](#component)упакован как [пользовательский элемент](#custom-element).

Узнайте больше в [Angular обзор элементов](guide/elements).

{@a annotation}

{@a annotation}
## аннотация

Структура, которая предоставляет метаданные для класса. Смотрите [декоратор](#decorator).

{@a app-shell}

{@a app-shell}
## app-shell

Оболочка приложения - это способ визуализации части вашего приложения через маршрут во время сборки.
Это дает пользователям осмысленную первую картину вашего приложения, которая появляется быстро, потому что браузер может отображать статический HTML и CSS без необходимости инициализации JavaScript.

Узнайте больше в [Модель оболочки приложения](https://developers.google.com/web/fundamentals/architecture/app-shell).

Вы можете использовать Angular CLI для [создания](cli/generate#appshell)оболочки приложения.
Это может улучшить взаимодействие с пользователем за счет быстрого запуска статической визуализированной страницы (скелет, общий для всех страниц), пока браузер загружает полную версию клиента и автоматически переключается на нее после загрузки кода.

Смотрите также [Сервисный работник и PWA](guide/service-worker-intro).
{@a architect}

{@a architect}
## Архитектор

Инструмент, который CLI использует для выполнения сложных задач, таких как компиляция и запуск теста, в соответствии с предоставленной конфигурацией.
Architect - это оболочка, которая запускает [builder](#builder)(определенный в [пакет npm](#npm-package)) с заданным [целевая конфигурация](#target).

В разделе [файл конфигурации рабочей области](guide/workspace-config#project-tool-configuration-options)раздел «Architect» предоставляет параметры конфигурации для разработчиков Architect.

Например, встроенный конструктор для линтинга определяется в пакете `@angular-devkit/build_angular:tslint`, который использует [TSLint](https://palantir.github.io/tslint/)инструмент для выполнения линтинга с конфигурацией, указанной в `tslint.json` файл.

Используйте [команда CLI `ng run` ](cli/run)чтобы вызвать компоновщик, указав [целевую конфигурацию](#target)связанную с этим компоновщиком.
Интеграторы могут добавлять сборщики, чтобы инструменты и рабочие процессы могли проходить через Angular CLI. Например, пользовательский конструктор может заменить сторонние инструменты, используемые встроенными реализациями для команд консоли, таких как `ng build ` или ` ng test`.

{@a attribute-directive}


{@a attribute-directives}


{@a attribute-directives}
## директивы атрибутов

Категория [директива](#directive)которая может слушать и изменять поведение
другие элементы HTML, атрибуты, свойства и компоненты. Они обычно представлены
как атрибуты HTML, отсюда и название.

Узнайте больше в [Директивы атрибутов](guide/attribute-directives).


{@a B}

{@a binding}

{@a binding}
## связывание

Как правило, практика установки переменной или свойства для значения данных.
В угловатый, как правило, относится к [привязки данных](#data-binding),
который координирует свойства объекта DOM со свойствами объекта данных.

Иногда относится к [зависимость-инъекция](#dependency-injection)привязке
между [токеном](#token)и зависимостью [провайдером](#provider).

{@a bootstrap}

{@a bootstrap}
## самозагрузки

Способ инициализации и запуска приложения или системы.

В Angular, корень приложения NgModule (`AppModule`) имеет `bootstrap` Свойство которое определяет верхний уровень приложения [компоненты](#component).
В процессе начальной загрузки Angular создает и вставляет эти компоненты в `index.html` веб-страница хоста.
Вы можете загрузить несколько приложений в одном `index.html` . Каждое приложение содержит свои собственные компоненты.

Узнайте больше в [Bootstrapping](guide/bootstrapping).

{@a builder}

{@a builder}
## строитель

Функция, которая использует [Architect](#architect)API для выполнения сложного процесса, такого как «сборка» или «тестирование».
Код компоновщика определен в [пакет npm](#npm-package).

Например, [BrowserBuilder](https://github.com/angular/angular-cli/tree/master/packages/angular_devkit/build_angular/src/browser)выполняет [сборку webpack](https://webpack.js.org/)для цели браузера и [KarmaBuilder](https://github.com/angular/angular-cli/tree/master/packages/angular_devkit/build_angular/src/karma)запускает сервер Karma и запускает сборку веб-пакета для модульных тестов.

Команда [CLI `ng run` сборщик](cli/run)вызывает с определенной [целевой конфигурацией](#target).
[Рабочая область конфигурации](guide/workspace-config)файла, `angular.json`, содержит конфигурации по умолчанию для встроенных сборщиков.

{@a C}

{@a case-conventions}
{@a dash-case}
{@a camelcase}
{@a kebab-case}

{@a case-types}
## типы случаев

Angular виды использования капитализацией конвенции различать имена различных типов, как описано в [руководящие принципы именования раздела](guide/styleguide#02-01)Руководства Style. Вот краткое описание типов случаев:

* camelCase: символы, свойства, методы, имена каналов, некомпонентные селекторы директив, константы.
Стандартный или нижний верблюжий регистр использует строчные буквы на первой букве предмета. Например, «selectedHero».

* UpperCamelCase (или PascalCase): Имена классов, в том числе классов, которые определяют компоненты, интерфейсы, NgModules, директивы, и трубы,
Верхний регистр верблюда использует верхний регистр на первой букве предмета. Например, «HeroListComponent».

* dash-case (или "kebab-case") : описательная часть имен файлов, селекторы компонентов. Например, «app-hero-list».

* underscore_case (или "snake_case") : обычно не используется в Angular. В случае со змеей используются слова, связанные с подчеркиванием.
Например, "convert_link_mode".

* UPPER_UNDERSCORE_CASE (или UPPER_SNAKE_CASE, или SCREAMING_SNAKE_CASE): традиционный для констант (приемлемый, но предпочитает camelCase).
Верхний регистр змеи использует слова во всех заглавных буквах, связанных с подчеркиванием. Например, «FIX_ME».

{@a change-detection}

{@a change-detection}
## обнаружение изменений

Механизм, с помощью которого платформа Angular синхронизирует состояние пользовательского интерфейса приложения с состоянием данных.
Детектор изменений проверяет текущее состояние модели данных при каждом ее запуске и сохраняет ее как предыдущее состояние для сравнения на следующей итерации.

Поскольку логика приложения обновляет данные компонента, значения, связанные со свойствами DOM в представлении, могут изменяться.
Детектор изменений отвечает за обновление представления для отображения текущей модели данных.
Точно так же пользователь может взаимодействовать с пользовательским интерфейсом, вызывая события, которые изменяют состояние модели данных.
Эти события могут вызвать обнаружение изменений.

Используя стратегию обнаружения изменений по умолчанию («CheckAlways»), детектор изменений проходит через [просмотр иерархии](#view-tree)на каждом повороте виртуальной машины, чтобы проверить каждое [привязанное к данным свойство](#data-binding)в шаблоне. На первом этапе он сравнивает текущее состояние зависимых данных с предыдущим состоянием и собирает изменения.
На втором этапе обновляется страница DOM для отображения любых новых значений данных.

Если вы установите `OnPush` стратегии обнаружения изменений («CheckOnce») детектор изменений запускается только при [явном вызове] (api / core / ChangeDetectorRef) или при его активации `Input` Изменение ссылки на или обработчик события. Это обычно улучшает производительность. Для получения дополнительной информации см. [Оптимизация обнаружения изменений Angular](https://web.dev/faster-angular-change-detection/).

{@a class-decorator}

{@a class-decorator}
## класс декоратора

[Декоратор](#decorator)который появляется непосредственно перед определением класса, который объявляет класс, чтобы быть данным типа, а также предоставляет метаданные, подходящих к типу.

Следующие декораторы могут объявить Angular типы класса:
* `@Component()` 
* `@Directive()` 
* `@Pipe()` 
* `@Injectable()` 
* `@NgModule()` 


{@a class-field-decorator}

{@a class-field-decorator}
## декоратор поля класса

[Декоратор](#decorator)заявление непосредственно перед полем в определении класса, объявляющий тип этого поля. Некоторые примеры `@Input` и `@Output`.

{@a collection}

{@a collection}
## коллекция

В Angular набор связанных [схем](#schematic)собранных в [пакет npm](#npm-package).

{@a cli}

{@a command-line-interface-cli}
## интерфейс командной строки (CLI)

[Angular CLI](cli)представляет собой инструмент командной строки для управления Angular циклом разработки. С его помощью можно создать исходную файловую систему строительных лесов для [рабочее пространство](#workspace)или [проект](#project), а также для запуска [схемы](#schematic)которые добавляют и модифицируют код для исходных общих версий различных элементов. CLI поддерживает все этапы цикла разработки, включая сборку, тестирование, пакетирование и развертывание.

* Чтобы начать использовать CLI для нового проекта, см. [Настройка локальной среды](guide/setup-local "Setting up for Local Development").
* Чтобы узнать больше о полных возможностях CLI, см. [Справочник по командам CLI](cli).

Смотрите также [Schematics CLI](#schematics-cli).

{@a component}

{@a component}
## компонент

Класс с `@Component()` [декоратор](#decorator)который связывает его с компаньоном [шаблоном](#template). Вместе компонент и шаблон определяют [представление](#view).
Компонент - это особый тип [директива](#directive).
 `@Component() ` расширяет ` @Directive()` с шаблонно-ориентированными функциями.

Класс компонента Angular отвечает за предоставление данных и обработку большей части отображения представления и логики взаимодействия с пользователем через [привязку данных](#data-binding).

Подробнее о компонентах, шаблонах и представлениях см. В разделе [Обзор архитектуры](guide/architecture).

{@a configuration}
## конфигурации

Смотрите [настройка рабочего пространства](#cli-config)


{@a custom-element}

{@a custom-element}
## пользовательский элемент

Функция веб-платформы, которая в настоящее время поддерживается большинством браузеров и доступна в других браузерах через полифиллы (см. браузеров [Поддержка](guide/browser-support)).

Функция пользовательских элементов расширяет HTML, позволяя вам определять тег, содержимое которого создается и контролируется кодом JavaScript. Пользовательский элемент (также называемый *веб-компонентом*) распознается браузером при его добавлении в [CustomElementRegistry](https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry).

Вы можете использовать API для преобразования компонента Angular, чтобы его можно было зарегистрировать в браузере и использовать в любом HTML, который вы добавляете непосредственно в DOM в приложении Angular. Пользовательский тег элемента вставляет представление компонента с функциями обнаружения изменений и привязки данных в контент, который в противном случае отображался бы без Angular обработки.

Смотрите [Angular элемент](#angular-element).

Смотрите также [динамическая загрузка компонентов](#dynamic-components).


{@a D}

{@a data-binding}

{@a data-binding}
## привязка данных

Процесс, который позволяет приложениям отображать значения данных пользователю и отвечать пользователю
действия (такие как щелчки, касания и нажатия клавиш).

При связывании данных вы объявляете связь между HTML-виджетом и источником данных
и позвольте структуре обращаться с деталями.
Привязка данных является альтернативой ручному вводу значений данных приложения в HTML
прослушиватели событий, извлечение измененных значений с экрана и др
обновление значений данных приложения.

Читайте о следующих форм связывания в [Шаблон синтаксиса](guide/template-syntax):

 * [Интерполяция](guide/template-syntax#interpolation)
 * [Недвижимость обязательна](guide/template-syntax#property-binding)
 * [Событие привязки](guide/template-syntax#event-binding)
 * [Привязка атрибутов](guide/template-syntax#attribute-binding)
 * [Класс привязки](guide/template-syntax#class-binding)
 * [Стиль привязки](guide/template-syntax#style-binding)
 * [Двустороннее связывание данных с ngModel](guide/template-syntax#ngModel)

{@a declarable}

{@a declarable}
## объявлению

Тип класса, который вы можете добавить к `declarations` список [NgModule](#ngmodule).
Вы можете объявить [компоненты](#component), [директивы](#directive)и [трубы](#pipe).

Не заявить следующее:
* Класс, который уже объявлен в другом NgModule
* Массив директив, импортированных из другого пакета. Например, не объявляйте `FORMS_DIRECTIVES` от `@angular/forms` 
* Классы NgModule
* Классы обслуживания
* Неангулярные классы и объекты, такие как строки, числа, функции, модели сущностей, конфигурации, бизнес-логика и вспомогательные классы


{@a decorator}

{@a decoration}

{@a decorator-|-decoration}
## декоратор | украшение

Функция, которая изменяет определение класса или свойства. Декораторы (также называемые *аннотациями*) являются экспериментальными (этап 2) [функция языка JavaScript](https://github.com/wycats/javascript-decorators).
TypeScript добавляет поддержку для декораторов.

Angular определяет декораторы, которые прикрепляют метаданные к классам или свойствам
чтобы он знал, что означают эти классы или свойства и как они должны работать.

Смотрите [декоратор класса](#class-decorator), [декоратор поля класса](#class-field-decorator).

{@a di}

{@a dependency-injection}

{@a dependency-injection-di}
## внедрение зависимости (DI)

Шаблон проектирования и механизм для создания и доставки некоторых частей приложения (зависимостей) в другие части приложения, которые в них нуждаются.

В Angular зависимости обычно являются сервисами, но они также могут быть значениями, такими как строки или функции.
[Инжектор](#injector)для приложения (созданного автоматически во время начальной загрузки) инстанцирует зависимости, когда это необходимо, с помощью настроенного [поставщика](#provider)обслуживания или стоимости.

Узнайте больше в [Инъекция зависимости в Angular](guide/dependency-injection).

{@a di-token}

{@a di-token}
## ДИ токен

Маркер поиска, связанный с зависимостью [провайдером](#provider), для использования с [внедрение зависимости)](#di)система.

{@a differential-loading}

{@a differential-loading}
## дифференциальная нагрузка

Техника сборки, которая создает два пакета для приложения. Один меньший пакет предназначен для современных браузеров. Второй, больший пакет позволяет приложению корректно работать в старых браузерах (таких как IE11), которые не поддерживают все современные API браузеров.

Для получения дополнительной информации см. [Развертывание](guide/deployment#differential-loading)Руководство.


{@a directive}
{@a directives}

{@a directive}
## директивы

Класс, который может изменять структуру DOM или изменять атрибуты в DOM и модели данных компонента. Определению директивного класса непосредственно предшествует `@Directive()` [декоратор](#decorator)который предоставляет метаданные.

Класс директивы обычно связан с элементом или атрибутом HTML, и этот элемент или атрибут часто называют самой директивой. Когда Angular находит директиву в HTML [шаблон](#template), он создает соответствующий экземпляр класса директивы и предоставляет экземпляру контроль над этой частью DOM браузера.

Есть три категории директивы:
* [Компоненты](#component)использовать `@Component()` (расширение `@Directive()` ), чтобы связать шаблон с классом.

* [Директивы атрибутов](#attribute-directive)изменяют поведение и внешний вид элементов страницы.

* [Структурные директивы](#structural-directive)изменяют структуру DOM.

Angular предоставляет ряд встроенных директив, которые начинаются с `ng` префикс.
Вы также можете создавать новые директивы для реализации своих собственных функций.
Вы связываете *селектор* (тег HTML, такой как `<my-directive>`) с пользовательской директивой, тем самым расширяя [шаблонный синтаксис](guide/template-syntax)который вы можете использовать в своих приложениях.

{@a dom}

{@a domain-specific-language-dsl}
## предметно-ориентированный язык (DSL)

Специализированная библиотека или API; см. [предметно-ориентированный язык](https://en.wikipedia.org/wiki/Domain-specific_language).
Angular расширяет TypeScript с помощью доменных языков для ряда доменов, относящихся к приложениям Angular, определенных в NgModules, таких как [анимация](guide/animations), [формы](guide/forms)и [маршрутизация и навигация](guide/router).

{@a dynamic-components}

{@a dynamic-component-loading}
## динамическая загрузка компонентов

Методика добавления компонента в DOM во время выполнения. Требуется исключить компонент из компиляции, а затем подключить его к среде обнаружения изменений и обработки событий Angular при добавлении его в DOM.

Смотрите также [пользовательский элемент](#custom-element), который обеспечивает более простой путь с тем же результатом.


{@a E}

{@a eager-loading}

{@a eager-loading}
## нетерпеливая загрузка

NgModules или компоненты, которые загружаются при запуске, называются загруженными, чтобы отличать их от тех
которые загружаются во время выполнения (ленивый загружен).
Смотрите [ленивая загрузка](#lazy-load).


{@a ecma}

{@a ecmascript}
## ECMAScript

[Официальная спецификация языка JavaScript](https://en.wikipedia.org/wiki/ECMAScript).

Не все браузеры поддерживают последний стандарт ECMAScript, но вы можете использовать [транспортер](#transpile)(например, [TypeScript](#typescript)) для написания кода с использованием новейших функций, который затем будет перенесен в код, который работает в версиях, поддерживаемых браузерами.

Чтобы узнать больше, смотрите[Поддержка браузера](guide/browser-support).


{@a element}

{@a element}
## элемент

Angular определяет `ElementRef` Класс для переноса специфичных для визуализации элементов пользовательского интерфейса.
В большинстве случаев это позволяет использовать шаблоны Angular и привязку данных для доступа к элементам DOM
без ссылки на родной элемент.

Документация обычно относится к *элементам* (`ElementRef`), в отличие от *элементов DOM*
(который может быть доступен напрямую, если это необходимо).

Сравните с [пользовательский элемент](#custom-element).

{@a entry-point}

{@a entry-point}
## точка входа

[Модуль JavaScript](#module)который предназначен для импортироваться пользователем [с. НПМ пакета](guide/npm-packages). Модуль точки входа обычно реэкспортирует
символы из других внутренних модулей. Пакет может содержать несколько
точки входа Например, `@angular/core` пакета есть две точки входа
модули, которые можно импортировать, используя имена модулей `@angular/core` и
 `@angular/core/testing`.

{@a F}

{@a form-control}

{@a form-control}
## контроль формы

Экземпляр `FormControl`, который является фундаментальным строительным блоком для Angular форм. Вместе с `FormGroup` и `FormArray`, отслеживает значение, проверку и состояние элемента ввода формы.

Читайте больше форм в [Введение в формы в Angular](guide/forms-overview).

{@a form-model}

{@a form-model}
## модель формы

«Источник правды» для значения и статуса проверки элемента ввода формы в данный момент времени. При использовании [реактивных форм](#reactive-forms)модель формы создается явно в классе компонента. При использовании [управляемых шаблоном форм](#template-driven-forms)модель формы неявно создается директивами.

Узнайте больше о реактивных и шаблонно-управляемых формах в [Введение в формы в Angular](guide/forms-overview).

{@a form-validation}

{@a form-validation}
## проверка формы

Проверка, которая запускается при изменении значений формы и сообщает о правильности и полноте заданных значений в соответствии с заданными ограничениями. Применяются реактивные формы [функции валидатора](guide/form-validation#adding-to-reactive-forms). Использование форм на основе шаблонов [директивы валидатора](guide/form-validation#adding-to-template-driven-forms).


Чтобы узнать больше, см. [Проверка формы](guide/form-validation).

{@a G}


{@a H}

{@a I}


{@a immutability}

{@a immutability}
## неизменность

Возможность изменять состояние значения после его создания. [Реактивные формы](#reactive-forms)выполняют неизменные изменения в этом
каждое изменение модели данных создает новую модель данных, а не изменяет существующую. [Шаблонно-управляемые формы](#template-driven-forms)выполняют изменяемые изменения с `NgModel` и [двусторонняя привязка данных](#data-binding)для изменения существующей модели данных на месте.

{@a injectable}

{@a injectable}
## инъекционный

Класс Angular или другое определение, которое обеспечивает зависимость с помощью [внедрения зависимости](#di)механизма . Инъецируемый [сервисный](#service)класс должен быть помечен `@Injectable()` [декоратор](#decorator). Другие элементы, такие как постоянные значения, также могут быть введены.

{@a injector}

{@a injector}
## инжектор

Объект в Angular [зависимости впрыск](#dependency-injection)системе
который может найти именованную зависимость в своем кеше или создать зависимость
используя настроенный [провайдер](#provider).
Инжекторы создаются для NgModules автоматически как часть процесса начальной загрузки
и наследуются через иерархию компонентов.

* Инжектор предоставляет единственный экземпляр зависимости и может внедрить этот же экземпляр в несколько компонентов.

* Иерархия инжекторов на уровне NgModule и компонентов может предоставлять разные экземпляры зависимости для своих собственных компонентов и дочерних компонентов.

* Можно настроить инжекторы с разными поставщиками, которые могут предоставлять разные реализации одной и той же зависимости.

Узнайте больше об иерархии инжекторов в [Инъекторы иерархической зависимости](guide/hierarchical-dependency-injection).

{@a input}

{@a input}
## вход

При определении [директива](#directive), `@Input()` для свойства директивы
делает это свойство доступно в качестве *мишени* в виде [имущества связывания](guide/template-syntax#property-binding).
Значения данных поступают во входное свойство из идентифицированного источника данных
в [шаблонное выражение](#template-expression)справа от знака равенства.

Чтобы узнать больше, см. [Свойства ввода и вывода](guide/template-syntax#inputs-outputs).

{@a interpolation}

{@a interpolation}
## интерполяция

Форма собственности [привязка данных](#data-binding)в которой[шаблонное выражение](#template-expression)между двойными фигурными скобками отображается как текст.
Этот текст можно объединить с соседним текстом, прежде чем он будет присвоен свойству элемента
или отображается между тегами элемента, как в этом примере.

```html
<label>My current hero is {{hero.name}}</label>
```


Подробнее о читайте [интерполяции](guide/template-syntax#interpolation)в [Синтаксис шаблона](guide/template-syntax).

{@a ivy}

{@a ivy}
## Айви

Ivy - это кодовое имя для Angular [конвейер компиляции и рендеринга следующего поколения](https://blog.angular.io/a-plan-for-version-8-0-and-ivy-b3318dfc19f7).
В версии Angular версии 9 новые инструкции компилятора и среды выполнения используются по умолчанию вместо старых компилятора и среды выполнения, известных как [View Engine](#ve).

Смотри [Angular плющ](guide/ivy),


{@a J}

{@a javascript}

{@a javascript}
## JavaScript

Смотрите [ECMAScript](#ecma), [TypeScript](#typescript).


{@a jit}


{@a just-in-time-jit-compilation}
## Компиляция точно в срок (JIT)

JIT-компилятор Angular преобразует ваш HTML-код и код TypeScript в Angular
эффективный код JavaScript во время выполнения, как часть начальной загрузки.

JIT-компиляция используется по умолчанию (в отличие от AOT-компиляции), когда вы запускаете Angular `ng build ` и ` ng serve` команды CLI и является хорошим выбором при разработке.
Режим JIT настоятельно не рекомендуется для производственного использования
потому что это приводит к большим нагрузкам приложения, которые снижают производительность начальной загрузки.

Сравните с [опережающей (AOT) компиляцией](#aot).


{@a K}


{@a L}

{@a lazy-load}

{@a lazy-loading}
## ленивая загрузка

Процесс, который ускоряет время загрузки приложения, разделяя приложение на несколько пакетов и загружая их по требованию.
Например, зависимости могут быть лениво загружены по мере необходимости - в отличие от[загруженные](#eager-loading)модули, которые требуются корневому модулю и, таким образом, загружаются при запуске.

В [маршрутизатор](#router)использует отложенную загрузку с видом нагрузки ребенка только тогда, когда родительский вид активируется.
Точно так же вы можете создавать пользовательские элементы, которые при необходимости могут быть загружены в приложение Angular.

{@a library}

{@a library}
## библиотека

В Angular, [проект](#project)который предоставляет функциональные возможности, которые могут быть включены в другие приложения Angular.
Библиотека не является полноценным приложением Angular и не может работать независимо.
(Чтобы добавить многократно используемые функции Angular в не-Angular веб-приложения, вы можете использовать Angular [пользовательские элементы](#angular-element).)

* Разработчики библиотеки могут использовать [Angular CLI](#cli)для `generate` леса для новой библиотеки в существующей [рабочей области](#workspace)и может публиковать библиотеку как `npm` Пакет.

* Разработчики приложений могут использовать [Angular CLI](#cli)для `add` опубликованную библиотеку для использования с приложением в том же [рабочее пространство](#workspace).

Смотрите также [схема](#schematic).

{@a lifecycle-hook}

{@a lifecycle-hook}
## жизненный цикл крюка

Интерфейс, который позволяет вам использовать жизненный цикл [директив](#directive)и [компонентов](#component)мере их создания, обновления и уничтожения.

Каждый интерфейс имеет единственный метод подключения, именем которого является имя интерфейса с префиксом `ng`.
Например, `OnInit` интерфейсе есть метод ловушки `ngOnInit`.

Angular вызовы этих методы хуки в следующем порядке:

* `ngOnChanges` : при [входной](#input)/ [выходной](#output)изменении значения привязки.
* `ngOnInit` : после первого `ngOnChanges`.
* `ngDoCheck` : обнаружение пользовательских изменений для разработчика.
* `ngAfterContentInit` : после инициализации содержимого компонента.
* `ngAfterContentChecked` : после каждой проверки содержимого компонента.
* `ngAfterViewInit` : после инициализации представлений компонента.
* `ngAfterViewChecked` : после каждой проверки представлений компонента.
* `ngOnDestroy` : до уничтожения директивы.

Чтобы узнать больше, см. [Lifecycle Hooks](guide/lifecycle-hooks).


{@a M}

{@a module}

{@a module}
## модуль

В общем, модуль собирает блок кода, предназначенный для одной цели. Angular использует стандартные модули JavaScript, а также определяет модуль Angular, `NgModule`.

В JavaScript (ECMAScript) каждый файл является модулем, и все объекты, определенные в файле, принадлежат этому модулю. Объекты можно экспортировать, делая их общедоступными, а общедоступные объекты можно импортировать для использования другими модулями.

Angular поставляется как коллекция модулей JavaScript (также называемых библиотеками). Каждое имя библиотеки Angular начинается с `@angular` префикс. Установите Angular библиотеки с помощью [менеджер пакетов npm](https://docs.npmjs.com/getting-started/what-is-npm)и импортируйте их части с помощью JavaScript `import` декларации.

Сравните с [NgModule](#ngmodule).


{@a N}

{@a ngcc}

{@a ngcc}
## нгкк

Компилятор Angular совместимости.
Если вы создаете свое приложение с использованием [Ivy](#ivy), но это зависит от того, какие библиотеки не были скомпилированы с Ivy, CLI использует `ngcc` для автоматического обновления зависимых библиотек для использования Ivy.


{@a ngmodule}

{@a ngmodule}
## NgModule

Определение класса, которому предшествует `@NgModule()` [декоратор](#decorator), который объявляет и служит манифестом для блока кода, выделенного для домена приложения, рабочего процесса или тесно связанного набора возможностей.

Как и [модуль JavaScript](#module), NgModule может экспортировать функциональные возможности для использования другими NgModules и импортировать открытые функциональные возможности из других NgModules.
Метаданные для класса NgModule собирают компоненты, директивы и каналы, которые приложение использует вместе со списком импорта и экспорта. Смотрите также [декларируемый](#declarable).

NgModules обычно называют в честь файла, в котором определяется экспортируемая вещь. Например, Angular [DatePipe](api/common/DatePipe)класс принадлежит функциональному модулю с именем `date_pipe` в файле `date_pipe.ts` . Вы импортируете их из Angular [пакета с областью действия](#scoped-package)такого как `@angular/core`.

Каждое приложение Angular имеет корневой модуль. По соглашению класс называется `AppModule` и находится в файле с именем `app.module.ts`.

Чтобы узнать больше, см. [NgModules](guide/ngmodules).

{@a npm-package}

{@a npm-package}
## Пакет Npm

[NPM менеджер пакетов](https://docs.npmjs.com/getting-started/what-is-npm)используется для распределения нагрузки и Angular модули и библиотеки.

Узнайте больше о том, как Angular использует [пакеты Npm](guide/npm-packages).

{@a O}

{@a observable}

{@a observable}
## наблюдаемым

Производитель множества значений, к которым он стремится [подписчики](#subscriber), Используется для асинхронной обработки событий по всему Angular. Вы выполняете наблюдаемое, подписавшись на него `subscribe()` Метод, передающий обратные вызовы для уведомлений о новых значениях, ошибках или завершении.

Наблюдаемые могут доставлять подписчикам одно или несколько значений любого типа либо синхронно (так как функция доставляет значение вызывающей стороне), либо по расписанию. Подписчик получает уведомление о новых значениях по мере их появления и уведомление о нормальном завершении или завершении ошибки.

Angular использует стороннюю библиотеку [Reactive Extensions (RxJS)](http://reactivex.io/rxjs/).

Чтобы узнать больше, смотрите [Observables](guide/observables).


{@a observer}

{@a observer}
## наблюдатель

Объект передан `subscribe()` Метод для [наблюдаемого](#observable). Объект определяет обратные вызовы для [подписчика](#subscriber).

{@a output}

{@a output}
## вывод

При определении [директива](#directive), `@Output{}` для свойства директивы
делает это свойство доступно в качестве *мишени* из [связывания событий](guide/template-syntax#event-binding).
События *выходят* из этого свойства на указанный получатель
в [шаблонное выражение](#template-expression)справа от знака равенства.

Чтобы узнать больше, см. [Свойства ввода и вывода](guide/template-syntax#inputs-outputs).


{@a P}

{@a pipe}

{@a pipe}
## труба

Класс, которому предшествует `@Pipe{}` который определяет функцию, которая преобразует входные значения в выходные значения для отображения в [представлении](#view). Angular определяет различные трубы, и вы можете определить новые трубы.

Чтобы узнать больше, см. [Трубы](guide/pipes).

{@a platform}

{@a platform}
## платформы

В терминологии Angular платформа - это контекст, в котором запускается приложение Angular.
Наиболее распространенной платформой для приложений Angular является веб-браузер, но он также может быть операционной системой для мобильного устройства или веб-сервером.

Поддержка различных рабочих платформ Angular обеспечивается `@angular/platform-*` пакеты. Эти пакеты позволяют приложениям, которые используют `@angular/core` и `@angular/common` для выполнения в различных средах, предоставляя реализацию для сбора пользовательского ввода и визуализации пользовательских интерфейсов для данной платформы. Выделение функциональности, специфичной для платформы, позволяет разработчику независимо от платформы использовать остальную часть платформы.

* При запуске в веб-браузере [ `BrowserModule` ](api/platform-browser/BrowserModule)импортируется из `platform-browser` пакет и поддерживает службы, которые упрощают безопасность и обработку событий, а также позволяют приложениям получать доступ к специфическим для браузера функциям, таким как интерпретация ввода с клавиатуры и управление заголовком отображаемого документа. Все приложения, работающие в браузере, используют один и тот же сервис платформы.

* Когда используется [рендеринг на стороне сервера](#server-side-rendering)(SSR), [platform-server"](api/platform-server)пакет предоставляет реализации веб-сервера `DOM`, `XMLHttpRequest` и другие низкоуровневые функции, которые не зависят от браузера.

{@a polyfill}

{@a polyfill}
## полифилл

[НПМ пакет](guide/npm-packages)который подключается пробелы в реализации JavaScript браузера.
См. [Поддержка браузера](guide/browser-support)для полифилов, которые поддерживают определенные функции для определенных платформ.

{@a project}

{@a project}
## проект

В Angular CLI - автономное приложение или [библиотека](#library)которые могут быть созданы или изменены командой CLI.

Проект, сгенерированный [ `ng new` ](cli/new), содержит набор исходных файлов, ресурсов и файлов конфигурации, которые необходимы для разработки и тестирования приложения с использованием CLI. Проекты также могут быть созданы с `ng generate application ` и ` ng generate library` команды.

Для получения дополнительной информации см. [Структура файла проекта](guide/file-structure).

[ `Angular.json` ](guide/workspace-config)файл настраивает все проекты в [рабочем пространстве](#workspace).

{@a provider}

{@a provider}
## провайдер

Объект, который реализует один из [ `Provider` ](api/core/Provider)интерфейсов. Объект провайдера определяет, как получить инъецируемую зависимость, связанную с [токеном DI](#token).
Ан [инжектор](#injector)использует провайдера для создания нового экземпляра зависимости
для класса, который требует этого.

Angular регистрирует своих поставщиков с каждым инжектором для услуг, которые определяет Angular.
Вы можете зарегистрировать своих поставщиков услуг, которые нужны вашему приложению.

Смотрите также [сервис](#service), [внедрение зависимости](#di).

Узнайте больше в [Dependency Injection](guide/dependency-injection).


{@a Q}

{@a R}

{@a reactive-forms}

{@a reactive-forms}
## реактивные формы

Фреймворк для создания Angular форм с помощью кода в компоненте.
Альтернативой является [управляемая шаблоном форма](#template-driven-forms).

При использовании реактивных форм:

* «Источник истины», модель формы, определяется в классе компонентов.
* Валидация устанавливается с помощью функций валидации, а не директив валидации.
* Каждый элемент управления явно создается в классе компонента путем создания `FormControl` вручную или с `FormBuilder`.
* Элементы ввода шаблона*не * используют `ngModel`.
* Связанные Angular директивы имеют префикс `form`, такая как `formControl`, `formGroup`, и `formControlName`.

Альтернативой является шаблонно-управляемая форма. Для ознакомления и сравнения подходов обеих форм см. [Введение в Angular формы](guide/forms-overview).

{@a router}
{@a router-module}

{@a router}
## маршрутизатор

Инструмент, который настраивает и реализует навигацию между состояниями и [представлениями](#view)в приложении Angular.

 `Router` Модуль - это [NgModule](#ngmodule)который предоставляет необходимые поставщики услуг и директивы для навигации по представлениям приложений. [Маршрутизации компонент](#routing-component)является тот, который импортирует `Router` Модуль и чей шаблон содержит `RouterOutlet` Элемент где он может отображать представления, созданные маршрутизатором.

Маршрутизатор определяет навигацию между представлениями на одной странице, в отличие от навигации по страницам. Он интерпретирует URL-подобные ссылки, чтобы определить, какие представления создавать или уничтожать, а также какие компоненты загружать или выгружать. Это позволяет вам использовать [ленивая загрузка](#lazy-load)в ваших приложениях Angular.

Чтобы узнать больше, см. [Маршрутизация и навигация](guide/router).

{@a router-outlet}

{@a router-outlet}
## розетка роутера

A [директива](#directive)это действует как заполнитель в шаблоне компонента маршрутизации. Angular динамически отображает шаблон в зависимости от текущего состояния маршрутизатора.

{@a router-component}

{@a routing-component}
## компонент маршрутизации

Angular [компонент](#component)с `RouterOutlet` Директива в своем шаблоне, которая отображает представления, основанные на навигациях маршрутизатора.

Для получения дополнительной информации см. [Маршрутизация и навигация](guide/router).

{@a rule}

{@a rule}
## править

В [схемы](#schematic)- функция, которая работает с [деревом файлов](#file-tree)для создания, удаления или изменения файлов определенным образом.

{@a S}

{@a schematic}

{@a schematic}
## схема

Библиотека скаффолдинга, которая определяет, как генерировать или преобразовывать программный проект путем создания, изменения, рефакторинга или перемещения файлов и кода.
Схема определяет [правила](#rule)которые работают в виртуальной файловой системе, называемой [деревом](#file-tree).

[Angular CLI](#cli)использует схемы для создания и редактирования [Angular проектов](#project)и части проектов.

* Angular предоставляет набор схем для использования с CLI. См. [Справочник по Angular командам CLI](cli). The [ `ng add` ](cli/add)команда запускает схемы как часть добавления библиотеки в ваш проект. Команда [ `ng generate` ](cli/generate)запускает схемы для создания приложений, библиотек и конструкций кода Angular.

* [библиотеки](#library)Разработчики могут создавать схемы, которые позволяют Angular CLI добавлять и обновлять свои опубликованные библиотеки, а также генерировать артефакты, определяемые библиотекой.
Добавьте эти схемы в пакет npm, который вы используете для публикации и публикации своей библиотеки.

Для получения дополнительной информации см. [Схемы](guide/schematics)и [Интеграция библиотек с CLI](guide/creating-libraries#integrating-with-the-cli).

{@a schematics-cli}

{@a schematics-cli}
## Схемы CLI

Схемы поставляются с собственным инструментом командной строки.
Использование узла 6.9 или выше, установите CLI схемные глобально:

<code-example language="bash">
npm install -g @angular-devkit/schematics-cli
</code-example>

Это устанавливает `schematics` Исполняемый файл, который можно использовать для создания новой схемы [коллекции](#collection)с исходным именем схема. Папка коллекции - это рабочее пространство для схем. Вы также можете использовать `schematics` команда для добавления новой схемы в существующую коллекцию или расширения существующей схемы.

{@a scoped-package}

{@a scoped-package}
## Scoped пакет

Способ группировки связанных [npm пакетов](guide/npm-packages).
Модули Ng поставляются в пакетах с определенной, имена которых начинаются с имени Angular *областью области* `@angular` . Например, `@angular/core`, `@angular/common`, `@angular/forms` и `@angular/router`.

Импортируйте пакет с той же областью, что и обычный пакет.

<code-example path="architecture/src/app/app.component.ts" header="architecture/src/app/app.component.ts (import)" region="import">

</code-example>

{@a server-side-rendering}

{@a server-side-rendering}
## рендеринг на стороне сервера

Техника, которая генерирует статические страницы приложения на сервере и может генерировать и обслуживать эти страницы в ответ на запросы браузеров.
Он также может предварительно генерировать страницы в виде HTML-файлов, которые вы обслуживаете позже.

Этот метод может повысить производительность на мобильных и маломощных устройствах и улучшить взаимодействие с пользователем, быстро показывая статическую первую страницу во время загрузки клиентского приложения.
Статическая версия также может сделать ваше приложение более заметным для веб-сканеров.

Вы можете легко подготовить приложение для рендеринга на стороне сервера, используя [CLI](#cli)для запуска [Angular Universal](#universal)инструмента, используя `@nguniversal/express-engine` [схема](#schematic).


{@a service}

{@a service}
## сервис

В Angular - класс с [@Injectable ()](#injectable)декоратором который инкапсулирует логику и код, не связанные с пользовательским интерфейсом, которые можно повторно использовать в приложении.
Angular отличает компоненты от сервисов для повышения модульности и возможности повторного использования.

 `@Injectable()` позволяют использовать класс обслуживания с [внедрение зависимости](#di)механизмом.
Инъецируемый класс создается экземпляром [провайдером](#provider).
[Инъекторы](#injector)ведут списки поставщиков и используют их для предоставления экземпляров сервисов, когда они требуются компонентами или другими сервисами.

Чтобы узнать больше, см. [Введение в службы и внедрение зависимостей](guide/architecture-services).

{@a structural-directive}
{@a structural-directives}

{@a structural-directives}
## структурные директивы

Категория[директива](#directive)которая отвечает за формирование HTML-макета путем изменения DOM - добавления, удаления или манипулирования элементами и их дочерними элементами.

Чтобы узнать больше, см. [Структурные директивы](guide/structural-directives).

{@a subscriber}

{@a subscriber}
## абонент

Функция, которая определяет, как получать или генерировать значения или сообщения для публикации. Эта функция выполняется, когда потребитель вызывает `subscribe()` Метод [наблюдаемый](#observable).

Подписка на наблюдаемое запускает его выполнение, связывает с ним обратные вызовы и создает `Subscription` Объект который позволяет вам отписаться.

 `subscribe()` метод принимает объект JavaScript (называемый [наблюдатель](#observer)) с точностью до трех обратных вызовов, по одному для каждого типа уведомления о том, что наблюдаемый может поставить:

* `next` уведомлении отправляется значение, например число, строка или объект.
* `error` Уведомление отправляет JavaScript Ошибка или исключение.
* `complete` уведомление не отправляет значение, но обработчик вызывается после завершения вызова. Запланированные значения могут продолжать возвращаться после завершения вызова.

{@a T}

{@a target}

{@a target}
## цель

Встраиваемое или запускаемое подмножество [проект](#project), настроенное как объект в [файл конфигурации рабочей области](guide/workspace-config#project-tool-configuration-options)и выполненное [Архитектор](#architect) [строитель](#builder).

в `angular.json` файле каждый проект имеет раздел «architect», содержащий цели, которые настраивают сборщики. Некоторые из этих целей соответствуют [командам CLI](#cli), таким как `build`, `serve`, `test`, и `lint`.

Например, Архитектор-строитель вызывается `ng build` Команда для компиляции проекта использует определенный инструмент сборки и имеет конфигурацию по умолчанию, значения которой могут быть переопределены в командной строке. `build` Цель также определяет альтернативную конфигурацию для «производственной» сборки, которая может быть вызвана с помощью `--prod` флаг на `build` команду.

Инструмент Архитектор предоставляет набор строителей. Команда [ `ng new` ](cli/new)предоставляет набор целей для начального проекта приложения. [ `Нг генерировать application` ](cli/generate#application)и [ ` нг генерировать library` ](cli/generate#library)команды обеспечивают набор задач для каждого нового [проект](#project). Эти цели, их параметры и конфигурации могут быть настроены в соответствии с потребностями вашего проекта. Например, вы можете добавить «промежуточную» или «тестовую» конфигурацию к цели «сборки» проекта.

Вы также можете определить пользовательского компоновщика и добавить цель в конфигурацию проекта, которая использует ваш компоновщик. Затем вы можете запустить цель, используя команду [ `ng run` ](cli/run)CLI.

{@a template}

{@a template}
## шаблон

Код, связанный с компонентом, который определяет, как визуализировать компонент [представление](#view).

Шаблон сочетает в себе прямой HTML с Angular [привязками данных](#data-binding)синтаксисом, [директивы](#directive),
и [шаблонные выражения](#template-expression)(логические конструкции).
Элементы Angular вставляют или вычисляют значения, которые изменяют элементы HTML, до отображения страницы.

Шаблон связан с [компонентным](#component)классом через `@Component()` [декоратор](#decorator). HTML может быть предоставлен встроенным, как значение `template` свойство или в отдельном HTML-файле, связанном через `templateUrl` свойство.

Дополнительные шаблоны, представленные `TemplateRef` Объекты могут определять альтернативные или *встроенные* представления, на которые можно ссылаться из нескольких компонентов.

{@a template-driven-forms}

{@a template-driven-forms}
## управляемые шаблоном формы

Формат для создания Angular форм с использованием HTML-форм и элементов ввода в представлении.
В альтернативном формате используется структура [реактивные формы](#reactive-forms).

При использовании форм на основе шаблонов:

* «Истиной истины» является шаблон. Проверка определяется с использованием атрибутов на отдельных элементах ввода.
* [Двухстороннее связывание](#data-binding)с `ngModel` поддерживает синхронизацию модели компонента с входом пользователя в элементы ввода.
* За кулисами Angular создает новый элемент управления для каждого элемента ввода, если вы настроили `name` атрибут и двусторонняя привязка для каждого входа.
* Связанные Angular директивы имеют префикс `ng` такие как `ngForm`, `ngModel` и `ngModelGroup`.

Альтернатива - реактивная форма. Для ознакомления и сравнения подходов обеих форм см. [Введение в Angular формы](guide/forms-overview).

{@a template-expression}

{@a template-expression}
## шаблонное выражение

TypeScript-подобный синтаксис, который Angular оценивает внутри [привязка данных](#data-binding).

Прочтите о том, как написать шаблонные выражения в [Шаблонные выражения](guide/template-syntax#template-expressions).

{@a token}

{@a token}
## маркер

Непрозрачный идентификатор, используемый для эффективного поиска в таблице. В Angular [токен DI](#di-token)используется для поиска [поставщиков](#provider)зависимостей в системе [внедрение зависимостей](#di).

{@a transpile}

{@a transpile}
## transpile

Процесс перевода, который преобразует одну версию JavaScript в другую версию; например, понижение уровня ES2015 до более старой версии ES5.

{@a file-tree}

{@a tree}
## дерево

В [схема](#schematic)виртуальная файловая система, представленная `Tree` Класс.
Схемы [правила](#rule)принимают объект дерева в качестве входных данных, оперируют ими и возвращают новый объект дерева.

{@a typescript}

{@a typescript}
## TypeScript

Язык программирования, основанный на JavaScript, который отличается необязательной системой набора текста.
Машинопись обеспечивает время компиляции проверку типов и сильную поддержку оснастки (например
Автозавершения кода, рефакторинг, рядные документации, и интеллектуальный поиск).
Многие редакторы кода и IDE поддерживают TypeScript как изначально, так и с помощью плагинов.

TypeScript является предпочтительным языком для разработки Angular.
Узнайте больше о TypeScript на [typescriptlang.org](http://www.typescriptlang.org/).


{@a U}

{@a universal}

{@a universal}
## Универсальный

Инструмент для реализации [рендеринга на стороне сервера](#server-side-rendering)приложения Angular.
При интеграции с приложением Universal генерирует и обслуживает статические страницы на сервере в ответ на запросы браузеров.
Начальная статическая страница служит быстро загружаемой меткой-заполнителем, пока полное приложение готовится к нормальному выполнению в браузере.

Чтобы узнать больше, смотрите [Angular Universal: рендеринг на стороне сервера](guide/universal).

{@a V}

{@a view}

{@a view}
## смотреть

Наименьшая группировка элементов отображения, которые можно создавать и уничтожать вместе.
Angular делает вид под контролем одного или нескольких [директивы](#directive),
особенно [компонент](#component)директивы и их сопутствующие [шаблоны](#template).

Вид конкретно представлен `ViewRef` связанный с компонентом.
Представление, которое принадлежит компоненту, называется представлением *хоста*.
Представления, как правило, собираются в [просмотр иерархий](#view-tree).

Свойства элементов в представлении могут изменяться динамически в ответ на действия пользователя;
структура (количество и порядок) элементов в представлении не может.
Вы можете изменить структуру элементов, вставляя, перемещая или удаляя вложенные представления в их контейнерах представлений.

Иерархии представлений могут загружаться и выгружаться динамически, когда пользователь перемещается по приложению, как правило, под управлением[роутер](#router).

{@a ve}

{@a view-engine}
## Просмотр двигателя

Конвейер компиляции и рендеринга, используемый Angular до версии 9. Сравнение [Ivy](#ivy).


{@a view-tree}

{@a view-hierarchy}
## Посмотреть иерархию

Дерево связанных видов, которые можно использовать как единое целое. Корневое представление - это представление компонента *узла*. Хост-представление может быть корнем дерева *встроенных представлений*, собранных в *контейнере представлений* (`ViewContainerRef`), прикрепленный к элементу привязки в компоненте хостинга. Иерархия представления является ключевой частью Angular [обнаружение изменений](#change-detection).

Иерархия представления не подразумевает иерархию компонентов. Представления, встроенные в контекст конкретной иерархии, могут быть представлениями узлов других компонентов. Эти компоненты могут находиться в том же NgModule, что и хост-компонент, или принадлежать другим NgModules.

{@a W}
{@a web-component}

{@a web-component}
## веб-компонент

Смотрите [пользовательский элемент](#custom-element).

{@a workspace}

{@a workspace}
## рабочее пространство

Коллекция Angular [проекты](#project)(то есть приложений и библиотек) на основе [Angular CLI] ( #cli), которые обычно размещаются в одном репозитории управления исходным кодом (например, [git](https://git-scm.com/)).

[CLI](#cli) команда [`ng new`](cli/new) создает каталог файловой системы («Рабочая область корневой папки»).  
В корне рабочей области также создается рабочая область [файл конфигурации](#configuration)(`angular.json`) и, по умолчанию, первоначальный проект приложения с тем же именем.

Команды, которые создают или работают с приложениями и библиотеками (такими как `add` и `generate`) должен быть выполнен из папки рабочей области.

Для получения дополнительной информации см. [Настройка рабочей области](guide/workspace-config).

{@a cli-config}

{@a config}

{@a workspace-configuration}
## конфигурация рабочего пространства

Файл с именем `angular.json` на корневом уровне Angular [рабочей области](#workspace)предоставляет настройки конфигурации по умолчанию для всей рабочей области и для проекта для инструментов сборки и разработки, которые предоставляются или интегрированы с [Angular CLI](#cli).

Для получения дополнительной информации см. [Настройка рабочей области](guide/workspace-config).

Дополнительные специфичные для проекта файлы конфигурации используются такими инструментами, как `package.json` для [менеджер пакетов npm](#npm-package), `tsconfig.json` для [перенос TypeScript](#transpile)и `tslint.json` для [TSLint](https://palantir.github.io/tslint/).

Для получения дополнительной информации см. [Рабочая область и структура файла проекта](guide/file-structure).

{@a X}


{@a Y}


{@a Z}
{@a zone}

## zone

Контекст выполнения для набора асинхронных задач. Полезно для отладки, профилирования и тестирования приложений, которые включают асинхронные операции, такие как обработка событий, обещания и вызовы на удаленные серверы.

Приложение Angular работает в зоне, где оно может реагировать на асинхронные события, проверяя изменения данных и обновляя отображаемую информацию путем разрешения [привязки данных](#data-binding).

Клиент зоны может выполнить действие до и после завершения асинхронной операции.

Узнайте больше о зонах в этом
[Брайан Форд видео](https://www.youtube.com/watch?v=3IqtmUscE_U).
