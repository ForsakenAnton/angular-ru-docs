
{@a observables}
# Наблюдаемые

Observables обеспечивают поддержку передачи сообщений между издателями и подписчиками в вашем приложении. Observables предлагают значительные преимущества по сравнению с другими методами обработки событий, асинхронного программирования и обработки нескольких значений.

Наблюдаемые являются декларативными, то есть вы определяете функцию для публикации значений, но она не выполняется, пока потребитель не подпишется на нее. Подписанный потребитель затем получает уведомления, пока функция не завершится или пока они не откажутся от подписки.

Observable может доставлять несколько значений любого типа - литералы, сообщения или события, в зависимости от контекста. API для получения значений одинаков независимо от того, доставляются ли значения синхронно или асинхронно. Поскольку настройка и логика разрыва обрабатываются наблюдаемым, вашему коду приложения нужно беспокоиться только о подписке на использование значений и, когда это будет сделано, отписке. Независимо от того, был ли поток нажатий клавиш, HTTP-ответ или интервальный таймер, интерфейс для прослушивания значений и остановки прослушивания одинаков.

Благодаря этим преимуществам наблюдаемые широко используются в Angular, а также рекомендуются для разработки приложений.

{@a basic-usage-and-terms}
## Основное использование и условия

Как издатель, вы создаете `Observable` экземпляр, который определяет функцию *подписчика* . Это функция, которая выполняется, когда потребитель вызывает `subscribe()` Метод . Функция подписчика определяет, как получать или генерировать значения или сообщения для публикации.

Чтобы выполнить созданную вами заметку и начать получать уведомления, вы вызываете ее `subscribe()` Метод, передавая *наблюдателя*. Это объект JavaScript, который определяет обработчики получаемых вами уведомлений. `subscribe()` вызов возвращает `Subscription` Объект который имеет `unsubscribe()` метод, который вызывается для прекращения получения уведомлений.

Вот пример, который демонстрирует базовую модель использования, показывая, как наблюдаемая может использоваться для предоставления обновлений геолокации.

<code-example class="no-auto-link" path="observables/src/geolocation.ts" header="Observe geolocation updates"></code-example>

{@a defining-observers}
## Определение наблюдателей

Обработчик для получения наблюдаемых уведомлений реализует `Observer` Интерфейс . Это объект, который определяет методы обратного вызова для обработки трех типов уведомлений о том, что наблюдаемая может отправить:

| Тип уведомления | Описание |
| --------- |: ------------------------------------- ------ |
| `next` | Необходимые. Обработчик для каждого доставленного значения. Вызывается ноль или более раз после запуска выполнения.
| `error` | Необязательный. Обработчик для уведомления об ошибке. Ошибка останавливает выполнение наблюдаемого экземпляра.
| `complete` | Необязательный. Обработчик для уведомления о завершении выполнения. Задержанные значения могут продолжать доставляться следующему обработчику после завершения выполнения.

Объект-наблюдатель может определять любую комбинацию этих обработчиков. Если вы не предоставите обработчик для типа уведомления, наблюдатель игнорирует уведомления этого типа.

{@a subscribing}
## Подписавшись

 `Observable` экземпляр начинает публиковать значения только тогда, когда кто-то подписывается на него. Вы подписываетесь по телефону `subscribe()` Метод экземпляра, передающий объект-наблюдатель для получения уведомлений.

<div class="alert is-helpful">

Чтобы показать, как работает подписка, нам нужно создать новую наблюдаемую. Существует конструктор, который можно использовать для создания новых экземпляров, но для иллюстрации, мы можем использовать некоторые методы из библиотеки RxJS, которые создают простые наблюдаемые часто используемые типов:

  * `of(...items) ` возвращает ` Observable` экземпляр, который синхронно доставляет значения, представленные в качестве аргументов.
  * `from(iterable)` преобразует свой аргумент в `Observable` экземпляр. Этот метод обычно используется для преобразования массива в наблюдаемый.

</div>

Вот пример создания и подписавшись на простом наблюдаемый с наблюдателем, который регистрирует принятое сообщение на консоль:

<code-example
  path="observables/src/subscribing.ts"
  region="observer"
  header="Subscribe using observer"></code-example>

В качестве альтернативы `subscribe()` Метод может принимать определения функции обратного вызова в строке, для `next`, `error` и `complete` обработчики. Например, следующее `subscribe()` вызов такой же, как тот, который определяет предопределенный наблюдателя:

<code-example path="observables/src/subscribing.ts" region="sub_fn" header="Subscribe with positional arguments"></code-example>

В любом случае, `next` Требуется обработчик. `error ` и ` complete` обработчики являются необязательными.

Обратите внимание, что `next()` Функция может получать, например, строки сообщений или объекты событий, числовые значения или структуры, в зависимости от контекста. Как общий термин, мы ссылаемся на данные, публикуемые наблюдаемой как *поток*. Любой тип значения может быть представлен наблюдаемой, а значения публикуются в виде потока.

{@a creating-observables}
## Создание наблюдаемых

Использовать `Observable` конструктор для создания наблюдаемого потока любого типа. Конструктор принимает в качестве аргумента функцию подписчика, которая запускается, когда наблюдаемая `subscribe()` Метод выполняется. Функция подписчика получает `Observer` объект, и может публиковать значения в наблюдателя `next()` метод.

Например, чтобы создать наблюдаемый эквивалент `of(1, 2, 3)` выше, вы могли бы сделать что - то вроде этого:

<code-example path="observables/src/creating.ts" region="subscriber" header="Create observable with constructor"></code-example>

Чтобы продолжить этот пример, мы можем создать заметку, которая публикует события. В этом примере функция подписчика определяется встроенной.

<code-example path="observables/src/creating.ts" region="fromevent" header="Create with custom fromEvent function"></code-example>

Теперь вы можете использовать эту функцию для создания наблюдаемого, который публикует KeyDown события:

<code-example path="observables/src/creating.ts" region="fromevent_use" header="Use custom fromEvent function"></code-example>

{@a multicasting}
## Многоадресная рассылка

Типичная наблюдаемая создает новое, независимое выполнение для каждого подписанного наблюдателя. Когда наблюдатель подписывается, наблюдаемый подключает обработчик события и доставляет значения этому наблюдателю. Когда подписывается второй наблюдатель, наблюдаемая затем подключает новый обработчик событий и доставляет значения этому второму наблюдателю в отдельном исполнении.

Иногда вместо того, чтобы запускать независимое выполнение для каждого подписчика, вы хотите, чтобы каждая подписка получала одинаковые значения, даже если значения уже начали излучаться. Это может иметь место с чем-то вроде наблюдаемых кликов на объекте документа.

*Multicasting* это практика трансляции на список нескольких подписчиков в одном исполнении. Благодаря наблюдаемой многоадресной рассылке вы не регистрируете несколько прослушивателей в документе, а вместо этого повторно используете первый прослушиватель и отправляете значения каждому подписчику.

При создании наблюдаемой вы должны определить, как вы хотите, чтобы эта наблюдаемая использовалась и хотите ли вы многоадресно передавать ее значения.

Давайте посмотрим на пример, который насчитывает от 1 до 3 с задержкой в ​​одну секунду после каждого испускаемого числа.

<code-example path="observables/src/multicasting.ts" region="delay_sequence" header="Create a delayed sequence"></code-example>

Обратите внимание, что если вы подпишетесь дважды, будет два отдельных потока, каждый из которых будет выдавать значения каждую секунду. Это выглядит примерно так:

<code-example path="observables/src/multicasting.ts" region="subscribe_twice" header="Two subscriptions"></code-example>

Изменение наблюдаемого быть мультикастинг может выглядеть примерно так:

<code-example path="observables/src/multicasting.ts" region="multicast_sequence" header="Create a multicast subscriber"></code-example>

<div class="alert is-helpful">
   Набираемые параметры многоадресной рассылки требуют немного больше настройки, но они могут быть полезны для определенных приложений. Позже мы рассмотрим инструменты, которые упрощают процесс многоадресной рассылки, позволяя вам взять любое наблюдаемое и сделать его многоадресным.
</div>

{@a error-handling}
## Обработка ошибок

Поскольку наблюдаемые производят значения асинхронно, try / catch не будет эффективно отлавливать ошибки. Вместо этого вы обрабатываете ошибки, указывая `error` обратного вызова на наблюдателя. Создание ошибки также приводит к тому, что наблюдаемое очищает подписки и прекращает создавать значения. Наблюдаемый может производить значения (вызывая `next` обратный вызов), или он может завершиться, вызывая либо `complete` или `error` обратного вызова.

<code-example>
myObservable.subscribe({
  next(num) { console.log('Next num: ' + num)},
  error(err) { console.log('Received an errror: ' + err)}
});
</code-example>

Обработка ошибок (и, в частности, восстановление после ошибки) более подробно рассматривается в следующем разделе.
