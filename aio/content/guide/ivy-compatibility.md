{@a ivy-compatibility-guide}
# Руководство по совместимости Ivy

Команда Angular усердно работала над тем, чтобы гарантировать, что Ivy максимально совместим с предыдущим механизмом рендеринга («View Engine»).
Однако, в редких случаях, небольшие изменения были необходимы, чтобы гарантировать, что поведение Angular было предсказуемым и последовательным, исправляя проблемы в реализации View Engine.
Чтобы сгладить переход, мы предусмотрели [автоматические миграции](guide/updating-to-version-9#migrations)везде, где это было возможно, чтобы код вашего приложения и библиотеки автоматически переносился с помощью CLI.
Тем не менее, некоторые приложения, вероятно, должны будут применить некоторые обновления вручную.

{@a debugging}
{@a how-to-debug-errors-with-ivy}
## Как отлаживать ошибки с помощью Ivy

В версии 9 [некоторые устаревшие API были удалены](guide/updating-to-version-9#removals)и есть [несколько критических изменений](guide/updating-to-version-9#breaking-changes)не связанных с Ivy.
Если после обновления до версии 9 вы видите ошибки, сначала нужно исключить эти изменения.

Для этого временно [выключите Ivy](guide/ivy#opting-out-of-angular-ivy)в вашем `tsconfig.json` и перезапустите ваше приложение.

Если вы все еще видите ошибки, они не относятся только к Ivy. В этом случае вы можете обратиться к [общее руководство по версии 9](guide/updating-to-version-9). Если вы выбрали какие-либо из более строгих настроек проверки типов, которые появились в v9, вы также можете проверить [руководство по проверке типов шаблонов](guide/template-typecheck).

Если ошибки исчезли, вернитесь к Ivy, удалив изменения в `tsconfig.json` и просмотрите список ожидаемых изменений ниже.

{@a payload-size-debugging}
{@a payload-size-debugging}
### Отладка размера полезной нагрузки

Если вы заметили, что размер основного пучка вашего приложения увеличился с Айви, вы можете проверить следующее:

1. Убедитесь, что компоненты и `NgModules` которые вы хотите загружать с загрузкой, импортируются только в отложенные модули.
Все, что вы импортируете вне ленивых модулей, может оказаться в основном комплекте.
Подробности смотрите в оригинальном номере [здесь](https://github.com/angular/angular-cli/issues/16146#issuecomment-557559287).

1. Убедитесь, что импортированные библиотеки помечены как свободные от побочных эффектов.
Если ваше приложение импортирует из общих библиотек, которые не имеют побочных эффектов, добавьте «sideEffects»: false к их `package.json`.
Это гарантирует, что библиотеки будут должным образом потрясены деревом, если они импортированы, но на них нет прямой ссылки.
Подробности смотрите в оригинальном номере [здесь](https://github.com/angular/angular-cli/issues/16799#issuecomment-580912090).

1. Проекты, не использующие Angular CLI, увидят значительную регрессию размера, если они не обновят свои настройки минификаторов и не установят константы времени компиляции `ngDevMode`, `ngI18nClosureMode` и `ngJitMode` to `false` (для Terser, пожалуйста, установите их на `false` через [опция конфигурации `global_defs` ](https://terser.org/docs/api-reference.html#conditional-compilation)).
Обратите внимание, что эти константы не предназначены для использования сторонней библиотекой или кодом приложения, поскольку они не являются частью нашей общедоступной API-интерфейса и могут измениться в будущем.


{@a common-changes}
{@a changes-you-may-see}
### Изменения, которые вы можете увидеть

* По умолчанию, `@ContentChildren` Запросы будут искать только прямые дочерние узлы в иерархии DOM (ранее они поиск на любом уровне вложенности в DOM, если над ним не найдена другая директива). Смотрите далее [подробности](guide/ivy-compatibility-examples#content-children-descendants).

* Все классы, которые используют Angular DI, должны иметь Angular-декоратор, такой как `@Directive()` или `@Injectable` (ранее недекорированные классы были разрешены только в режиме AOT или при использовании флагов внедрения). Смотрите далее [подробности](guide/ivy-compatibility-examples#undecorated-classes).

* Несвязанные входные данные для директив (например, имя в `<my-comp name="">`) теперь устанавливаются при создании представления перед запуском обнаружения изменений (ранее все входы были установлены при обнаружении изменений).

* Статические атрибуты, установленные непосредственно в HTML шаблона, будут переопределять любые конфликтующие атрибуты хоста, установленные директивами или компонентами (ранее статические атрибуты хоста, установленные директивами / компонентами, переопределяли статические атрибуты шаблона в случае конфликта).

{@a less-common-changes}
{@a less-common-changes}
### Менее распространенные изменения

* Свойства как `host` внутри `@Component` и `@Directive` декораторы могут быть унаследованы (ранее, только свойства с явными полевыми декораторами, такими как `@HostBinding` будет наследоваться).

* Поддержка HammerJS осуществляется через импорт `HammerModule` (ранее он всегда включался в рабочие пакеты независимо от того, использовало ли приложение HammerJS).

* `@ContentChild ` и ` @ContentChildren` Запросы больше не смогут соответствовать собственному узлу их директивы (ранее эти запросы соответствовали узлу узла в дополнение к его содержимого).

* Если токен введен с `@Host` или `@Self` Флаг, для инжектора модуля этот токен не ищется (ранее токены, помеченные этими флагами, все еще находились на уровне модуля).

* При доступе к нескольким локальным ссылкам с одним и тем же именем в привязках к шаблону сопоставляется первый (ранее сопоставлялся последний экземпляр).

* Директивы, которые используются в экспортируемом модуле (но не экспортируются сами), экспортируются публично (ранее компилятор автоматически записывал частный экспорт с псевдонимом, чтобы он мог использовать свои глобальные знания для разрешения нисходящего потока).

* Внешние функции или внешние константы в метаданных декоратора не могут быть статически разрешены (ранее вы могли импортировать константу или функцию из другого модуля компиляции, например из библиотеки, и использовать эту константу / функцию в своем `@NgModule` определение).

* Прямые ссылки на входы директив, доступные через локальные ссылки, по умолчанию больше не поддерживаются.

* Если есть и несвязанный атрибут класса и `[class]` привязка, классы в несвязанном атрибуте также будут добавлены (ранее привязка классов перезаписывала классы в несвязанном атрибуте).

* Теперь ошибочно назначать значения переменным только для шаблона, таким как `item` в `ngFor="let item of items"` (ранее компилятор игнорировал эти назначения).

* Больше невозможно перезаписывать ловушки жизненного цикла при помощи макетов на экземплярах директив для тестирования (вместо этого измените ловушку жизненного цикла на самом типе директивы).

* Специальные токены для инъекций (такие как `TemplateRef` или `ViewContainerRef`) возвращает новый экземпляр всякий раз, когда они запрашиваются (ранее экземпляры специальных токенов передавались по запросу на том же узле). Это в первую очередь влияет на тесты, которые проводят сравнение идентичности этих объектов.

* Синтаксический анализ ICU происходит во время выполнения, поэтому в случаях ICU разрешен только текст, теги HTML и текстовые привязки (ранее директивы также разрешались внутри ICU).

* Добавление текстовых привязок в переводы i18n, которых нет в самом исходном шаблоне, приведет к ошибке времени выполнения (ранее, включая дополнительные привязки в переводах, было разрешено).

* Дополнительные теги HTML в переводах i18n, которых нет в самом исходном шаблоне, будут отображаться как обычный текст (ранее эти теги отображались как HTML).

* Поставщики отформатированы как `{provide: X} ` без ` useValue `, ` useFactory `, ` useExisting ` или ` useClass` свойство обрабатывается как `{provide: X, useClass: X}` (ранее по умолчанию `{provide: X, useValue: undefined}`).

* `DebugElement.attributes ` возвращается ` undefined` для атрибутов, которые были добавлены, а затем впоследствии удалены (ранее атрибуты, добавленные, а затем удаленные, имели бы значение `null`).

* `DebugElement.classes ` возвращается ` undefined` для классов, которые были добавлены, а затем удалены (ранее классы, добавленные, а затем удаленные, имели бы значение `false`)

* При выборе родного `<option>` элемент в `<select>` где `<option>` создаются через `*ngFor`, используйте `[selected]` свойство `<option>` вместо привязки к `[value]` свойство `<select>` элемент (ранее вы могли привязать к любому.) [подробнее](guide/ivy-compatibility-examples#select-value-binding)

* Встроенные представления (например, созданные `*ngFor`) теперь вставляются перед узлом комментария DOM (например, `<!--ng-for-of-->`), а не за этим, как было ранее.
В большинстве случаев это не оказывает никакого влияния на визуализированный DOM.
В некоторых случаях (например, анимации, задерживающие удаление встроенного вида), любые новые встроенные виды будут вставлены после того, как встроенный вид будет удален.
Эта разница сохраняется только в то время, когда анимация активна, и может изменить внешний вид анимации.
Как только анимация закончится, полученная отрисованная модель DOM будет идентична визуализированной с помощью View Engine.
